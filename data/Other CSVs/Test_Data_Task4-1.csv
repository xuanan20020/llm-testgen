FQN,Signature,Jimple,Callees,MethodModifiers,ClassModifiers,JavaDoc,MethodBody,Imports,classJavaDoc,classFnCs
org.apache.commons.lang3.CharRange$CharacterIterator.prepareNext(),void prepareNext(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1; $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack2; $stack20; $stack21; $stack22; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack2 = staticinvoke <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)>($stack1);\n\n    if $stack2 == 0 goto label4;\n    $stack9 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n\n    if $stack9 != 65535 goto label1;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n    goto label6;\n\n  label1:\n    $stack10 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack13 = $stack10 + 1;\n    $stack11 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack12 = staticinvoke <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)>($stack11);\n\n    if $stack13 != $stack12 goto label3;\n    $stack17 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack18 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack17);\n\n    if $stack18 != 65535 goto label2;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n    goto label6;\n\n  label2:\n    $stack19 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack20 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack19);\n    $stack21 = $stack20 + 1;\n    $stack22 = (char) $stack21;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack22;\n\n    goto label6;\n\n  label3:\n    $stack14 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack15 = $stack14 + 1;\n    $stack16 = (char) $stack15;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack16;\n\n    goto label6;\n\n  label4:\n    $stack4 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack3 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack5 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack3);\n\n    if $stack4 >= $stack5 goto label5;\n    $stack6 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack7 = $stack6 + 1;\n    $stack8 = (char) $stack7;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack8;\n\n    goto label6;\n\n  label5:\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n  label6:\n    return;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)> via $stack2 = staticinvoke <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)>($stack1);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)> via $stack12 = staticinvoke <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)>($stack11);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack18 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack17);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack20 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack19);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack5 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack3);,[private ],[private ; static ],Prepare the next character in the range.\n,{\n    if (range.negated) {\n        if (current == Character.MAX_VALUE) {\n            hasNext = false;\n        } else if (current + 1 == range.start) {\n            if (range.end == Character.MAX_VALUE) {\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = (char) (current + 1);\n        }\n    } else if (current < range.end) {\n        current = (char) (current + 1);\n    } else {\n        hasNext = false;\n    }\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n
org.apache.commons.lang3.CharRange$CharacterIterator.next(),java.lang.Object next(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = virtualinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()>();\n\n    return $stack1;\n}\n,,[public ],[private ; static ],Return the next character in the iteration\n\n@return {@code Character} for the next character\n,{\n    if (hasNext == false) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n
org.apache.commons.lang3.CharRange$CharacterIterator.next(),java.lang.Character next(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack2; $stack3; $stack4; cur;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack2 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext>;\n\n    if $stack2 != 0 goto label1;\n    $stack4 = new java.util.NoSuchElementException;\n    specialinvoke $stack4.<java.util.NoSuchElementException: void <init>()>();\n\n    throw $stack4;\n\n  label1:\n    cur = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    specialinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()>();\n    $stack3 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(cur);\n\n    return $stack3;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <java.util.NoSuchElementException: void <init>()> via specialinvoke $stack4.<java.util.NoSuchElementException: void <init>()>();\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> via specialinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()>();\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <java.lang.Character: java.lang.Character valueOf(char)> via $stack3 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(cur);,[public ],[private ; static ],Return the next character in the iteration\n\n@return {@code Character} for the next character\n,{\n    if (hasNext == false) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n
org.apache.commons.lang3.CharRange$CharacterIterator.hasNext(),boolean hasNext(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext>;\n\n    return $stack1;\n}\n,,[public ],[private ; static ],Has the iterator not reached the end character yet?\n\n@return {@code true} if the iterator has yet to reach the character date\n,{\n    return hasNext;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n
org.apache.commons.lang3.CharRange$CharacterIterator.remove(),void remove(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = new java.lang.UnsupportedOperationException;\n    specialinvoke $stack1.<java.lang.UnsupportedOperationException: void <init>()>();\n\n    throw $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: void remove()> -> <java.lang.UnsupportedOperationException: void <init>()> via specialinvoke $stack1.<java.lang.UnsupportedOperationException: void <init>()>();,[public ],[private ; static ],Always throws UnsupportedOperationException.\n\n@throws UnsupportedOperationException\n@see java.util.Iterator#remove()\n,{\n    throw new UnsupportedOperationException();\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n
"org.apache.commons.lang3.CharSetUtils.keep(java.lang.String, java.lang.String[])","java.lang.String keep(java.lang.String,java.lang.String[])","{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack2; $stack3; $stack4;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n\n    if str != null goto label1;\n\n    return null;\n\n  label1:\n    $stack2 = virtualinvoke str.<java.lang.String: boolean isEmpty()>();\n\n    if $stack2 != 0 goto label2;\n    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack3 == 0 goto label3;\n\n  label2:\n    return "";\n\n  label3:\n    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 1);\n\n    return $stack4;\n}\n",Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <java.lang.String: boolean isEmpty()> via $stack2 = virtualinvoke str.<java.lang.String: boolean isEmpty()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> via $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 1);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand keeps any of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.keep(null; *)        = null\nCharSetUtils.keep(""; *)          = ""\nCharSetUtils.keep(*; null)        = ""\nCharSetUtils.keep(*; "")          = ""\nCharSetUtils.keep(hello""; ""hl"")  = ""hll""\nCharSetUtils.keep(""hello""; ""le"")  = ""ell""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to keep characters from; may be null\n@param set String[] set of characters to keep; may be null\n@return the modified String; {@code null} if null string input\n@since 2.0\n""",{\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    return modify(str; set; true);\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
"org.apache.commons.lang3.CharSetUtils.squeeze(java.lang.String, java.lang.String[])","java.lang.String squeeze(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack9; buffer; ch; chars; chrs; i; lastChar; sz;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack9 != 0 goto label1;\n    $stack10 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack10 == 0 goto label2;\n\n  label1:\n    return str;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    $stack12 = new java.lang.StringBuilder;\n    $stack11 = virtualinvoke str.<java.lang.String: int length()>();\n    specialinvoke $stack12.<java.lang.StringBuilder: void <init>(int)>($stack11);\n    buffer = $stack12;\n    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    sz = lengthof chrs;\n    lastChar = 32;\n    ch = 32;\n    i = 0;\n\n  label3:\n    if i >= sz goto label6;\n    ch = chrs[i];\n\n    if ch != lastChar goto label4;\n\n    if i == 0 goto label4;\n    $stack14 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(ch);\n\n    if $stack14 == 0 goto label4;\n\n    goto label5;\n\n  label4:\n    virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(ch);\n    lastChar = ch;\n\n  label5:\n    i = i + 1;\n\n    goto label3;\n\n  label6:\n    $stack13 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack13;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack10 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.String: int length()> via $stack11 = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack12.<java.lang.StringBuilder: void <init>(int)>($stack11);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(ch);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack13 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack14 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(ch);,[public ; static ],[public ],"<p>Squeezes any repetitions of a character that is mentioned in the\nsupplied set.</p>\n\n<pre>\nCharSetUtils.squeeze(null; *)        = null\nCharSetUtils.squeeze(""; *)          = ""\nCharSetUtils.squeeze(*; null)        = *\nCharSetUtils.squeeze(*; "")          = *\nCharSetUtils.squeeze(hello""; ""k-p"") = ""helo""\nCharSetUtils.squeeze(""hello""; ""a-e"") = ""hello""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str the string to squeeze; may be null\n@param set the character set to use for manipulation; may be null\n@return the modified String; {@code null} if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    char lastChar = ' ';\n    char ch = ' ';\n    for (int i = 0; i < sz; i++) {\n        ch = chrs[i];\n        // Compare with contains() last for performance.\n        if (ch == lastChar && i != 0 && chars.contains(ch)) {\n            continue;\n        }\n        buffer.append(ch);\n        lastChar = ch;\n    }\n    return buffer.toString();\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
org.apache.commons.lang3.CharSetUtils.deepEmpty(java.lang.String[]),boolean deepEmpty(java.lang.String[]),{\n    java.lang.String[] strings;\n    unknown $stack5; l1; l2; l3; s;\n\n\n    strings := @parameter0: java.lang.String[];\n\n    if strings == null goto label3;\n    l1 = strings;\n    l2 = lengthof l1;\n    l3 = 0;\n\n  label1:\n    if l3 >= l2 goto label3;\n    s = l1[l3];\n    $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);\n\n    if $stack5 == 0 goto label2;\n\n    return 0;\n\n  label2:\n    l3 = l3 + 1;\n\n    goto label1;\n\n  label3:\n    return 1;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);,[private ; static ],[public ],Determines whether or not all the Strings in an array are \nempty or not.\n\n@param strings String[] whose elements are being checked for emptiness\n@return whether or not the String is empty\n,{\n    if (strings != null) {\n        for (final String s : strings) {\n            if (StringUtils.isNotEmpty(s)) {\n                return false;\n            }\n        }\n    }\n    return true;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
"org.apache.commons.lang3.CharSetUtils.modify(java.lang.String, java.lang.String[], boolean)","java.lang.String modify(java.lang.String,java.lang.String[],boolean)",{\n    boolean expect;\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack8; $stack9; buffer; chars; chrs; i; sz;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    expect := @parameter2: boolean;\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    $stack9 = new java.lang.StringBuilder;\n    $stack8 = virtualinvoke str.<java.lang.String: int length()>();\n    specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\n    buffer = $stack9;\n    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    sz = lengthof chrs;\n    i = 0;\n\n  label1:\n    if i >= sz goto label3;\n    $stack11 = chrs[i];\n    $stack12 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>($stack11);\n\n    if $stack12 != expect goto label2;\n    $stack13 = chrs[i];\n    virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack13);\n\n  label2:\n    i = i + 1;\n\n    goto label1;\n\n  label3:\n    $stack10 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack10;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.String: int length()> via $stack8 = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.String: char[] toCharArray()> via chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack13);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack10 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack12 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>($stack11);,[private ; static ],[public ],Implementation of delete and keep\n\n@param str String to modify characters within\n@param set String[] set of characters to modify\n@param expect whether to evaluate on match; or non-match\n@return the modified String; not null\n,{\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i]) == expect) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
"org.apache.commons.lang3.CharSetUtils.count(java.lang.String, java.lang.String[])","int count(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack8; $stack9; c; chars; count; l4; l5; l6;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack8 != 0 goto label1;\n    $stack9 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack9 == 0 goto label2;\n\n  label1:\n    return 0;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    count = 0;\n    l4 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    l5 = lengthof l4;\n    l6 = 0;\n\n  label3:\n    if l6 >= l5 goto label5;\n    c = l4[l6];\n    $stack10 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);\n\n    if $stack10 == 0 goto label4;\n    count = count + 1;\n\n  label4:\n    l6 = l6 + 1;\n\n    goto label3;\n\n  label5:\n    return count;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack9 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via l4 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack10 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand returns the number of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.count(null; *)        = 0\nCharSetUtils.count(""; *)          = 0\nCharSetUtils.count(*; null)        = 0\nCharSetUtils.count(*; "")          = 0\nCharSetUtils.count(hello""; ""k-p"") = 3\nCharSetUtils.count(""hello""; ""a-e"") = 1\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to count characters in; may be null\n@param set String[] set of characters to count; may be null\n@return the character count; zero if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
"org.apache.commons.lang3.CharSetUtils.containsAny(java.lang.String, java.lang.String[])","boolean containsAny(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack7; $stack8; $stack9; c; chars; l3; l4; l5;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label1;\n    $stack8 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack8 == 0 goto label2;\n\n  label1:\n    return 0;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    l3 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    l4 = lengthof l3;\n    l5 = 0;\n\n  label3:\n    if l5 >= l4 goto label5;\n    c = l3[l5];\n    $stack9 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);\n\n    if $stack9 == 0 goto label4;\n\n    return 1;\n\n  label4:\n    l5 = l5 + 1;\n\n    goto label3;\n\n  label5:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack8 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via l3 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack9 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand identifies whether any of the characters are present in the specified string.</p>\n\n<pre>\nCharSetUtils.containsAny(null; *)        = false\nCharSetUtils.containsAny(""; *)          = false\nCharSetUtils.containsAny(*; null)        = false\nCharSetUtils.containsAny(*; "")          = false\nCharSetUtils.containsAny(hello""; ""k-p"") = true\nCharSetUtils.containsAny(""hello""; ""a-d"") = false\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to look for characters in; may be null\n@param set String[] set of characters to identify; may be null\n@return whether or not the characters in the set are in the primary string\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return false;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            return true;\n        }\n    }\n    return false;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
"org.apache.commons.lang3.CharSetUtils.delete(java.lang.String, java.lang.String[])","java.lang.String delete(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack2; $stack3; $stack4;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack2 != 0 goto label1;\n    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack3 == 0 goto label2;\n\n  label1:\n    return str;\n\n  label2:\n    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 0);\n\n    return $stack4;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> via $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 0);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand deletes any of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.delete(null; *)        = null\nCharSetUtils.delete(""; *)          = ""\nCharSetUtils.delete(*; null)        = *\nCharSetUtils.delete(*; "")          = *\nCharSetUtils.delete(hello""; ""hl"")  = ""eo""\nCharSetUtils.delete(""hello""; ""le"")  = ""ho""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to delete characters from; may be null\n@param set String[] set of characters to delete; may be null\n@return the modified String; {@code null} if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str; set; false);\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n
org.apache.commons.lang3.CharRange.contains(org.apache.commons.lang3.CharRange),boolean contains(org.apache.commons.lang3.CharRange),"{\n    org.apache.commons.lang3.CharRange range; this;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack2; $stack20; $stack21; $stack22; $stack23; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    range := @parameter0: org.apache.commons.lang3.CharRange;\n\n    if range != null goto label01;\n    $stack23 = new java.lang.IllegalArgumentException;\n    specialinvoke $stack23.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(The Range must not be null"");\n\n    throw $stack23;\n\n  label01:\n    $stack2 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack2 == 0 goto label08;\n    $stack12 = range.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack12 == 0 goto label04;\n    $stack19 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack18 = range.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack19 < $stack18 goto label02;\n    $stack21 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack20 = range.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack21 > $stack20 goto label02;\n    $stack22 = 1;\n\n    goto label03;\n\n  label02:\n    $stack22 = 0;\n\n  label03:\n    return $stack22;\n\n  label04:\n    $stack14 = range.<org.apache.commons.lang3.CharRange: char end>;\n    $stack13 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack14 < $stack13 goto label05;\n    $stack16 = range.<org.apache.commons.lang3.CharRange: char start>;\n    $stack15 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack16 <= $stack15 goto label06;\n\n  label05:\n    $stack17 = 1;\n\n    goto label07;\n\n  label06:\n    $stack17 = 0;\n\n  label07:\n    return $stack17;\n\n  label08:\n    $stack3 = range.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack3 == 0 goto label11;\n    $stack9 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack9 != 0 goto label09;\n    $stack10 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack10 != 65535 goto label09;\n    $stack11 = 1;\n\n    goto label10;\n\n  label09:\n    $stack11 = 0;\n\n  label10:\n    return $stack11;\n\n  label11:\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack4 = range.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack5 > $stack4 goto label12;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack6 = range.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack7 < $stack6 goto label12;\n    $stack8 = 1;\n\n    goto label13;\n\n  label12:\n    $stack8 = 0;\n\n  label13:\n    return $stack8;\n}\n""","Call:<org.apache.commons.lang3.CharRange: boolean contains(org.apache.commons.lang3.CharRange)> -> <java.lang.IllegalArgumentException: void <init>(java.lang.String)> via specialinvoke $stack23.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(The Range must not be null"");""",[public ],[final ],<p>Are all the characters of the passed in range contained in\nthis range.</p>\n\n@param range the range to check against\n@return {@code true} if this range entirely contains the input range\n@throws IllegalArgumentException if {@code null} input\n,"{\n    if (range == null) {\n        throw new IllegalArgumentException(The Range must not be null"");\n    }\n    if (negated) {\n        if (range.negated) {\n            return start >= range.start && end <= range.end;\n        }\n        return range.end < start || range.start > end;\n    }\n    if (range.negated) {\n        return start == 0 && end == Character.MAX_VALUE;\n    }\n    return start <= range.start && end >= range.end;\n}""",[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.is(char),org.apache.commons.lang3.CharRange is(char),{\n    char ch;\n    unknown $stack1;\n\n\n    ch := @parameter0: char;\n    $stack1 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 0);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange is(char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 0);,[public ; static ],[final ],<p>Constructs a {@code CharRange} over a single character.</p>\n\n@param ch only character in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(ch; ch; false);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.iterator(),java.util.Iterator iterator(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = new org.apache.commons.lang3.CharRange$CharacterIterator;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)>(this; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: java.util.Iterator iterator()> -> <org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)>(this; null);,[public ],[final ],<p>Returns an iterator which can be used to walk through the characters described by this range.</p>\n\n<p>#NotThreadSafe# the iterator is not thread-safe</p>\n\n@return an iterator to the chars represented by this range\n@since 2.5\n,{\n    return new CharacterIterator(this);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.hashCode(),int hashCode(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1; $stack2; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack3 = 83 + $stack1;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack4 = 7 * $stack2;\n    $stack6 = $stack3 + $stack4;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack5 == 0 goto label1;\n    $stack8 = 1;\n\n    goto label2;\n\n  label1:\n    $stack8 = 0;\n\n  label2:\n    $stack7 = $stack6 + $stack8;\n\n    return $stack7;\n}\n,,[public ],[final ],<p>Gets a hashCode compatible with the equals method.</p>\n\n@return a suitable hashCode\n,{\n    return 83 + start + 7 * end + (negated ? 1 : 0);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.getEnd(),char getEnd(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Gets the end character for this character range.</p>\n\n@return the end char (inclusive)\n,{\n    return this.end;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.isNegated(),boolean isNegated(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Is this {@code CharRange} negated.</p>\n\n<p>A negated range includes everything except that defined by the\nstart and end characters.</p>\n\n@return {@code true} if negated\n,{\n    return negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
"org.apache.commons.lang3.CharRange.isNotIn(char, char)","org.apache.commons.lang3.CharRange isNotIn(char,char)",{\n    char end; start;\n    unknown $stack2;\n\n\n    start := @parameter0: char;\n    end := @parameter1: char;\n    $stack2 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 1);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isNotIn(char;char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 1);,[public ; static ],[final ],<p>Constructs a negated {@code CharRange} over a set of characters.</p>\n\n@param start first character; inclusive; in this range\n@param end last character; inclusive; in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(start; end; true);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.equals(java.lang.Object),boolean equals(java.lang.Object),{\n    java.lang.Object obj;\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack10; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9; other;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    obj := @parameter0: java.lang.Object;\n\n    if obj != this goto label1;\n\n    return 1;\n\n  label1:\n    $stack3 = obj instanceof org.apache.commons.lang3.CharRange;\n\n    if $stack3 != 0 goto label2;\n\n    return 0;\n\n  label2:\n    other = (org.apache.commons.lang3.CharRange) obj;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack4 = other.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack5 != $stack4 goto label3;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack6 = other.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack7 != $stack6 goto label3;\n    $stack9 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n    $stack8 = other.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack9 != $stack8 goto label3;\n    $stack10 = 1;\n\n    goto label4;\n\n  label3:\n    $stack10 = 0;\n\n  label4:\n    return $stack10;\n}\n,,[public ],[final ],<p>Compares two CharRange objects; returning true if they represent\nexactly the same range of characters defined in the same way.</p>\n\n@param obj the object to compare to\n@return true if equal\n,{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof CharRange == false) {\n        return false;\n    }\n    final CharRange other = (CharRange) obj;\n    return start == other.start && end == other.end && negated == other.negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
"org.apache.commons.lang3.CharRange.isIn(char, char)","org.apache.commons.lang3.CharRange isIn(char,char)",{\n    char end; start;\n    unknown $stack2;\n\n\n    start := @parameter0: char;\n    end := @parameter1: char;\n    $stack2 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 0);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isIn(char;char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 0);,[public ; static ],[final ],<p>Constructs a {@code CharRange} over a set of characters.</p>\n\n@param start first character; inclusive; in this range\n@param end last character; inclusive; in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(start; end; false);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.getStart(),char getStart(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Gets the start character for this character range.</p>\n\n@return the start char (inclusive)\n,{\n    return this.start;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.contains(char),boolean contains(char),{\n    char ch;\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack2; $stack3; $stack4; $stack5; $stack6;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    ch := @parameter0: char;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if ch < $stack2 goto label1;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if ch > $stack5 goto label1;\n    $stack6 = 1;\n\n    goto label2;\n\n  label1:\n    $stack6 = 0;\n\n  label2:\n    $stack3 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack6 == $stack3 goto label3;\n    $stack4 = 1;\n\n    goto label4;\n\n  label3:\n    $stack4 = 0;\n\n  label4:\n    return $stack4;\n}\n,,[public ],[final ],<p>Is the character specified contained in this range.</p>\n\n@param ch the character to check\n@return {@code true} if this range contains the input character\n,{\n    return (ch >= start && ch <= end) != negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.isNot(char),org.apache.commons.lang3.CharRange isNot(char),{\n    char ch;\n    unknown $stack1;\n\n\n    ch := @parameter0: char;\n    $stack1 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 1);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isNot(char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 1);,[public ; static ],[final ],<p>Constructs a negated {@code CharRange} over a single character.</p>\n\n@param ch only character in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(ch; ch; true);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.CharRange.toString(),java.lang.String toString(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack10; $stack2; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9; buf;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;\n\n    if $stack2 != null goto label3;\n    $stack4 = new java.lang.StringBuilder;\n    specialinvoke $stack4.<java.lang.StringBuilder: void <init>(int)>(4);\n    buf = $stack4;\n    $stack5 = virtualinvoke this.<org.apache.commons.lang3.CharRange: boolean isNegated()>();\n\n    if $stack5 == 0 goto label1;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(94);\n\n  label1:\n    $stack6 = this.<org.apache.commons.lang3.CharRange: char start>;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack6);\n    $stack8 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack8 == $stack7 goto label2;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(45);\n    $stack10 = this.<org.apache.commons.lang3.CharRange: char end>;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack10);\n\n  label2:\n    $stack9 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.String toString()>();\n    this.<org.apache.commons.lang3.CharRange: java.lang.String iToString> = $stack9;\n\n  label3:\n    $stack3 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;\n\n    return $stack3;\n}\n,Call:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack4.<java.lang.StringBuilder: void <init>(int)>(4);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(94);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack6);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(45);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack10);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack9 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.String toString()>();,[public ],[final ],<p>Gets a string representation of the character range.</p>\n\n@return string representation of this range\n,{\n    if (iToString == null) {\n        final StringBuilder buf = new StringBuilder(4);\n        if (isNegated()) {\n            buf.append('^');\n        }\n        buf.append(start);\n        if (start != end) {\n            buf.append('-');\n            buf.append(end);\n        }\n        iToString = buf.toString();\n    }\n    return iToString;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n
org.apache.commons.lang3.concurrent.AtomicInitializer.initialize(),java.lang.Object initialize(),,,[protected ; abstract ],[public ; abstract ],Creates and initializes the object managed by this {@code\nAtomicInitializer}. This method is called by {@link #get()} when the\nmanaged object is not available yet. An implementation can focus on the\ncreation of the object. No synchronization is needed; as this is already\nhandled by {@code get()}. As stated by the class comment; it is possible\nthat this method is called multiple times.\n\n@return the managed data object\n@throws ConcurrentException if an error occurs during object creation\n,,[import java.util.concurrent.atomic.AtomicReference;\n],<p>\nA specialized implementation of the {@code ConcurrentInitializer} interface\nbased on an {@link AtomicReference} variable.\n</p>\n<p>\nThis class maintains a member field of type {@code AtomicReference}. It\nimplements the following algorithm to create and initialize an object in its\n{@link #get()} method:\n<ul>\n<li>First it is checked whether the {@code AtomicReference} variable contains\nalready a value. If this is the case; the value is directly returned.</li>\n<li>Otherwise the {@link #initialize()} method is called. This method must be\ndefined in concrete subclasses to actually create the managed object.</li>\n<li>After the object was created by {@link #initialize()} it is checked\nwhether the {@code AtomicReference} variable is still undefined. This has to\nbe done because in the meantime another thread may have initialized the\nobject. If the reference is still empty; the newly created object is stored\nin it and returned by this method.</li>\n<li>Otherwise the value stored in the {@code AtomicReference} is returned.</li>\n</ul>\n</p>\n<p>\nBecause atomic variables are used this class does not need any\nsynchronization. So there is no danger of deadlock; and access to the managed\nobject is efficient. However; if multiple threads access the {@code\nAtomicInitializer} object before it has been initialized almost at the same\ntime; it can happen that {@link #initialize()} is called multiple times. The\nalgorithm outlined above guarantees that {@link #get()} always returns the\nsame object though.\n</p>\n<p>\nCompared with the {@link LazyInitializer} class; this class can be more\nefficient because it does not need synchronization. The drawback is that the\n{@link #initialize()} method can be called multiple times which may be\nproblematic if the creation of the managed object is expensive. As a rule of\nthumb this initializer implementation is preferable if there are not too many\nthreads involved and the probability that multiple threads access an\nuninitialized object is small. If there is high parallelism;\n{@link LazyInitializer} is more appropriate.\n</p>\n\n@since 3.0\n@version $Id$\n@param <T> the type of the object managed by this initializer class\n,/**\n * Holds the reference to the managed object.\n */\nprivate final AtomicReference<T> reference = new AtomicReference<T>();\n\n
org.apache.commons.lang3.concurrent.AtomicInitializer.get(),java.lang.Object get(),{\n    org.apache.commons.lang3.concurrent.AtomicInitializer this;\n    unknown $stack2; $stack3; $stack4; $stack5; result;\n\n\n    this := @this: org.apache.commons.lang3.concurrent.AtomicInitializer;\n    $stack2 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    result = virtualinvoke $stack2.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\n\n    if result != null goto label1;\n    result = virtualinvoke this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object initialize()>();\n    $stack3 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    $stack4 = virtualinvoke $stack3.<java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)>(null; result);\n\n    if $stack4 != 0 goto label1;\n    $stack5 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    result = virtualinvoke $stack5.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\n\n  label1:\n    return result;\n}\n,Call:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: java.lang.Object get()> via result = virtualinvoke $stack2.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\nCall:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)> via $stack4 = virtualinvoke $stack3.<java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)>(null; result);\nCall:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: java.lang.Object get()> via result = virtualinvoke $stack5.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();,[public ],[public ; abstract ],Returns the object managed by this initializer. The object is created if\nit is not available yet and stored internally. This method always returns\nthe same object.\n\n@return the object created by this {@code AtomicInitializer}\n@throws ConcurrentException if an error occurred during initialization of\nthe object\n,{\n    T result = reference.get();\n    if (result == null) {\n        result = initialize();\n        if (!reference.compareAndSet(null; result)) {\n            // another thread has initialized the reference\n            result = reference.get();\n        }\n    }\n    return result;\n},[import java.util.concurrent.atomic.AtomicReference;\n],<p>\nA specialized implementation of the {@code ConcurrentInitializer} interface\nbased on an {@link AtomicReference} variable.\n</p>\n<p>\nThis class maintains a member field of type {@code AtomicReference}. It\nimplements the following algorithm to create and initialize an object in its\n{@link #get()} method:\n<ul>\n<li>First it is checked whether the {@code AtomicReference} variable contains\nalready a value. If this is the case; the value is directly returned.</li>\n<li>Otherwise the {@link #initialize()} method is called. This method must be\ndefined in concrete subclasses to actually create the managed object.</li>\n<li>After the object was created by {@link #initialize()} it is checked\nwhether the {@code AtomicReference} variable is still undefined. This has to\nbe done because in the meantime another thread may have initialized the\nobject. If the reference is still empty; the newly created object is stored\nin it and returned by this method.</li>\n<li>Otherwise the value stored in the {@code AtomicReference} is returned.</li>\n</ul>\n</p>\n<p>\nBecause atomic variables are used this class does not need any\nsynchronization. So there is no danger of deadlock; and access to the managed\nobject is efficient. However; if multiple threads access the {@code\nAtomicInitializer} object before it has been initialized almost at the same\ntime; it can happen that {@link #initialize()} is called multiple times. The\nalgorithm outlined above guarantees that {@link #get()} always returns the\nsame object though.\n</p>\n<p>\nCompared with the {@link LazyInitializer} class; this class can be more\nefficient because it does not need synchronization. The drawback is that the\n{@link #initialize()} method can be called multiple times which may be\nproblematic if the creation of the managed object is expensive. As a rule of\nthumb this initializer implementation is preferable if there are not too many\nthreads involved and the probability that multiple threads access an\nuninitialized object is small. If there is high parallelism;\n{@link LazyInitializer} is more appropriate.\n</p>\n\n@since 3.0\n@version $Id$\n@param <T> the type of the object managed by this initializer class\n,/**\n * Holds the reference to the managed object.\n */\nprivate final AtomicReference<T> reference = new AtomicReference<T>();\n\n
"org.apache.commons.lang3.text.translate.CodePointTranslator.translate(java.lang.CharSequence, int, java.io.Writer)","int translate(java.lang.CharSequence,int,java.io.Writer)",{\n    int index;\n    java.io.Writer out;\n    java.lang.CharSequence input;\n    org.apache.commons.lang3.text.translate.CodePointTranslator this;\n    unknown codepoint; consumed;\n\n\n    this := @this: org.apache.commons.lang3.text.translate.CodePointTranslator;\n    input := @parameter0: java.lang.CharSequence;\n    index := @parameter1: int;\n    out := @parameter2: java.io.Writer;\n    codepoint = staticinvoke <java.lang.Character: int codePointAt(java.lang.CharSequence;int)>(input; index);\n    consumed = virtualinvoke this.<org.apache.commons.lang3.text.translate.CodePointTranslator: boolean translate(int;java.io.Writer)>(codepoint; out);\n\n    if consumed == 0 goto label1;\n\n    return 1;\n\n  label1:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.text.translate.CodePointTranslator: int translate(java.lang.CharSequence;int;java.io.Writer)> -> <java.lang.Character: int codePointAt(java.lang.CharSequence;int)> via codepoint = staticinvoke <java.lang.Character: int codePointAt(java.lang.CharSequence;int)>(input; index);,[public ; final ],[public ; abstract ],Implementation of translate that maps onto the abstract translate(int; Writer) method. \n{@inheritDoc}\n,{\n    final int codepoint = Character.codePointAt(input; index);\n    final boolean consumed = translate(codepoint; out);\n    if (consumed) {\n        return 1;\n    } else {\n        return 0;\n    }\n},[import java.io.IOException;\n; import java.io.Writer;\n],Helper subclass to CharSequenceTranslator to allow for translations that \nwill replace up to one character at a time.\n\n@since 3.0\n@version $Id$\n,
"org.apache.commons.lang3.text.translate.CodePointTranslator.translate(int, java.io.Writer)","boolean translate(int,java.io.Writer)",,,[public ; abstract ],[public ; abstract ],Translate the specified codepoint into another.\n\n@param codepoint int character input to translate\n@param out Writer to optionally push the translated output to\n@return boolean as to whether translation occurred or not\n@throws IOException if and only if the Writer produces an IOException\n,,[import java.io.IOException;\n; import java.io.Writer;\n],Helper subclass to CharSequenceTranslator to allow for translations that \nwill replace up to one character at a time.\n\n@since 3.0\n@version $Id$\n,
"org.apache.commons.lang3.text.WordUtils.isDelimiter(char, char[])","boolean isDelimiter(char,char[])",{\n    char ch;\n    char[] delimiters;\n    unknown $stack6; delimiter; l2; l3; l4;\n\n\n    ch := @parameter0: char;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    $stack6 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\n\n    return $stack6;\n\n  label1:\n    l2 = delimiters;\n    l3 = lengthof l2;\n    l4 = 0;\n\n  label2:\n    if l4 >= l3 goto label4;\n    delimiter = l2[l4];\n\n    if ch != delimiter goto label3;\n\n    return 1;\n\n  label3:\n    l4 = l4 + 1;\n\n    goto label2;\n\n  label4:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> -> <java.lang.Character: boolean isWhitespace(char)> via $stack6 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);,[private ; static ],[public ],Is the character a delimiter.\n\n@param ch the character to check\n@param delimiters the delimiters\n@return true if it is a delimiter\n,{\n    if (delimiters == null) {\n        return Character.isWhitespace(ch);\n    }\n    for (final char delimiter : delimiters) {\n        if (ch == delimiter) {\n            return true;\n        }\n    }\n    return false;\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String),java.lang.String capitalizeFully(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Converts all the whitespace separated words in a String into capitalized words; \nthat is each word is made up of a titlecase character and then a series of \nlowercase characters.  </p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalizeFully(null)        = null\nWordUtils.capitalizeFully("")          = ""\nWordUtils.capitalizeFully(i am FINE"") = ""I Am Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@return capitalized String; <code>null</code> if null String input\n""",{\n    return capitalizeFully(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String, char[])","java.lang.String capitalizeFully(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack3; $stack4; delimLen;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack3 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    str = virtualinvoke str.<java.lang.String: java.lang.String toLowerCase()>();\n    $stack4 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; delimiters);\n\n    return $stack4;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <java.lang.String: java.lang.String toLowerCase()> via str = virtualinvoke str.<java.lang.String: java.lang.String toLowerCase()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> via $stack4 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Converts all the delimiter separated words in a String into capitalized words; \nthat is each word is made up of a titlecase character and then a series of \nlowercase characters. </p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be capitalized. </p>\n\n<p>A <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalizeFully(null; *)            = null\nWordUtils.capitalizeFully(""; *)              = ""\nWordUtils.capitalizeFully(*; null)            = *\nWordUtils.capitalizeFully(*; new char[0])     = *\nWordUtils.capitalizeFully(i aM.fine""; {'.'}) = ""I am.Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@param delimiters set of characters to determine capitalization; null means whitespace\n@return capitalized String; <code>null</code> if null String input\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str; delimiters);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String, char[])","java.lang.String uncapitalize(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack7; $stack8; $stack9; buffer; ch; delimLen; i; uncapitalizeNext;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    uncapitalizeNext = 1;\n    i = 0;\n\n  label5:\n    $stack8 = lengthof buffer;\n\n    if i >= $stack8 goto label8;\n    ch = buffer[i];\n    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack10 == 0 goto label6;\n    uncapitalizeNext = 1;\n\n    goto label7;\n\n  label6:\n    if uncapitalizeNext == 0 goto label7;\n    $stack11 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack11;\n    uncapitalizeNext = 0;\n\n  label7:\n    i = i + 1;\n\n    goto label5;\n\n  label8:\n    $stack9 = new java.lang.String;\n    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack9;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.Character: char toLowerCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Uncapitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed.</p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be uncapitalized. </p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.uncapitalize(null; *)            = null\nWordUtils.uncapitalize(""; *)              = ""\nWordUtils.uncapitalize(*; null)            = *\nWordUtils.uncapitalize(*; new char[0])     = *\nWordUtils.uncapitalize(I AM.FINE""; {'.'}) = ""i AM.fINE""\n</pre>\n\n@param str the String to uncapitalize; may be null\n@param delimiters set of characters to determine uncapitalization; null means whitespace\n@return uncapitalized String; <code>null</code> if null String input\n@see #capitalize(String)\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch; delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
org.apache.commons.lang3.text.WordUtils.swapCase(java.lang.String),java.lang.String swapCase(java.lang.String),{\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack5; $stack6; $stack7; $stack8; $stack9; buffer; ch; i; whitespace;\n\n\n    str := @parameter0: java.lang.String;\n    $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack5 == 0 goto label1;\n\n    return str;\n\n  label1:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    whitespace = 1;\n    i = 0;\n\n  label2:\n    $stack6 = lengthof buffer;\n\n    if i >= $stack6 goto label8;\n    ch = buffer[i];\n    $stack8 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(ch);\n\n    if $stack8 == 0 goto label3;\n    $stack14 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack14;\n    whitespace = 0;\n\n    goto label7;\n\n  label3:\n    $stack9 = staticinvoke <java.lang.Character: boolean isTitleCase(char)>(ch);\n\n    if $stack9 == 0 goto label4;\n    $stack13 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack13;\n    whitespace = 0;\n\n    goto label7;\n\n  label4:\n    $stack10 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(ch);\n\n    if $stack10 == 0 goto label6;\n\n    if whitespace == 0 goto label5;\n    $stack12 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\n    buffer[i] = $stack12;\n    whitespace = 0;\n\n    goto label7;\n\n  label5:\n    $stack11 = staticinvoke <java.lang.Character: char toUpperCase(char)>(ch);\n    buffer[i] = $stack11;\n\n    goto label7;\n\n  label6:\n    whitespace = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\n\n  label7:\n    i = i + 1;\n\n    goto label2;\n\n  label8:\n    $stack7 = new java.lang.String;\n    specialinvoke $stack7.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack7;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isUpperCase(char)> via $stack8 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toLowerCase(char)> via $stack14 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isTitleCase(char)> via $stack9 = staticinvoke <java.lang.Character: boolean isTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toLowerCase(char)> via $stack13 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isLowerCase(char)> via $stack10 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toTitleCase(char)> via $stack12 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toUpperCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toUpperCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isWhitespace(char)> via whitespace = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack7.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Swaps the case of a String using a word based algorithm.</p>\n\n<ul>\n <li>Upper case character converts to Lower case</li>\n <li>Title case character converts to Lower case</li>\n <li>Lower case character after Whitespace or at start converts to Title case</li>\n <li>Other Lower case character converts to Upper case</li>\n</ul>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nStringUtils.swapCase(null)                 = null\nStringUtils.swapCase("")                   = ""\nStringUtils.swapCase(The dog has a BONE"") = ""tHE DOG HAS A bone""\n</pre>\n\n@param str the String to swap case; may be null\n@return the changed String; <code>null</code> if null String input\n""",{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                buffer[i] = Character.toTitleCase(ch);\n                whitespace = false;\n            } else {\n                buffer[i] = Character.toUpperCase(ch);\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int)","java.lang.String wrap(java.lang.String,int)",{\n    int wrapLength;\n    java.lang.String str;\n    unknown $stack2;\n\n\n    str := @parameter0: java.lang.String;\n    wrapLength := @parameter1: int;\n    $stack2 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)>(str; wrapLength; null; 0);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> via $stack2 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)>(str; wrapLength; null; 0);,[public ; static ],[public ],"<p>Wraps a single line of text; identifying words by <code>' '</code>.</p>\n\n<p>New lines will be separated by the system property line separator.\nVery long words; such as URLs will <i>not</i> be wrapped.</p>\n\n<p>Leading spaces on a new line are stripped.\nTrailing spaces are not stripped.</p>\n\n<pre>\nWordUtils.wrap(null; *) = null\nWordUtils.wrap(""; *) = ""\n</pre>\n\n@param str the String to be word wrapped; may be null\n@param wrapLength the column to wrap the words at; less than 1 is treated as 1\n@return a line with newlines inserted; <code>null</code> if null input\n",{\n    return wrap(str; wrapLength; null; false);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int, java.lang.String, boolean)","java.lang.String wrap(java.lang.String,int,java.lang.String,boolean)",{\n    boolean wrapLongWords;\n    int wrapLength;\n    java.lang.String newLineStr; str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack20; $stack8; $stack9; inputLineLength; offset; spaceToWrapAt; wrappedLine;\n\n\n    str := @parameter0: java.lang.String;\n    wrapLength := @parameter1: int;\n    newLineStr := @parameter2: java.lang.String;\n    wrapLongWords := @parameter3: boolean;\n\n    if str != null goto label01;\n\n    return null;\n\n  label01:\n    if newLineStr != null goto label02;\n    newLineStr = <org.apache.commons.lang3.SystemUtils: java.lang.String LINE_SEPARATOR>;\n\n  label02:\n    if wrapLength >= 1 goto label03;\n    wrapLength = 1;\n\n  label03:\n    inputLineLength = virtualinvoke str.<java.lang.String: int length()>();\n    offset = 0;\n    $stack9 = new java.lang.StringBuilder;\n    $stack8 = inputLineLength + 32;\n    specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\n    wrappedLine = $stack9;\n\n  label04:\n    $stack10 = inputLineLength - offset;\n\n    if $stack10 <= wrapLength goto label10;\n    $stack13 = virtualinvoke str.<java.lang.String: char charAt(int)>(offset);\n\n    if $stack13 != 32 goto label05;\n    offset = offset + 1;\n\n    goto label04;\n\n  label05:\n    $stack14 = wrapLength + offset;\n    spaceToWrapAt = virtualinvoke str.<java.lang.String: int lastIndexOf(int;int)>(32; $stack14);\n\n    if spaceToWrapAt < offset goto label06;\n    $stack20 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack20);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = spaceToWrapAt + 1;\n\n    goto label09;\n\n  label06:\n    if wrapLongWords == 0 goto label07;\n    $stack18 = wrapLength + offset;\n    $stack19 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; $stack18);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack19);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = offset + wrapLength;\n\n    goto label09;\n\n  label07:\n    $stack15 = wrapLength + offset;\n    spaceToWrapAt = virtualinvoke str.<java.lang.String: int indexOf(int;int)>(32; $stack15);\n\n    if spaceToWrapAt < 0 goto label08;\n    $stack17 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack17);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = spaceToWrapAt + 1;\n\n    goto label09;\n\n  label08:\n    $stack16 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack16);\n    offset = inputLineLength;\n\n  label09:\n    goto label04;\n\n  label10:\n    $stack11 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack11);\n    $stack12 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack12;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int length()> via inputLineLength = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: char charAt(int)> via $stack13 = virtualinvoke str.<java.lang.String: char charAt(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int lastIndexOf(int;int)> via spaceToWrapAt = virtualinvoke str.<java.lang.String: int lastIndexOf(int;int)>(32; $stack14);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack20 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack20);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack19 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; $stack18);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack19);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int indexOf(int;int)> via spaceToWrapAt = virtualinvoke str.<java.lang.String: int indexOf(int;int)>(32; $stack15);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack17 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack17);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int)> via $stack16 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack16);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int)> via $stack11 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack11);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack12 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <org.apache.commons.lang3.SystemUtils: void <clinit>()> via newLineStr = <org.apache.commons.lang3.SystemUtils: java.lang.String LINE_SEPARATOR>;,[public ; static ],[public ],"<p>Wraps a single line of text; identifying words by <code>' '</code>.</p>\n\n<p>Leading spaces on a new line are stripped.\nTrailing spaces are not stripped.</p>\n\n<pre>\nWordUtils.wrap(null; *; *; *) = null\nWordUtils.wrap(""; *; *; *) = ""\n</pre>\n\n@param str the String to be word wrapped; may be null\n@param wrapLength the column to wrap the words at; less than 1 is treated as 1\n@param newLineStr the string to insert for a new line; \n <code>null</code> uses the system property line separator\n@param wrapLongWords true if long words (such as URLs) should be wrapped\n@return a line with newlines inserted; <code>null</code> if null input\n",{\n    if (str == null) {\n        return null;\n    }\n    if (newLineStr == null) {\n        newLineStr = SystemUtils.LINE_SEPARATOR;\n    }\n    if (wrapLength < 1) {\n        wrapLength = 1;\n    }\n    final int inputLineLength = str.length();\n    int offset = 0;\n    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n    while (inputLineLength - offset > wrapLength) {\n        if (str.charAt(offset) == ' ') {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = str.lastIndexOf(' '; wrapLength + offset);\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(offset; spaceToWrapAt));\n            wrappedLine.append(newLineStr);\n            offset = spaceToWrapAt + 1;\n        } else {\n            // really long word or URL\n            if (wrapLongWords) {\n                // wrap really long word one line at a time\n                wrappedLine.append(str.substring(offset; wrapLength + offset));\n                wrappedLine.append(newLineStr);\n                offset += wrapLength;\n            } else {\n                // do not wrap really long word; just extend beyond limit\n                spaceToWrapAt = str.indexOf(' '; wrapLength + offset);\n                if (spaceToWrapAt >= 0) {\n                    wrappedLine.append(str.substring(offset; spaceToWrapAt));\n                    wrappedLine.append(newLineStr);\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    wrappedLine.append(str.substring(offset));\n                    offset = inputLineLength;\n                }\n            }\n        }\n    }\n    // Whatever is left in line is short enough to just pass through\n    wrappedLine.append(str.substring(offset));\n    return wrappedLine.toString();\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String),java.lang.String capitalize(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Capitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed. To convert the \nrest of each word to lowercase at the same time; \nuse {@link #capitalizeFully(String)}.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalize(null)        = null\nWordUtils.capitalize("")          = ""\nWordUtils.capitalize(i am FINE"") = ""I Am FINE""\n</pre>\n\n@param str the String to capitalize; may be null\n@return capitalized String; <code>null</code> if null String input\n@see #uncapitalize(String)\n@see #capitalizeFully(String)\n""",{\n    return capitalize(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
org.apache.commons.lang3.text.WordUtils.initials(java.lang.String),java.lang.String initials(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Extracts the initial letters from each word in the String.</p>\n\n<p>The first letter of the string and all first letters after\nwhitespace are returned as a new string.\nTheir case is not changed.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.initials(null)             = null\nWordUtils.initials("")               = ""\nWordUtils.initials(Ben John Lee"")   = ""BJL""\nWordUtils.initials(""Ben J.Lee"")      = ""BJ""\n</pre>\n\n@param str the String to get initials from; may be null\n@return String of initial letters; <code>null</code> if null String input\n@see #initials(String;char[])\n@since 2.2\n""",{\n    return initials(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String, char[])","java.lang.String capitalize(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack7; $stack8; $stack9; buffer; capitalizeNext; ch; delimLen; i;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    capitalizeNext = 1;\n    i = 0;\n\n  label5:\n    $stack8 = lengthof buffer;\n\n    if i >= $stack8 goto label8;\n    ch = buffer[i];\n    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack10 == 0 goto label6;\n    capitalizeNext = 1;\n\n    goto label7;\n\n  label6:\n    if capitalizeNext == 0 goto label7;\n    $stack11 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\n    buffer[i] = $stack11;\n    capitalizeNext = 0;\n\n  label7:\n    i = i + 1;\n\n    goto label5;\n\n  label8:\n    $stack9 = new java.lang.String;\n    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack9;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.Character: char toTitleCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Capitalizes all the delimiter separated words in a String.\nOnly the first letter of each word is changed. To convert the \nrest of each word to lowercase at the same time; \nuse {@link #capitalizeFully(String; char[])}.</p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be capitalized. </p>\n\n<p>A <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalize(null; *)            = null\nWordUtils.capitalize(""; *)              = ""\nWordUtils.capitalize(*; new char[0])     = *\nWordUtils.capitalize(i am fine""; null)  = ""I Am Fine""\nWordUtils.capitalize(""i aM.fine""; {'.'}) = ""I aM.Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@param delimiters set of characters to determine capitalization; null means whitespace\n@return capitalized String; <code>null</code> if null String input\n@see #uncapitalize(String)\n@see #capitalizeFully(String)\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch; delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String),java.lang.String uncapitalize(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Uncapitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.uncapitalize(null)        = null\nWordUtils.uncapitalize("")          = ""\nWordUtils.uncapitalize(I Am FINE"") = ""i am fINE""\n</pre>\n\n@param str the String to uncapitalize; may be null\n@return uncapitalized String; <code>null</code> if null String input\n@see #capitalize(String)\n""",{\n    return uncapitalize(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
"org.apache.commons.lang3.text.WordUtils.initials(java.lang.String, char[])","java.lang.String initials(java.lang.String,char[])","{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack8; $stack9; buf; ch; count; i; lastWasGap; strLen;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack8 == 0 goto label1;\n\n    return str;\n\n  label1:\n    if delimiters == null goto label2;\n    $stack14 = lengthof delimiters;\n\n    if $stack14 != 0 goto label2;\n\n    return "";\n\n  label2:\n    strLen = virtualinvoke str.<java.lang.String: int length()>();\n    $stack9 = strLen / 2;\n    $stack10 = $stack9 + 1;\n    buf = newarray (char)[$stack10];\n    count = 0;\n    lastWasGap = 1;\n    i = 0;\n\n  label3:\n    if i >= strLen goto label6;\n    ch = virtualinvoke str.<java.lang.String: char charAt(int)>(i);\n    $stack12 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack12 == 0 goto label4;\n    lastWasGap = 1;\n\n    goto label5;\n\n  label4:\n    if lastWasGap == 0 goto label5;\n    $stack13 = count;\n    count = count + 1;\n    buf[$stack13] = ch;\n    lastWasGap = 0;\n\n  label5:\n    i = i + 1;\n\n    goto label3;\n\n  label6:\n    $stack11 = new java.lang.String;\n    specialinvoke $stack11.<java.lang.String: void <init>(char[];int;int)>(buf; 0; count);\n\n    return $stack11;\n}\n",Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: int length()> via strLen = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: char charAt(int)> via ch = virtualinvoke str.<java.lang.String: char charAt(int)>(i);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack12 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: void <init>(char[];int;int)> via specialinvoke $stack11.<java.lang.String: void <init>(char[];int;int)>(buf; 0; count);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Extracts the initial letters from each word in the String.</p>\n\n<p>The first letter of the string and all first letters after the\ndefined delimiters are returned as a new string.\nTheir case is not changed.</p>\n\n<p>If the delimiters array is null; then Whitespace is used.\nWhitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nAn empty delimiter array returns an empty String.</p>\n\n<pre>\nWordUtils.initials(null; *)                = null\nWordUtils.initials(""; *)                  = ""\nWordUtils.initials(Ben John Lee""; null)   = ""BJL""\nWordUtils.initials(""Ben J.Lee""; null)      = ""BJ""\nWordUtils.initials(""Ben J.Lee""; [' ';'.']) = ""BJL""\nWordUtils.initials(*; new char[0])         = """"\n</pre>\n\n@param str the String to get initials from; may be null\n@param delimiters set of characters to determine words; null means whitespace\n@return String of initial letters; <code>null</code> if null String input\n@see #initials(String)\n@since 2.2\n""","{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return "";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch; delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n            continue;\n        }\n    }\n    return new String(buf; 0; count);\n}",[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n"""
