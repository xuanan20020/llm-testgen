FQN,Signature,Jimple,Callees,MethodModifiers,ClassModifiers,JavaDoc,MethodBody,Imports,classJavaDoc,classFnCs,Generated Code,Code After Formatting,Saved Path
org.apache.commons.lang3.CharRange$CharacterIterator.prepareNext(),void prepareNext(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1; $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack2; $stack20; $stack21; $stack22; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack2 = staticinvoke <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)>($stack1);\n\n    if $stack2 == 0 goto label4;\n    $stack9 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n\n    if $stack9 != 65535 goto label1;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n    goto label6;\n\n  label1:\n    $stack10 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack13 = $stack10 + 1;\n    $stack11 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack12 = staticinvoke <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)>($stack11);\n\n    if $stack13 != $stack12 goto label3;\n    $stack17 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack18 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack17);\n\n    if $stack18 != 65535 goto label2;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n    goto label6;\n\n  label2:\n    $stack19 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack20 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack19);\n    $stack21 = $stack20 + 1;\n    $stack22 = (char) $stack21;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack22;\n\n    goto label6;\n\n  label3:\n    $stack14 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack15 = $stack14 + 1;\n    $stack16 = (char) $stack15;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack16;\n\n    goto label6;\n\n  label4:\n    $stack4 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack3 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: org.apache.commons.lang3.CharRange range>;\n    $stack5 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack3);\n\n    if $stack4 >= $stack5 goto label5;\n    $stack6 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    $stack7 = $stack6 + 1;\n    $stack8 = (char) $stack7;\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current> = $stack8;\n\n    goto label6;\n\n  label5:\n    this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext> = 0;\n\n  label6:\n    return;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)> via $stack2 = staticinvoke <org.apache.commons.lang3.CharRange: boolean access$100(org.apache.commons.lang3.CharRange)>($stack1);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)> via $stack12 = staticinvoke <org.apache.commons.lang3.CharRange: char access$200(org.apache.commons.lang3.CharRange)>($stack11);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack18 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack17);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack20 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack19);\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> -> <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)> via $stack5 = staticinvoke <org.apache.commons.lang3.CharRange: char access$300(org.apache.commons.lang3.CharRange)>($stack3);,[private ],[private ; static ],Prepare the next character in the range.\n,{\n    if (range.negated) {\n        if (current == Character.MAX_VALUE) {\n            hasNext = false;\n        } else if (current + 1 == range.start) {\n            if (range.end == Character.MAX_VALUE) {\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = (char) (current + 1);\n        }\n    } else if (current < range.end) {\n        current = (char) (current + 1);\n    } else {\n        hasNext = false;\n    }\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class CharRange_CharacterIterator_prepareNext__Test {

    // Minimal stub for CharRange to support the iterator logic
    private static class CharRange implements Serializable {
        private static final long serialVersionUID = 1L;
        final char start;
        final char end;
        final boolean negated;

        CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }

        // Simulate the package-private static accessors used in the iterator
        static boolean access$100(CharRange r) {
            return r.negated;
        }
        static char access$200(CharRange r) {
            return r.start;
        }
        static char access$300(CharRange r) {
            return r.end;
        }
    }

    // Reflection helper to instantiate the private static inner class
    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = null;
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                iteratorClass = c;
                break;
            }
        }
        assertNotNull(""CharacterIterator class not found"", iteratorClass);
        Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    // Reflection helper to invoke private prepareNext()
    private void invokePrepareNext(Object iterator) throws Exception {
        Method m = iterator.getClass().getDeclaredMethod(""prepareNext"");
        m.setAccessible(true);
        m.invoke(iterator);
    }

    // Reflection helpers to get/set private fields
    private void setField(Object obj, String fieldName, Object value) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    private Object getField(Object obj, String fieldName) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        return f.get(obj);
    }

    @Test
    public void testNegated_CurrentIsMaxValue() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE
        CharRange range = new CharRange('A', 'Z', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", Character.MAX_VALUE);
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals(Character.MAX_VALUE, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_EndIsMaxValue() throws Exception {
        // range.negated == true, current + 1 == range.start, range.end == Character.MAX_VALUE
        CharRange range = new CharRange('B', Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('B' - 1)); // current + 1 == 'B'
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('B' - 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_EndIsNotMaxValue() throws Exception {
        // range.negated == true, current + 1 == range.start, range.end != Character.MAX_VALUE
        CharRange range = new CharRange('C', 'Y', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('C' - 1)); // current + 1 == 'C'
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('Y' + 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentNotSpecial() throws Exception {
        // range.negated == true, current != Character.MAX_VALUE, current + 1 != range.start
        CharRange range = new CharRange('D', 'X', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'M');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals('N', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentLessThanEnd() throws Exception {
        // range.negated == false, current < range.end
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'm');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals('n', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentEqualsEnd() throws Exception {
        // range.negated == false, current == range.end
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'z');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals('z', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentGreaterThanEnd() throws Exception {
        // range.negated == false, current > range.end (should not happen in normal use, but test edge)
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('z' + 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('z' + 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_EmptySet() throws Exception {
        // range.negated == true, range.start == 0, range.end == Character.MAX_VALUE
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", false); // as per constructor logic

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)0, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_CurrentIsMaxMinusOne() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE - 1, range.start == Character.MAX_VALUE
        CharRange range = new CharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)(Character.MAX_VALUE - 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // Since range.end == Character.MAX_VALUE, hasNext should become false
        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)(Character.MAX_VALUE - 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentIsZero_StartIsZero_EndIsNotMax() throws Exception {
        // range.negated == true, range.start == 0, range.end != Character.MAX_VALUE
        CharRange range = new CharRange((char)0, 'X', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // Should not change hasNext or current, as per constructor logic, but let's check
        assertTrue((Boolean) getField(iterator, ""hasNext""));
        // The constructor would have set current = (char)(range.end + 1)
        // But we forcibly set current = 0, so after prepareNext, current should become 1
        assertEquals((char)1, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentIsMaxMinusOne_StartIsMax_EndIsNotMax() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE - 1, range.start == Character.MAX_VALUE, range.end != Character.MAX_VALUE
        CharRange range = new CharRange(Character.MAX_VALUE, 'Y', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)(Character.MAX_VALUE - 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // current + 1 == start, range.end != MAX, so current = (char)(range.end + 1)
        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)('Y' + 1), (char) getField(iterator, ""current""));
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class CharRange_CharacterIterator_prepareNext__Test {

    // Minimal stub for CharRange to support the iterator logic
    private static class CharRange implements Serializable {
        private static final long serialVersionUID = 1L;
        final char start;
        final char end;
        final boolean negated;

        CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }

        // Simulate the package-private static accessors used in the iterator
        static boolean access$100(CharRange r) {
            return r.negated;
        }
        static char access$200(CharRange r) {
            return r.start;
        }
        static char access$300(CharRange r) {
            return r.end;
        }
    }

    // Reflection helper to instantiate the private static inner class
    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = null;
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                iteratorClass = c;
                break;
            }
        }
        assertNotNull(""CharacterIterator class not found"", iteratorClass);
        Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    // Reflection helper to invoke private prepareNext()
    private void invokePrepareNext(Object iterator) throws Exception {
        Method m = iterator.getClass().getDeclaredMethod(""prepareNext"");
        m.setAccessible(true);
        m.invoke(iterator);
    }

    // Reflection helpers to get/set private fields
    private void setField(Object obj, String fieldName, Object value) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    private Object getField(Object obj, String fieldName) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        return f.get(obj);
    }

    @Test
    public void testNegated_CurrentIsMaxValue() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE
        CharRange range = new CharRange('A', 'Z', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", Character.MAX_VALUE);
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals(Character.MAX_VALUE, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_EndIsMaxValue() throws Exception {
        // range.negated == true, current + 1 == range.start, range.end == Character.MAX_VALUE
        CharRange range = new CharRange('B', Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('B' - 1)); // current + 1 == 'B'
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('B' - 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_EndIsNotMaxValue() throws Exception {
        // range.negated == true, current + 1 == range.start, range.end != Character.MAX_VALUE
        CharRange range = new CharRange('C', 'Y', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('C' - 1)); // current + 1 == 'C'
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('Y' + 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentNotSpecial() throws Exception {
        // range.negated == true, current != Character.MAX_VALUE, current + 1 != range.start
        CharRange range = new CharRange('D', 'X', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'M');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals('N', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentLessThanEnd() throws Exception {
        // range.negated == false, current < range.end
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'm');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals('n', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentEqualsEnd() throws Exception {
        // range.negated == false, current == range.end
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", 'z');
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals('z', (char) getField(iterator, ""current""));
    }

    @Test
    public void testNonNegated_CurrentGreaterThanEnd() throws Exception {
        // range.negated == false, current > range.end (should not happen in normal use, but test edge)
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char) ('z' + 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char) ('z' + 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_EmptySet() throws Exception {
        // range.negated == true, range.start == 0, range.end == Character.MAX_VALUE
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", false); // as per constructor logic

        invokePrepareNext(iterator);

        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)0, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentPlusOneEqualsStart_CurrentIsMaxMinusOne() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE - 1, range.start == Character.MAX_VALUE
        CharRange range = new CharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)(Character.MAX_VALUE - 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // Since range.end == Character.MAX_VALUE, hasNext should become false
        assertFalse((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)(Character.MAX_VALUE - 1), (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentIsZero_StartIsZero_EndIsNotMax() throws Exception {
        // range.negated == true, range.start == 0, range.end != Character.MAX_VALUE
        CharRange range = new CharRange((char)0, 'X', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // Should not change hasNext or current, as per constructor logic, but let's check
        assertTrue((Boolean) getField(iterator, ""hasNext""));
        // The constructor would have set current = (char)(range.end + 1)
        // But we forcibly set current = 0, so after prepareNext, current should become 1
        assertEquals((char)1, (char) getField(iterator, ""current""));
    }

    @Test
    public void testNegated_CurrentIsMaxMinusOne_StartIsMax_EndIsNotMax() throws Exception {
        // range.negated == true, current == Character.MAX_VALUE - 1, range.start == Character.MAX_VALUE, range.end != Character.MAX_VALUE
        CharRange range = new CharRange(Character.MAX_VALUE, 'Y', true);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)(Character.MAX_VALUE - 1));
        setField(iterator, ""hasNext"", true);

        invokePrepareNext(iterator);

        // current + 1 == start, range.end != MAX, so current = (char)(range.end + 1)
        assertTrue((Boolean) getField(iterator, ""hasNext""));
        assertEquals((char)('Y' + 1), (char) getField(iterator, ""current""));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_CharacterIterator_prepareNext__Test.java
org.apache.commons.lang3.CharRange$CharacterIterator.next(),java.lang.Object next(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = virtualinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()>();\n\n    return $stack1;\n}\n,,[public ],[private ; static ],Return the next character in the iteration\n\n@return {@code Character} for the next character\n,{\n    if (hasNext == false) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class CharRange_CharacterIterator_next__Test {

    // Minimal stub for CharRange to allow instantiation of CharacterIterator
    private static class CharRange {
        final char start;
        final char end;
        final boolean negated;

        CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Reflection-based access to the private static inner class CharacterIterator
    private Class<?> getCharacterIteratorClass() throws Exception {
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                return c;
            }
        }
        throw new ClassNotFoundException(""CharacterIterator inner class not found"");
    }

    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = getCharacterIteratorClass();
        java.lang.reflect.Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    private Object invokeNext(Object iterator) throws Exception {
        java.lang.reflect.Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);
        return nextMethod.invoke(iterator);
    }

    private void setField(Object obj, String fieldName, Object value) throws Exception {
        java.lang.reflect.Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    private Object getField(Object obj, String fieldName) throws Exception {
        java.lang.reflect.Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        return f.get(obj);
    }

    @Test
    public void testNext_NormalRange_FirstCall() throws Exception {
        CharRange range = new CharRange('a', 'c', false);
        Object iterator = createCharacterIterator(range);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('a'), result);
        // After next(), current should be advanced, but we can't check private state without knowing prepareNext()
    }

    @Test
    public void testNext_NormalRange_MultipleCalls() throws Exception {
        CharRange range = new CharRange('x', 'z', false);
        Object iterator = createCharacterIterator(range);

        Object first = invokeNext(iterator);
        assertEquals(Character.valueOf('x'), first);

        // Simulate next() again
        Object second = invokeNext(iterator);
        assertEquals(Character.valueOf('y'), second);

        Object third = invokeNext(iterator);
        assertEquals(Character.valueOf('z'), third);

        // Now, should throw NoSuchElementException on next()
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_NegatedRange_EmptySet() throws Exception {
        // negated, start == 0, end == Character.MAX_VALUE => empty set
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        // Should throw NoSuchElementException immediately
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_NegatedRange_NonEmptySet_StartZero_EndNotMax() throws Exception {
        // negated, start == 0, end < Character.MAX_VALUE
        CharRange range = new CharRange((char)0, (char)100, true);
        Object iterator = createCharacterIterator(range);
        // Should start at end+1
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)101), result);
    }

    @Test
    public void testNext_NegatedRange_NonEmptySet_StartNotZero() throws Exception {
        // negated, start > 0
        CharRange range = new CharRange((char)5, (char)10, true);
        Object iterator = createCharacterIterator(range);
        // Should start at 0
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)0), result);
    }

    @Test
    public void testNext_SingleCharacterRange() throws Exception {
        CharRange range = new CharRange('m', 'm', false);
        Object iterator = createCharacterIterator(range);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('m'), result);
        // Should throw on next call
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_ManuallySetHasNextFalse() throws Exception {
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        // forcibly set hasNext to false
        setField(iterator, ""hasNext"", false);
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_ManuallySetCurrentToBoundary() throws Exception {
        CharRange range = new CharRange('a', 'c', false);
        Object iterator = createCharacterIterator(range);
        // forcibly set current to 'z'
        setField(iterator, ""current"", 'z');
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('z'), result);
    }

    @Test
    public void testNext_ManuallySetCurrentToMinValue() throws Exception {
        CharRange range = new CharRange((char)0, (char)2, false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)0), result);
    }

    @Test
    public void testNext_ManuallySetCurrentToMaxValue() throws Exception {
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", Character.MAX_VALUE);
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf(Character.MAX_VALUE), result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.NoSuchElementException;
import java.util.Iterator;

public class CharRange_CharacterIterator_next__Test {

    // Minimal stub for CharRange to allow instantiation of CharacterIterator
    private static class CharRange {
        final char start;
        final char end;
        final boolean negated;

        CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Reflection-based access to the private static inner class CharacterIterator
    private Class<?> getCharacterIteratorClass() throws Exception {
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                return c;
            }
        }
        throw new ClassNotFoundException(""CharacterIterator inner class not found"");
    }

    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = getCharacterIteratorClass();
        java.lang.reflect.Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    private Object invokeNext(Object iterator) throws Exception {
        java.lang.reflect.Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);
        return nextMethod.invoke(iterator);
    }

    private void setField(Object obj, String fieldName, Object value) throws Exception {
        java.lang.reflect.Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    private Object getField(Object obj, String fieldName) throws Exception {
        java.lang.reflect.Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        return f.get(obj);
    }

    @Test
    public void testNext_NormalRange_FirstCall() throws Exception {
        CharRange range = new CharRange('a', 'c', false);
        Object iterator = createCharacterIterator(range);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('a'), result);
        // After next(), current should be advanced, but we can't check private state without knowing prepareNext()
    }

    @Test
    public void testNext_NormalRange_MultipleCalls() throws Exception {
        CharRange range = new CharRange('x', 'z', false);
        Object iterator = createCharacterIterator(range);

        Object first = invokeNext(iterator);
        assertEquals(Character.valueOf('x'), first);

        // Simulate next() again
        Object second = invokeNext(iterator);
        assertEquals(Character.valueOf('y'), second);

        Object third = invokeNext(iterator);
        assertEquals(Character.valueOf('z'), third);

        // Now, should throw NoSuchElementException on next()
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_NegatedRange_EmptySet() throws Exception {
        // negated, start == 0, end == Character.MAX_VALUE => empty set
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        // Should throw NoSuchElementException immediately
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_NegatedRange_NonEmptySet_StartZero_EndNotMax() throws Exception {
        // negated, start == 0, end < Character.MAX_VALUE
        CharRange range = new CharRange((char)0, (char)100, true);
        Object iterator = createCharacterIterator(range);
        // Should start at end+1
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)101), result);
    }

    @Test
    public void testNext_NegatedRange_NonEmptySet_StartNotZero() throws Exception {
        // negated, start > 0
        CharRange range = new CharRange((char)5, (char)10, true);
        Object iterator = createCharacterIterator(range);
        // Should start at 0
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)0), result);
    }

    @Test
    public void testNext_SingleCharacterRange() throws Exception {
        CharRange range = new CharRange('m', 'm', false);
        Object iterator = createCharacterIterator(range);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('m'), result);
        // Should throw on next call
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_ManuallySetHasNextFalse() throws Exception {
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        // forcibly set hasNext to false
        setField(iterator, ""hasNext"", false);
        try {
            invokeNext(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof NoSuchElementException);
        }
    }

    @Test
    public void testNext_ManuallySetCurrentToBoundary() throws Exception {
        CharRange range = new CharRange('a', 'c', false);
        Object iterator = createCharacterIterator(range);
        // forcibly set current to 'z'
        setField(iterator, ""current"", 'z');
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf('z'), result);
    }

    @Test
    public void testNext_ManuallySetCurrentToMinValue() throws Exception {
        CharRange range = new CharRange((char)0, (char)2, false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", (char)0);
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf((char)0), result);
    }

    @Test
    public void testNext_ManuallySetCurrentToMaxValue() throws Exception {
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(range);
        setField(iterator, ""current"", Character.MAX_VALUE);
        setField(iterator, ""hasNext"", true);
        Object result = invokeNext(iterator);
        assertEquals(Character.valueOf(Character.MAX_VALUE), result);
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_CharacterIterator_next__Test.java
org.apache.commons.lang3.CharRange$CharacterIterator.next(),java.lang.Character next(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack2; $stack3; $stack4; cur;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack2 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext>;\n\n    if $stack2 != 0 goto label1;\n    $stack4 = new java.util.NoSuchElementException;\n    specialinvoke $stack4.<java.util.NoSuchElementException: void <init>()>();\n\n    throw $stack4;\n\n  label1:\n    cur = this.<org.apache.commons.lang3.CharRange$CharacterIterator: char current>;\n    specialinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()>();\n    $stack3 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(cur);\n\n    return $stack3;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <java.util.NoSuchElementException: void <init>()> via specialinvoke $stack4.<java.util.NoSuchElementException: void <init>()>();\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()> via specialinvoke this.<org.apache.commons.lang3.CharRange$CharacterIterator: void prepareNext()>();\nCall:<org.apache.commons.lang3.CharRange$CharacterIterator: java.lang.Character next()> -> <java.lang.Character: java.lang.Character valueOf(char)> via $stack3 = staticinvoke <java.lang.Character: java.lang.Character valueOf(char)>(cur);,[public ],[private ; static ],Return the next character in the iteration\n\n@return {@code Character} for the next character\n,{\n    if (hasNext == false) {\n        throw new NoSuchElementException();\n    }\n    final char cur = current;\n    prepareNext();\n    return Character.valueOf(cur);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class CharRange_CharacterIterator_next__Test {

    // Helper class to mock CharRange with required fields
    private static class MockCharRange {
        public char start;
        public char end;
        public boolean negated;

        public MockCharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Helper method to create a CharRange instance via reflection
    private Object createCharRange(char start, char end, boolean negated) throws Exception {
        Class<?> charRangeClass = Class.forName(""org.apache.commons.lang3.CharRange"");
        Constructor<?> constructor = null;
        for (Constructor<?> c : charRangeClass.getDeclaredConstructors()) {
            if (c.getParameterTypes().length == 3) {
                constructor = c;
                break;
            }
        }
        if (constructor == null) {
            throw new RuntimeException(""CharRange constructor not found"");
        }
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    // Helper method to create a CharacterIterator instance via reflection
    private Object createCharacterIterator(Object charRange) throws Exception {
        Class<?> iteratorClass = Class.forName(""org.apache.commons.lang3.CharRange$CharacterIterator"");
        Constructor<?> constructor = iteratorClass.getDeclaredConstructor(Class.forName(""org.apache.commons.lang3.CharRange""));
        constructor.setAccessible(true);
        return constructor.newInstance(charRange);
    }

    // Helper to set private fields
    private void setField(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    // Helper to get private fields
    private Object getField(Object obj, String fieldName) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(obj);
    }

    // Helper to invoke private method
    private Object invokeMethod(Object obj, String methodName, Class<?>[] paramTypes, Object[] params) throws Exception {
        Method method = obj.getClass().getDeclaredMethod(methodName, paramTypes);
        method.setAccessible(true);
        return method.invoke(obj, params);
    }

    /**
     * Test normal case: hasNext is true, current is a valid character.
     */
    @Test
    public void testNext_NormalCase() throws Exception {
        Object charRange = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(charRange);

        // Set hasNext = true, current = 'b'
        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", 'b');

        // Prepare to track prepareNext() call by subclassing via proxy if needed
        // For now, just call next and check result

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf('b'), result);

        // After next(), prepareNext() should have been called, so current may have changed
        // But we can't check prepareNext() directly as it's private and logic is unknown
    }

    /**
     * Test edge case: hasNext is false, should throw NoSuchElementException.
     */
    @Test
    public void testNext_HasNextFalse_ThrowsException() throws Exception {
        Object charRange = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", false);
        setField(iterator, ""current"", 'c');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }

    /**
     * Test edge case: current is Character.MIN_VALUE.
     */
    @Test
    public void testNext_CurrentIsMinValue() throws Exception {
        Object charRange = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", Character.MIN_VALUE);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(Character.MIN_VALUE), result);
    }

    /**
     * Test edge case: current is Character.MAX_VALUE.
     */
    @Test
    public void testNext_CurrentIsMaxValue() throws Exception {
        Object charRange = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", Character.MAX_VALUE);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(Character.MAX_VALUE), result);
    }

    /**
     * Test edge case: negated range, hasNext true, current at 0.
     */
    @Test
    public void testNext_NegatedRange_CurrentZero() throws Exception {
        Object charRange = createCharRange((char) 0, (char) 10, true);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", (char) 0);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf((char) 0), result);
    }

    /**
     * Test edge case: negated range, hasNext false, should throw.
     */
    @Test
    public void testNext_NegatedRange_HasNextFalse() throws Exception {
        Object charRange = createCharRange((char) 0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", false);
        setField(iterator, ""current"", (char) 0);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }

    /**
     * Test edge case: current is a non-alphabetic character.
     */
    @Test
    public void testNext_CurrentIsNonAlphabetic() throws Exception {
        Object charRange = createCharRange('!', '/', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", '!');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf('!'), result);
    }

    /**
     * Test edge case: current is a surrogate character.
     */
    @Test
    public void testNext_CurrentIsSurrogate() throws Exception {
        char surrogate = '\uD800'; // High surrogate
        Object charRange = createCharRange(surrogate, surrogate, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", surrogate);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(surrogate), result);
    }

    /**
     * Test calling next multiple times, simulating iteration.
     */
    @Test
    public void testNext_MultipleCalls() throws Exception {
        Object charRange = createCharRange('a', 'c', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", 'a');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        // First call
        Character result1 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('a'), result1);

        // Simulate prepareNext() by setting current and hasNext for next call
        setField(iterator, ""current"", 'b');
        setField(iterator, ""hasNext"", true);

        Character result2 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('b'), result2);

        // Simulate prepareNext() for last element
        setField(iterator, ""current"", 'c');
        setField(iterator, ""hasNext"", true);

        Character result3 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('c'), result3);

        // Now set hasNext to false to simulate end of iteration
        setField(iterator, ""hasNext"", false);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class CharRange_CharacterIterator_next__Test {

    // Helper class to mock CharRange with required fields
    private static class MockCharRange {
        public char start;
        public char end;
        public boolean negated;

        public MockCharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Helper method to create a CharRange instance via reflection
    private Object createCharRange(char start, char end, boolean negated) throws Exception {
        Class<?> charRangeClass = Class.forName(""org.apache.commons.lang3.CharRange"");
        Constructor<?> constructor = null;
        for (Constructor<?> c : charRangeClass.getDeclaredConstructors()) {
            if (c.getParameterTypes().length == 3) {
                constructor = c;
                break;
            }
        }
        if (constructor == null) {
            throw new RuntimeException(""CharRange constructor not found"");
        }
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    // Helper method to create a CharacterIterator instance via reflection
    private Object createCharacterIterator(Object charRange) throws Exception {
        Class<?> iteratorClass = Class.forName(""org.apache.commons.lang3.CharRange$CharacterIterator"");
        Constructor<?> constructor = iteratorClass.getDeclaredConstructor(Class.forName(""org.apache.commons.lang3.CharRange""));
        constructor.setAccessible(true);
        return constructor.newInstance(charRange);
    }

    // Helper to set private fields
    private void setField(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    // Helper to get private fields
    private Object getField(Object obj, String fieldName) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(obj);
    }

    // Helper to invoke private method
    private Object invokeMethod(Object obj, String methodName, Class<?>[] paramTypes, Object[] params) throws Exception {
        Method method = obj.getClass().getDeclaredMethod(methodName, paramTypes);
        method.setAccessible(true);
        return method.invoke(obj, params);
    }

    /**
     * Test normal case: hasNext is true, current is a valid character.
     */
    @Test
    public void testNext_NormalCase() throws Exception {
        Object charRange = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(charRange);

        // Set hasNext = true, current = 'b'
        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", 'b');

        // Prepare to track prepareNext() call by subclassing via proxy if needed
        // For now, just call next and check result

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf('b'), result);

        // After next(), prepareNext() should have been called, so current may have changed
        // But we can't check prepareNext() directly as it's private and logic is unknown
    }

    /**
     * Test edge case: hasNext is false, should throw NoSuchElementException.
     */
    @Test
    public void testNext_HasNextFalse_ThrowsException() throws Exception {
        Object charRange = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", false);
        setField(iterator, ""current"", 'c');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }

    /**
     * Test edge case: current is Character.MIN_VALUE.
     */
    @Test
    public void testNext_CurrentIsMinValue() throws Exception {
        Object charRange = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", Character.MIN_VALUE);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(Character.MIN_VALUE), result);
    }

    /**
     * Test edge case: current is Character.MAX_VALUE.
     */
    @Test
    public void testNext_CurrentIsMaxValue() throws Exception {
        Object charRange = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", Character.MAX_VALUE);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(Character.MAX_VALUE), result);
    }

    /**
     * Test edge case: negated range, hasNext true, current at 0.
     */
    @Test
    public void testNext_NegatedRange_CurrentZero() throws Exception {
        Object charRange = createCharRange((char) 0, (char) 10, true);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", (char) 0);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf((char) 0), result);
    }

    /**
     * Test edge case: negated range, hasNext false, should throw.
     */
    @Test
    public void testNext_NegatedRange_HasNextFalse() throws Exception {
        Object charRange = createCharRange((char) 0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", false);
        setField(iterator, ""current"", (char) 0);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }

    /**
     * Test edge case: current is a non-alphabetic character.
     */
    @Test
    public void testNext_CurrentIsNonAlphabetic() throws Exception {
        Object charRange = createCharRange('!', '/', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", '!');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf('!'), result);
    }

    /**
     * Test edge case: current is a surrogate character.
     */
    @Test
    public void testNext_CurrentIsSurrogate() throws Exception {
        char surrogate = '\uD800'; // High surrogate
        Object charRange = createCharRange(surrogate, surrogate, false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", surrogate);

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        Character result = (Character) nextMethod.invoke(iterator);

        assertNotNull(result);
        assertEquals(Character.valueOf(surrogate), result);
    }

    /**
     * Test calling next multiple times, simulating iteration.
     */
    @Test
    public void testNext_MultipleCalls() throws Exception {
        Object charRange = createCharRange('a', 'c', false);
        Object iterator = createCharacterIterator(charRange);

        setField(iterator, ""hasNext"", true);
        setField(iterator, ""current"", 'a');

        Method nextMethod = iterator.getClass().getDeclaredMethod(""next"");
        nextMethod.setAccessible(true);

        // First call
        Character result1 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('a'), result1);

        // Simulate prepareNext() by setting current and hasNext for next call
        setField(iterator, ""current"", 'b');
        setField(iterator, ""hasNext"", true);

        Character result2 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('b'), result2);

        // Simulate prepareNext() for last element
        setField(iterator, ""current"", 'c');
        setField(iterator, ""hasNext"", true);

        Character result3 = (Character) nextMethod.invoke(iterator);
        assertEquals(Character.valueOf('c'), result3);

        // Now set hasNext to false to simulate end of iteration
        setField(iterator, ""hasNext"", false);

        try {
            nextMethod.invoke(iterator);
            fail(""Expected NoSuchElementException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NoSuchElementException);
        }
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_CharacterIterator_next__Test.java
org.apache.commons.lang3.CharRange$CharacterIterator.hasNext(),boolean hasNext(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = this.<org.apache.commons.lang3.CharRange$CharacterIterator: boolean hasNext>;\n\n    return $stack1;\n}\n,,[public ],[private ; static ],Has the iterator not reached the end character yet?\n\n@return {@code true} if the iterator has yet to reach the character date\n,{\n    return hasNext;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_CharacterIterator_hasNext__Test {

    // Helper to create a CharRange instance with given parameters via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<?> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return (CharRange) ctor.newInstance(start, end, negated);
    }

    // Helper to create a CharacterIterator instance with given CharRange via reflection
    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = null;
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                iteratorClass = c;
                break;
            }
        }
        assertNotNull(""CharacterIterator inner class not found"", iteratorClass);
        Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    // Helper to set the hasNext field
    private void setHasNext(Object iterator, boolean value) throws Exception {
        Field hasNextField = iterator.getClass().getDeclaredField(""hasNext"");
        hasNextField.setAccessible(true);
        hasNextField.setBoolean(iterator, value);
    }

    // Helper to get the hasNext() result
    private boolean invokeHasNext(Object iterator) throws Exception {
        return (Boolean) iterator.getClass().getDeclaredMethod(""hasNext"").invoke(iterator);
    }

    @Test
    public void testHasNext_DefaultTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        // By constructor, hasNext should be true
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_ExplicitlyFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        boolean result = invokeHasNext(iterator);
        assertFalse(result);
    }

    @Test
    public void testHasNext_EmptyNegatedRange() throws Exception {
        // range: negated, start == 0, end == Character.MAX_VALUE
        CharRange range = createCharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertFalse(result);
    }

    @Test
    public void testHasNext_NegatedRangeStartZeroEndNotMax() throws Exception {
        // range: negated, start == 0, end < Character.MAX_VALUE
        CharRange range = createCharRange((char)0, (char)100, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_NegatedRangeStartNotZero() throws Exception {
        // range: negated, start != 0
        CharRange range = createCharRange((char)1, (char)100, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_SingleCharRange() throws Exception {
        // range: not negated, start == end
        CharRange range = createCharRange('x', 'x', false);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_SetHasNextTrueAfterFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_SetHasNextFalseAfterTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_LargeRange() throws Exception {
        // range: not negated, large range
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_NegatedRangeEdgeCase() throws Exception {
        // range: negated, start == 0, end == Character.MAX_VALUE - 1
        CharRange range = createCharRange((char)0, (char)(Character.MAX_VALUE - 1), true);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_NegatedRangeStartMax() throws Exception {
        // range: negated, start == Character.MAX_VALUE, end == Character.MAX_VALUE
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_ManuallySetHasNextToTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_ManuallySetHasNextToFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_AfterMultipleSetHasNext() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_CharacterIterator_hasNext__Test {

    // Helper to create a CharRange instance with given parameters via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<?> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return (CharRange) ctor.newInstance(start, end, negated);
    }

    // Helper to create a CharacterIterator instance with given CharRange via reflection
    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> iteratorClass = null;
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                iteratorClass = c;
                break;
            }
        }
        assertNotNull(""CharacterIterator inner class not found"", iteratorClass);
        Constructor<?> ctor = iteratorClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    // Helper to set the hasNext field
    private void setHasNext(Object iterator, boolean value) throws Exception {
        Field hasNextField = iterator.getClass().getDeclaredField(""hasNext"");
        hasNextField.setAccessible(true);
        hasNextField.setBoolean(iterator, value);
    }

    // Helper to get the hasNext() result
    private boolean invokeHasNext(Object iterator) throws Exception {
        return (Boolean) iterator.getClass().getDeclaredMethod(""hasNext"").invoke(iterator);
    }

    @Test
    public void testHasNext_DefaultTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        // By constructor, hasNext should be true
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_ExplicitlyFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        boolean result = invokeHasNext(iterator);
        assertFalse(result);
    }

    @Test
    public void testHasNext_EmptyNegatedRange() throws Exception {
        // range: negated, start == 0, end == Character.MAX_VALUE
        CharRange range = createCharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertFalse(result);
    }

    @Test
    public void testHasNext_NegatedRangeStartZeroEndNotMax() throws Exception {
        // range: negated, start == 0, end < Character.MAX_VALUE
        CharRange range = createCharRange((char)0, (char)100, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_NegatedRangeStartNotZero() throws Exception {
        // range: negated, start != 0
        CharRange range = createCharRange((char)1, (char)100, true);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_SingleCharRange() throws Exception {
        // range: not negated, start == end
        CharRange range = createCharRange('x', 'x', false);
        Object iterator = createCharacterIterator(range);
        boolean result = invokeHasNext(iterator);
        assertTrue(result);
    }

    @Test
    public void testHasNext_SetHasNextTrueAfterFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_SetHasNextFalseAfterTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_LargeRange() throws Exception {
        // range: not negated, large range
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_NegatedRangeEdgeCase() throws Exception {
        // range: negated, start == 0, end == Character.MAX_VALUE - 1
        CharRange range = createCharRange((char)0, (char)(Character.MAX_VALUE - 1), true);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_NegatedRangeStartMax() throws Exception {
        // range: negated, start == Character.MAX_VALUE, end == Character.MAX_VALUE
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_ManuallySetHasNextToTrue() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_ManuallySetHasNextToFalse() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }

    @Test
    public void testHasNext_AfterMultipleSetHasNext() throws Exception {
        // range: not negated, start < end
        CharRange range = createCharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
        setHasNext(iterator, true);
        assertTrue(invokeHasNext(iterator));
        setHasNext(iterator, false);
        assertFalse(invokeHasNext(iterator));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_CharacterIterator_hasNext__Test.java
org.apache.commons.lang3.CharRange$CharacterIterator.remove(),void remove(),{\n    org.apache.commons.lang3.CharRange$CharacterIterator this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange$CharacterIterator;\n    $stack1 = new java.lang.UnsupportedOperationException;\n    specialinvoke $stack1.<java.lang.UnsupportedOperationException: void <init>()>();\n\n    throw $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange$CharacterIterator: void remove()> -> <java.lang.UnsupportedOperationException: void <init>()> via specialinvoke $stack1.<java.lang.UnsupportedOperationException: void <init>()>();,[public ],[private ; static ],Always throws UnsupportedOperationException.\n\n@throws UnsupportedOperationException\n@see java.util.Iterator#remove()\n,{\n    throw new UnsupportedOperationException();\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],Character {@link Iterator}.\n<p>#NotThreadSafe#</p>\n,/**\n * The current character\n */\nprivate char current;\nprivate final CharRange range;\nprivate boolean hasNext;\n\n/**\n * Construct a new iterator for the character range.\n *\n * @param r The character range\n */\nprivate CharacterIterator(final CharRange r) {\n    range = r;\n    hasNext = true;\n    if (range.negated) {\n        if (range.start == 0) {\n            if (range.end == Character.MAX_VALUE) {\n                // This range is an empty set\n                hasNext = false;\n            } else {\n                current = (char) (range.end + 1);\n            }\n        } else {\n            current = 0;\n        }\n    } else {\n        current = range.start;\n    }\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_CharacterIterator_remove__Test {

    // Minimal stub for CharRange to satisfy the CharacterIterator constructor
    private static class CharRange {
        public final boolean negated;
        public final char start;
        public final char end;

        public CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Concrete subclass to access the private static CharacterIterator class
    // via reflection
    private Class<?> getCharacterIteratorClass() throws Exception {
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                return c;
            }
        }
        throw new ClassNotFoundException(""CharacterIterator inner class not found"");
    }

    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> ciClass = getCharacterIteratorClass();
        java.lang.reflect.Constructor<?> ctor = ciClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NormalRange() throws Exception {
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NegatedRange() throws Exception {
        CharRange range = new CharRange('a', 'z', true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_EmptyRange() throws Exception {
        // This will trigger the hasNext = false branch in the constructor
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_SingleCharRange() throws Exception {
        CharRange range = new CharRange('x', 'x', false);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NegatedSingleCharRange() throws Exception {
        CharRange range = new CharRange('x', 'x', true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_CharacterIterator_remove__Test {

    // Minimal stub for CharRange to satisfy the CharacterIterator constructor
    private static class CharRange {
        public final boolean negated;
        public final char start;
        public final char end;

        public CharRange(char start, char end, boolean negated) {
            this.start = start;
            this.end = end;
            this.negated = negated;
        }
    }

    // Concrete subclass to access the private static CharacterIterator class
    // via reflection
    private Class<?> getCharacterIteratorClass() throws Exception {
        for (Class<?> c : CharRange.class.getDeclaredClasses()) {
            if (c.getSimpleName().equals(""CharacterIterator"")) {
                return c;
            }
        }
        throw new ClassNotFoundException(""CharacterIterator inner class not found"");
    }

    private Object createCharacterIterator(CharRange range) throws Exception {
        Class<?> ciClass = getCharacterIteratorClass();
        java.lang.reflect.Constructor<?> ctor = ciClass.getDeclaredConstructor(CharRange.class);
        ctor.setAccessible(true);
        return ctor.newInstance(range);
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NormalRange() throws Exception {
        CharRange range = new CharRange('a', 'z', false);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NegatedRange() throws Exception {
        CharRange range = new CharRange('a', 'z', true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_EmptyRange() throws Exception {
        // This will trigger the hasNext = false branch in the constructor
        CharRange range = new CharRange((char)0, Character.MAX_VALUE, true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_SingleCharRange() throws Exception {
        CharRange range = new CharRange('x', 'x', false);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }

    @Test
    public void testRemoveThrowsUnsupportedOperationException_NegatedSingleCharRange() throws Exception {
        CharRange range = new CharRange('x', 'x', true);
        Object iterator = createCharacterIterator(range);
        java.lang.reflect.Method removeMethod = iterator.getClass().getDeclaredMethod(""remove"");
        removeMethod.setAccessible(true);
        try {
            removeMethod.invoke(iterator);
            fail(""Expected UnsupportedOperationException"");
        } catch (java.lang.reflect.InvocationTargetException e) {
            assertTrue(e.getCause() instanceof UnsupportedOperationException);
        }
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_CharacterIterator_remove__Test.java
"org.apache.commons.lang3.CharSetUtils.keep(java.lang.String, java.lang.String[])","java.lang.String keep(java.lang.String,java.lang.String[])","{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack2; $stack3; $stack4;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n\n    if str != null goto label1;\n\n    return null;\n\n  label1:\n    $stack2 = virtualinvoke str.<java.lang.String: boolean isEmpty()>();\n\n    if $stack2 != 0 goto label2;\n    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack3 == 0 goto label3;\n\n  label2:\n    return "";\n\n  label3:\n    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 1);\n\n    return $stack4;\n}\n",Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <java.lang.String: boolean isEmpty()> via $stack2 = virtualinvoke str.<java.lang.String: boolean isEmpty()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String keep(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> via $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 1);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand keeps any of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.keep(null; *)        = null\nCharSetUtils.keep(""; *)          = ""\nCharSetUtils.keep(*; null)        = ""\nCharSetUtils.keep(*; "")          = ""\nCharSetUtils.keep(hello""; ""hl"")  = ""hll""\nCharSetUtils.keep(""hello""; ""le"")  = ""ell""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to keep characters from; may be null\n@param set String[] set of characters to keep; may be null\n@return the modified String; {@code null} if null string input\n@since 2.0\n""",{\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return StringUtils.EMPTY;\n    }\n    return modify(str; set; true);\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_keep_java_lang_String_java_lang_StringArray_Test {

    // Helper: minimal stub for StringUtils.EMPTY if not present
    private static final String EMPTY = """";

    // Helper: Reflection to access static methods if needed
    private static java.lang.reflect.Method getStaticMethod(String name, Class<?>... paramTypes) throws Exception {
        return CharSetUtils.class.getDeclaredMethod(name, paramTypes);
    }

    // Helper: invoke deepEmpty
    private static boolean deepEmpty(String[] set) {
        try {
            java.lang.reflect.Method m = getStaticMethod(""deepEmpty"", String[].class);
            m.setAccessible(true);
            return (Boolean) m.invoke(null, (Object) set);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // Helper: invoke modify
    private static String modify(String str, String[] set, boolean expectKeep) {
        try {
            java.lang.reflect.Method m = getStaticMethod(""modify"", String.class, String[].class, boolean.class);
            m.setAccessible(true);
            return (String) m.invoke(null, str, set, expectKeep);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // Test: str == null
    @Test
    public void testKeep_NullStr_ReturnsNull() {
        String result = CharSetUtils.keep(null, new String[]{""abc""});
        assertNull(result);
    }

    // Test: str is empty string, set is non-null, non-empty
    @Test
    public void testKeep_EmptyStr_NonNullSet_ReturnsEmpty() {
        String result = CharSetUtils.keep("""", new String[]{""abc""});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set == null
    @Test
    public void testKeep_NonEmptyStr_NullSet_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", null);
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set is empty array
    @Test
    public void testKeep_NonEmptyStr_EmptySet_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set contains only empty strings
    @Test
    public void testKeep_NonEmptyStr_SetWithOnlyEmptyStrings_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{"""", """"});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set contains nulls and empty strings
    @Test
    public void testKeep_NonEmptyStr_SetWithNullsAndEmptyStrings_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, """"});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set is non-empty, normal case
    @Test
    public void testKeep_NormalCase_KeepSomeChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""hl""});
        // Should keep only 'h' and 'l'
        assertEquals(""hll"", result);
    }

    // Test: str is non-empty, set is non-empty, keep different chars
    @Test
    public void testKeep_NormalCase_KeepOtherChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""le""});
        // Should keep only 'l' and 'e'
        assertEquals(""ell"", result);
    }

    // Test: str is non-empty, set is non-empty, keep all chars
    @Test
    public void testKeep_KeepAllChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""helo""});
        assertEquals(""hello"", result);
    }

    // Test: str is non-empty, set is non-empty, keep none
    @Test
    public void testKeep_KeepNoChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""xyz""});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, set contains nulls and valid sets
    @Test
    public void testKeep_SetWithNullsAndValidSets() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, ""e""});
        assertEquals(""e"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains duplicate sets
    @Test
    public void testKeep_SetWithDuplicateSets() {
        String result = CharSetUtils.keep(""hello"", new String[]{""l"", ""l""});
        assertEquals(""ll"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains special characters
    @Test
    public void testKeep_SetWithSpecialCharacters() {
        String result = CharSetUtils.keep(""h@e#l$l%o"", new String[]{""@#$%l""});
        assertEquals(""@#l$l%l"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains whitespace
    @Test
    public void testKeep_SetWithWhitespace() {
        String result = CharSetUtils.keep(""h e l l o"", new String[]{"" ""});
        assertEquals(""   "", result);
    }

    // Test: str is non-empty, set is non-empty, set contains unicode
    @Test
    public void testKeep_SetWithUnicode() {
        String result = CharSetUtils.keep(""héllo"", new String[]{""é""});
        assertEquals(""é"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains all nulls
    @Test
    public void testKeep_SetAllNulls() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, null});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, set contains empty and valid
    @Test
    public void testKeep_SetWithEmptyAndValid() {
        String result = CharSetUtils.keep(""hello"", new String[]{"""", ""o""});
        assertEquals(""o"", result);
    }

    // Test: str is non-empty, set is non-empty, str contains only chars not in set
    @Test
    public void testKeep_StrNoCharsInSet() {
        String result = CharSetUtils.keep(""abc"", new String[]{""xyz""});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, str contains only chars in set
    @Test
    public void testKeep_StrAllCharsInSet() {
        String result = CharSetUtils.keep(""abc"", new String[]{""abc""});
        assertEquals(""abc"", result);
    }

    // Test: str is non-empty, set is non-empty, set is very large
    @Test
    public void testKeep_LargeSet() {
        StringBuilder sb = new StringBuilder();
        for (char c = 32; c < 127; c++) {
            sb.append(c);
        }
        String allChars = sb.toString();
        String result = CharSetUtils.keep(""hello123"", new String[]{allChars});
        assertEquals(""hello123"", result);
    }

    // Test: str is very large, set is small
    @Test
    public void testKeep_LargeStr_SmallSet() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String largeStr = sb.toString();
        String result = CharSetUtils.keep(largeStr, new String[]{""b""});
        assertEquals(10000, result.length());
        for (char c : result.toCharArray()) {
            assertEquals('b', c);
        }
    }

    // Test: str is non-empty, set is empty string
    @Test
    public void testKeep_SetIsEmptyString() {
        String result = CharSetUtils.keep(""hello"", new String[]{""""});
        assertEquals("""", result);
    }

    // Test: str is empty, set is null
    @Test
    public void testKeep_EmptyStr_NullSet() {
        String result = CharSetUtils.keep("""", null);
        assertEquals("""", result);
    }

    // Test: str is empty, set is empty array
    @Test
    public void testKeep_EmptyStr_EmptySet() {
        String result = CharSetUtils.keep("""", new String[]{});
        assertEquals("""", result);
    }

    // Test: str is empty, set is array with empty string
    @Test
    public void testKeep_EmptyStr_SetWithEmptyString() {
        String result = CharSetUtils.keep("""", new String[]{""""});
        assertEquals("""", result);
    }

    // Test: str is empty, set is array with null
    @Test
    public void testKeep_EmptyStr_SetWithNull() {
        String result = CharSetUtils.keep("""", new String[]{null});
        assertEquals("""", result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_keep_java_lang_String_java_lang_StringArray_Test {

    // Helper: minimal stub for StringUtils.EMPTY if not present
    private static final String EMPTY = """";

    // Helper: Reflection to access static methods if needed
    private static java.lang.reflect.Method getStaticMethod(String name, Class<?>... paramTypes) throws Exception {
        return CharSetUtils.class.getDeclaredMethod(name, paramTypes);
    }

    // Helper: invoke deepEmpty
    private static boolean deepEmpty(String[] set) {
        try {
            java.lang.reflect.Method m = getStaticMethod(""deepEmpty"", String[].class);
            m.setAccessible(true);
            return (Boolean) m.invoke(null, (Object) set);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // Helper: invoke modify
    private static String modify(String str, String[] set, boolean expectKeep) {
        try {
            java.lang.reflect.Method m = getStaticMethod(""modify"", String.class, String[].class, boolean.class);
            m.setAccessible(true);
            return (String) m.invoke(null, str, set, expectKeep);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // Test: str == null
    @Test
    public void testKeep_NullStr_ReturnsNull() {
        String result = CharSetUtils.keep(null, new String[]{""abc""});
        assertNull(result);
    }

    // Test: str is empty string, set is non-null, non-empty
    @Test
    public void testKeep_EmptyStr_NonNullSet_ReturnsEmpty() {
        String result = CharSetUtils.keep("""", new String[]{""abc""});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set == null
    @Test
    public void testKeep_NonEmptyStr_NullSet_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", null);
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set is empty array
    @Test
    public void testKeep_NonEmptyStr_EmptySet_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set contains only empty strings
    @Test
    public void testKeep_NonEmptyStr_SetWithOnlyEmptyStrings_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{"""", """"});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set contains nulls and empty strings
    @Test
    public void testKeep_NonEmptyStr_SetWithNullsAndEmptyStrings_ReturnsEmpty() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, """"});
        assertEquals(EMPTY, result);
    }

    // Test: str is non-empty, set is non-empty, normal case
    @Test
    public void testKeep_NormalCase_KeepSomeChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""hl""});
        // Should keep only 'h' and 'l'
        assertEquals(""hll"", result);
    }

    // Test: str is non-empty, set is non-empty, keep different chars
    @Test
    public void testKeep_NormalCase_KeepOtherChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""le""});
        // Should keep only 'l' and 'e'
        assertEquals(""ell"", result);
    }

    // Test: str is non-empty, set is non-empty, keep all chars
    @Test
    public void testKeep_KeepAllChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""helo""});
        assertEquals(""hello"", result);
    }

    // Test: str is non-empty, set is non-empty, keep none
    @Test
    public void testKeep_KeepNoChars() {
        String result = CharSetUtils.keep(""hello"", new String[]{""xyz""});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, set contains nulls and valid sets
    @Test
    public void testKeep_SetWithNullsAndValidSets() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, ""e""});
        assertEquals(""e"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains duplicate sets
    @Test
    public void testKeep_SetWithDuplicateSets() {
        String result = CharSetUtils.keep(""hello"", new String[]{""l"", ""l""});
        assertEquals(""ll"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains special characters
    @Test
    public void testKeep_SetWithSpecialCharacters() {
        String result = CharSetUtils.keep(""h@e#l$l%o"", new String[]{""@#$%l""});
        assertEquals(""@#l$l%l"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains whitespace
    @Test
    public void testKeep_SetWithWhitespace() {
        String result = CharSetUtils.keep(""h e l l o"", new String[]{"" ""});
        assertEquals(""   "", result);
    }

    // Test: str is non-empty, set is non-empty, set contains unicode
    @Test
    public void testKeep_SetWithUnicode() {
        String result = CharSetUtils.keep(""héllo"", new String[]{""é""});
        assertEquals(""é"", result);
    }

    // Test: str is non-empty, set is non-empty, set contains all nulls
    @Test
    public void testKeep_SetAllNulls() {
        String result = CharSetUtils.keep(""hello"", new String[]{null, null});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, set contains empty and valid
    @Test
    public void testKeep_SetWithEmptyAndValid() {
        String result = CharSetUtils.keep(""hello"", new String[]{"""", ""o""});
        assertEquals(""o"", result);
    }

    // Test: str is non-empty, set is non-empty, str contains only chars not in set
    @Test
    public void testKeep_StrNoCharsInSet() {
        String result = CharSetUtils.keep(""abc"", new String[]{""xyz""});
        assertEquals("""", result);
    }

    // Test: str is non-empty, set is non-empty, str contains only chars in set
    @Test
    public void testKeep_StrAllCharsInSet() {
        String result = CharSetUtils.keep(""abc"", new String[]{""abc""});
        assertEquals(""abc"", result);
    }

    // Test: str is non-empty, set is non-empty, set is very large
    @Test
    public void testKeep_LargeSet() {
        StringBuilder sb = new StringBuilder();
        for (char c = 32; c < 127; c++) {
            sb.append(c);
        }
        String allChars = sb.toString();
        String result = CharSetUtils.keep(""hello123"", new String[]{allChars});
        assertEquals(""hello123"", result);
    }

    // Test: str is very large, set is small
    @Test
    public void testKeep_LargeStr_SmallSet() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String largeStr = sb.toString();
        String result = CharSetUtils.keep(largeStr, new String[]{""b""});
        assertEquals(10000, result.length());
        for (char c : result.toCharArray()) {
            assertEquals('b', c);
        }
    }

    // Test: str is non-empty, set is empty string
    @Test
    public void testKeep_SetIsEmptyString() {
        String result = CharSetUtils.keep(""hello"", new String[]{""""});
        assertEquals("""", result);
    }

    // Test: str is empty, set is null
    @Test
    public void testKeep_EmptyStr_NullSet() {
        String result = CharSetUtils.keep("""", null);
        assertEquals("""", result);
    }

    // Test: str is empty, set is empty array
    @Test
    public void testKeep_EmptyStr_EmptySet() {
        String result = CharSetUtils.keep("""", new String[]{});
        assertEquals("""", result);
    }

    // Test: str is empty, set is array with empty string
    @Test
    public void testKeep_EmptyStr_SetWithEmptyString() {
        String result = CharSetUtils.keep("""", new String[]{""""});
        assertEquals("""", result);
    }

    // Test: str is empty, set is array with null
    @Test
    public void testKeep_EmptyStr_SetWithNull() {
        String result = CharSetUtils.keep("""", new String[]{null});
        assertEquals("""", result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_keep_java_lang_String_java_lang_StringArray_Test.java
"org.apache.commons.lang3.CharSetUtils.squeeze(java.lang.String, java.lang.String[])","java.lang.String squeeze(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack9; buffer; ch; chars; chrs; i; lastChar; sz;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack9 != 0 goto label1;\n    $stack10 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack10 == 0 goto label2;\n\n  label1:\n    return str;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    $stack12 = new java.lang.StringBuilder;\n    $stack11 = virtualinvoke str.<java.lang.String: int length()>();\n    specialinvoke $stack12.<java.lang.StringBuilder: void <init>(int)>($stack11);\n    buffer = $stack12;\n    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    sz = lengthof chrs;\n    lastChar = 32;\n    ch = 32;\n    i = 0;\n\n  label3:\n    if i >= sz goto label6;\n    ch = chrs[i];\n\n    if ch != lastChar goto label4;\n\n    if i == 0 goto label4;\n    $stack14 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(ch);\n\n    if $stack14 == 0 goto label4;\n\n    goto label5;\n\n  label4:\n    virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(ch);\n    lastChar = ch;\n\n  label5:\n    i = i + 1;\n\n    goto label3;\n\n  label6:\n    $stack13 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack13;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack10 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.String: int length()> via $stack11 = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack12.<java.lang.StringBuilder: void <init>(int)>($stack11);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(ch);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack13 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack9 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String squeeze(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack14 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(ch);,[public ; static ],[public ],"<p>Squeezes any repetitions of a character that is mentioned in the\nsupplied set.</p>\n\n<pre>\nCharSetUtils.squeeze(null; *)        = null\nCharSetUtils.squeeze(""; *)          = ""\nCharSetUtils.squeeze(*; null)        = *\nCharSetUtils.squeeze(*; "")          = *\nCharSetUtils.squeeze(hello""; ""k-p"") = ""helo""\nCharSetUtils.squeeze(""hello""; ""a-e"") = ""hello""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str the string to squeeze; may be null\n@param set the character set to use for manipulation; may be null\n@return the modified String; {@code null} if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    char lastChar = ' ';\n    char ch = ' ';\n    for (int i = 0; i < sz; i++) {\n        ch = chrs[i];\n        // Compare with contains() last for performance.\n        if (ch == lastChar && i != 0 && chars.contains(ch)) {\n            continue;\n        }\n        buffer.append(ch);\n        lastChar = ch;\n    }\n    return buffer.toString();\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_squeeze_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testSqueeze_NullString_NonNullSet() {
        String result = CharSetUtils.squeeze(null, new String[]{""abc""});
        assertNull(result);
    }

    @Test
    public void testSqueeze_NullString_NullSet() {
        String result = CharSetUtils.squeeze(null, null);
        assertNull(result);
    }

    @Test
    public void testSqueeze_EmptyString_NullSet() {
        String result = CharSetUtils.squeeze("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_EmptyString_EmptySet() {
        String result = CharSetUtils.squeeze("""", new String[]{});
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_EmptyString_NonEmptySet() {
        String result = CharSetUtils.squeeze("""", new String[]{""abc""});
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_NullSet() {
        String result = CharSetUtils.squeeze(""abc"", null);
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_EmptySet() {
        String result = CharSetUtils.squeeze(""abc"", new String[]{});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_DeepEmptySet() {
        String result = CharSetUtils.squeeze(""abc"", new String[]{null, """"});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_RepeatedCharsInSet() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""k-p""});
        assertEquals(""helo"", result);
    }

    @Test
    public void testSqueeze_RepeatedCharsNotInSet() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""a-e""});
        assertEquals(""hello"", result);
    }

    @Test
    public void testSqueeze_AllCharsInSet() {
        String result = CharSetUtils.squeeze(""aaaaa"", new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_AlternatingCharsInSet() {
        String result = CharSetUtils.squeeze(""ababab"", new String[]{""a""});
        assertEquals(""ababab"", result);
    }

    @Test
    public void testSqueeze_AlternatingCharsAllInSet() {
        String result = CharSetUtils.squeeze(""aabbcc"", new String[]{""a"", ""b"", ""c""});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_SingleCharStringInSet() {
        String result = CharSetUtils.squeeze(""a"", new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_SingleCharStringNotInSet() {
        String result = CharSetUtils.squeeze(""z"", new String[]{""a""});
        assertEquals(""z"", result);
    }

    @Test
    public void testSqueeze_MixedCaseSet() {
        String result = CharSetUtils.squeeze(""AaAaAAaa"", new String[]{""A""});
        assertEquals(""AaAaAAaa"", result);
    }

    @Test
    public void testSqueeze_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""a"");
        }
        String input = sb.toString();
        String result = CharSetUtils.squeeze(input, new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_SetWithEmptyString() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""""});
        assertEquals(""hello"", result);
    }

    @Test
    public void testSqueeze_SetWithNullAndNonNull() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{null, ""l""});
        assertEquals(""helo"", result);
    }

    @Test
    public void testSqueeze_StringWithWhitespace() {
        String result = CharSetUtils.squeeze(""  foo  bar  "", new String[]{"" ""});
        assertEquals("" foo bar "", result);
    }

    @Test
    public void testSqueeze_StringWithNoRepetitions() {
        String result = CharSetUtils.squeeze(""abcdef"", new String[]{""a-f""});
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testSqueeze_StringWithSpecialChars() {
        String result = CharSetUtils.squeeze(""!!@@##"", new String[]{""!@"", ""#""});
        assertEquals(""!@#"", result);
    }

    @Test
    public void testSqueeze_SetWithOverlappingRanges() {
        String result = CharSetUtils.squeeze(""aabbccddeeff"", new String[]{""a-c"", ""b-d""});
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testSqueeze_StringWithUnicode() {
        String result = CharSetUtils.squeeze(""ääääöööö"", new String[]{""ä"", ""ö""});
        assertEquals(""äö"", result);
    }

    @Test
    public void testSqueeze_StringWithDigits() {
        String result = CharSetUtils.squeeze(""1122334455"", new String[]{""1-5""});
        assertEquals(""12345"", result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_squeeze_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testSqueeze_NullString_NonNullSet() {
        String result = CharSetUtils.squeeze(null, new String[]{""abc""});
        assertNull(result);
    }

    @Test
    public void testSqueeze_NullString_NullSet() {
        String result = CharSetUtils.squeeze(null, null);
        assertNull(result);
    }

    @Test
    public void testSqueeze_EmptyString_NullSet() {
        String result = CharSetUtils.squeeze("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_EmptyString_EmptySet() {
        String result = CharSetUtils.squeeze("""", new String[]{});
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_EmptyString_NonEmptySet() {
        String result = CharSetUtils.squeeze("""", new String[]{""abc""});
        assertEquals("""", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_NullSet() {
        String result = CharSetUtils.squeeze(""abc"", null);
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_EmptySet() {
        String result = CharSetUtils.squeeze(""abc"", new String[]{});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_NonEmptyString_DeepEmptySet() {
        String result = CharSetUtils.squeeze(""abc"", new String[]{null, """"});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_RepeatedCharsInSet() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""k-p""});
        assertEquals(""helo"", result);
    }

    @Test
    public void testSqueeze_RepeatedCharsNotInSet() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""a-e""});
        assertEquals(""hello"", result);
    }

    @Test
    public void testSqueeze_AllCharsInSet() {
        String result = CharSetUtils.squeeze(""aaaaa"", new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_AlternatingCharsInSet() {
        String result = CharSetUtils.squeeze(""ababab"", new String[]{""a""});
        assertEquals(""ababab"", result);
    }

    @Test
    public void testSqueeze_AlternatingCharsAllInSet() {
        String result = CharSetUtils.squeeze(""aabbcc"", new String[]{""a"", ""b"", ""c""});
        assertEquals(""abc"", result);
    }

    @Test
    public void testSqueeze_SingleCharStringInSet() {
        String result = CharSetUtils.squeeze(""a"", new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_SingleCharStringNotInSet() {
        String result = CharSetUtils.squeeze(""z"", new String[]{""a""});
        assertEquals(""z"", result);
    }

    @Test
    public void testSqueeze_MixedCaseSet() {
        String result = CharSetUtils.squeeze(""AaAaAAaa"", new String[]{""A""});
        assertEquals(""AaAaAAaa"", result);
    }

    @Test
    public void testSqueeze_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""a"");
        }
        String input = sb.toString();
        String result = CharSetUtils.squeeze(input, new String[]{""a""});
        assertEquals(""a"", result);
    }

    @Test
    public void testSqueeze_SetWithEmptyString() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{""""});
        assertEquals(""hello"", result);
    }

    @Test
    public void testSqueeze_SetWithNullAndNonNull() {
        String result = CharSetUtils.squeeze(""hello"", new String[]{null, ""l""});
        assertEquals(""helo"", result);
    }

    @Test
    public void testSqueeze_StringWithWhitespace() {
        String result = CharSetUtils.squeeze(""  foo  bar  "", new String[]{"" ""});
        assertEquals("" foo bar "", result);
    }

    @Test
    public void testSqueeze_StringWithNoRepetitions() {
        String result = CharSetUtils.squeeze(""abcdef"", new String[]{""a-f""});
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testSqueeze_StringWithSpecialChars() {
        String result = CharSetUtils.squeeze(""!!@@##"", new String[]{""!@"", ""#""});
        assertEquals(""!@#"", result);
    }

    @Test
    public void testSqueeze_SetWithOverlappingRanges() {
        String result = CharSetUtils.squeeze(""aabbccddeeff"", new String[]{""a-c"", ""b-d""});
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testSqueeze_StringWithUnicode() {
        String result = CharSetUtils.squeeze(""ääääöööö"", new String[]{""ä"", ""ö""});
        assertEquals(""äö"", result);
    }

    @Test
    public void testSqueeze_StringWithDigits() {
        String result = CharSetUtils.squeeze(""1122334455"", new String[]{""1-5""});
        assertEquals(""12345"", result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_squeeze_java_lang_String_java_lang_StringArray_Test.java
org.apache.commons.lang3.CharSetUtils.deepEmpty(java.lang.String[]),boolean deepEmpty(java.lang.String[]),{\n    java.lang.String[] strings;\n    unknown $stack5; l1; l2; l3; s;\n\n\n    strings := @parameter0: java.lang.String[];\n\n    if strings == null goto label3;\n    l1 = strings;\n    l2 = lengthof l1;\n    l3 = 0;\n\n  label1:\n    if l3 >= l2 goto label3;\n    s = l1[l3];\n    $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);\n\n    if $stack5 == 0 goto label2;\n\n    return 0;\n\n  label2:\n    l3 = l3 + 1;\n\n    goto label1;\n\n  label3:\n    return 1;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isNotEmpty(java.lang.CharSequence)>(s);,[private ; static ],[public ],Determines whether or not all the Strings in an array are \nempty or not.\n\n@param strings String[] whose elements are being checked for emptiness\n@return whether or not the String is empty\n,{\n    if (strings != null) {\n        for (final String s : strings) {\n            if (StringUtils.isNotEmpty(s)) {\n                return false;\n            }\n        }\n    }\n    return true;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class CharSetUtils_deepEmpty_java_lang_StringArray_Test {

    /**
     * Utility to invoke the private static deepEmpty method via reflection.
     */
    private boolean invokeDeepEmpty(String[] input) throws Exception {
        Method m = CharSetUtils.class.getDeclaredMethod(""deepEmpty"", String[].class);
        m.setAccessible(true);
        Object result = m.invoke(null, (Object) input);
        return (Boolean) result;
    }

    @Test
    public void testNullArrayReturnsTrue() throws Exception {
        // Per JavaDoc and code, null input should return true
        assertTrue(invokeDeepEmpty(null));
    }

    @Test
    public void testEmptyArrayReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[0]));
    }

    @Test
    public void testAllEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """", """"}));
    }

    @Test
    public void testAllNullStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {null, null, null}));
    }

    @Test
    public void testMixedNullAndEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", null, """", null}));
    }

    @Test
    public void testSingleNonEmptyStringReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""abc""}));
    }

    @Test
    public void testFirstElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""abc"", """", null}));
    }

    @Test
    public void testMiddleElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""def"", """"}));
    }

    @Test
    public void testLastElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", null, ""ghi""}));
    }

    @Test
    public void testMultipleNonEmptyStringsReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""foo"", ""bar"", ""baz""}));
    }

    @Test
    public void testArrayWithWhitespaceStringsReturnsFalse() throws Exception {
        // StringUtils.isNotEmpty("" "") returns true, so whitespace is not empty
        assertFalse(invokeDeepEmpty(new String[] {"" "", ""\t"", ""\n""}));
    }

    @Test
    public void testArrayWithEmptyAndWhitespaceStringsReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", "" "", null, """"}));
    }

    @Test
    public void testArrayWithLongEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """", """"}));
    }

    @Test
    public void testArrayWithLongNonEmptyStringReturnsFalse() throws Exception {
        String longStr = new String(new char[1000]).replace('\0', 'a');
        assertFalse(invokeDeepEmpty(new String[] {longStr}));
    }

    @Test
    public void testArrayWithEmptyAndLongNonEmptyStringReturnsFalse() throws Exception {
        String longStr = new String(new char[1000]).replace('\0', 'b');
        assertFalse(invokeDeepEmpty(new String[] {"""", longStr, """"}));
    }

    @Test
    public void testArrayWithSpecialCharactersReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""!@#$%^&*()""}));
    }

    @Test
    public void testArrayWithUnicodeCharactersReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""\u2603""})); // Unicode snowman
    }

    @Test
    public void testArrayWithEmptyAndUnicodeNullsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", null, """"}));
    }

    @Test
    public void testArrayWithEmptyAndZeroLengthStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """"}));
    }

    @Test
    public void testArrayWithEmptyAndNullAndWhitespaceReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", null, "" ""}));
    }

    @Test
    public void testArrayWithLargeNumberOfEmptyStringsReturnsTrue() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = """";
        assertTrue(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithLargeNumberOfNullsReturnsTrue() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = null;
        assertTrue(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithLargeNumberOfEmptyAndOneNonEmptyReturnsFalse() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = """";
        arr[500] = ""not empty"";
        assertFalse(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithEmptyAndTabCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\t""}));
    }

    @Test
    public void testArrayWithEmptyAndNewlineCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\n""}));
    }

    @Test
    public void testArrayWithEmptyAndZeroCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\0""}));
    }

    @Test
    public void testArrayWithEmptyAndDigitStringReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""0""}));
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class CharSetUtils_deepEmpty_java_lang_StringArray_Test {

    /**
     * Utility to invoke the private static deepEmpty method via reflection.
     */
    private boolean invokeDeepEmpty(String[] input) throws Exception {
        Method m = CharSetUtils.class.getDeclaredMethod(""deepEmpty"", String[].class);
        m.setAccessible(true);
        Object result = m.invoke(null, (Object) input);
        return (Boolean) result;
    }

    @Test
    public void testNullArrayReturnsTrue() throws Exception {
        // Per JavaDoc and code, null input should return true
        assertTrue(invokeDeepEmpty(null));
    }

    @Test
    public void testEmptyArrayReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[0]));
    }

    @Test
    public void testAllEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """", """"}));
    }

    @Test
    public void testAllNullStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {null, null, null}));
    }

    @Test
    public void testMixedNullAndEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", null, """", null}));
    }

    @Test
    public void testSingleNonEmptyStringReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""abc""}));
    }

    @Test
    public void testFirstElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""abc"", """", null}));
    }

    @Test
    public void testMiddleElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""def"", """"}));
    }

    @Test
    public void testLastElementNonEmptyReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", null, ""ghi""}));
    }

    @Test
    public void testMultipleNonEmptyStringsReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""foo"", ""bar"", ""baz""}));
    }

    @Test
    public void testArrayWithWhitespaceStringsReturnsFalse() throws Exception {
        // StringUtils.isNotEmpty("" "") returns true, so whitespace is not empty
        assertFalse(invokeDeepEmpty(new String[] {"" "", ""\t"", ""\n""}));
    }

    @Test
    public void testArrayWithEmptyAndWhitespaceStringsReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", "" "", null, """"}));
    }

    @Test
    public void testArrayWithLongEmptyStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """", """"}));
    }

    @Test
    public void testArrayWithLongNonEmptyStringReturnsFalse() throws Exception {
        String longStr = new String(new char[1000]).replace('\0', 'a');
        assertFalse(invokeDeepEmpty(new String[] {longStr}));
    }

    @Test
    public void testArrayWithEmptyAndLongNonEmptyStringReturnsFalse() throws Exception {
        String longStr = new String(new char[1000]).replace('\0', 'b');
        assertFalse(invokeDeepEmpty(new String[] {"""", longStr, """"}));
    }

    @Test
    public void testArrayWithSpecialCharactersReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""!@#$%^&*()""}));
    }

    @Test
    public void testArrayWithUnicodeCharactersReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {""\u2603""})); // Unicode snowman
    }

    @Test
    public void testArrayWithEmptyAndUnicodeNullsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", null, """"}));
    }

    @Test
    public void testArrayWithEmptyAndZeroLengthStringsReturnsTrue() throws Exception {
        assertTrue(invokeDeepEmpty(new String[] {"""", """"}));
    }

    @Test
    public void testArrayWithEmptyAndNullAndWhitespaceReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", null, "" ""}));
    }

    @Test
    public void testArrayWithLargeNumberOfEmptyStringsReturnsTrue() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = """";
        assertTrue(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithLargeNumberOfNullsReturnsTrue() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = null;
        assertTrue(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithLargeNumberOfEmptyAndOneNonEmptyReturnsFalse() throws Exception {
        String[] arr = new String[1000];
        for (int i = 0; i < arr.length; i++) arr[i] = """";
        arr[500] = ""not empty"";
        assertFalse(invokeDeepEmpty(arr));
    }

    @Test
    public void testArrayWithEmptyAndTabCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\t""}));
    }

    @Test
    public void testArrayWithEmptyAndNewlineCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\n""}));
    }

    @Test
    public void testArrayWithEmptyAndZeroCharacterReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""\0""}));
    }

    @Test
    public void testArrayWithEmptyAndDigitStringReturnsFalse() throws Exception {
        assertFalse(invokeDeepEmpty(new String[] {"""", ""0""}));
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_deepEmpty_java_lang_StringArray_Test.java
"org.apache.commons.lang3.CharSetUtils.modify(java.lang.String, java.lang.String[], boolean)","java.lang.String modify(java.lang.String,java.lang.String[],boolean)",{\n    boolean expect;\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack8; $stack9; buffer; chars; chrs; i; sz;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    expect := @parameter2: boolean;\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    $stack9 = new java.lang.StringBuilder;\n    $stack8 = virtualinvoke str.<java.lang.String: int length()>();\n    specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\n    buffer = $stack9;\n    chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    sz = lengthof chrs;\n    i = 0;\n\n  label1:\n    if i >= sz goto label3;\n    $stack11 = chrs[i];\n    $stack12 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>($stack11);\n\n    if $stack12 != expect goto label2;\n    $stack13 = chrs[i];\n    virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack13);\n\n  label2:\n    i = i + 1;\n\n    goto label1;\n\n  label3:\n    $stack10 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack10;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.String: int length()> via $stack8 = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.String: char[] toCharArray()> via chrs = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buffer.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack13);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack10 = virtualinvoke buffer.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack12 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>($stack11);,[private ; static ],[public ],Implementation of delete and keep\n\n@param str String to modify characters within\n@param set String[] set of characters to modify\n@param expect whether to evaluate on match; or non-match\n@return the modified String; not null\n,{\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i]) == expect) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class CharSetUtils_modify_java_lang_String_java_lang_String_array_boolean_Test {

    // Helper to invoke the private static method via reflection
    private String invokeModify(String str, String[] set, boolean expect) throws Exception {
        Method method = CharSetUtils.class.getDeclaredMethod(""modify"", String.class, String[].class, boolean.class);
        method.setAccessible(true);
        return (String) method.invoke(null, str, set, expect);
    }

    @Test
    public void testDeleteTypical() throws Exception {
        // Delete all vowels from the string
        String input = ""Hello World"";
        String[] set = {""aeiou""};
        boolean expect = false; // delete
        String result = invokeModify(input, set, expect);
        assertEquals(""Hll Wrld"", result);
    }

    @Test
    public void testKeepTypical() throws Exception {
        // Keep only vowels from the string
        String input = ""Hello World"";
        String[] set = {""aeiou""};
        boolean expect = true; // keep
        String result = invokeModify(input, set, expect);
        assertEquals(""eoo"", result);
    }

    @Test
    public void testDeleteNoMatch() throws Exception {
        // No characters in set, so nothing is deleted
        String input = ""abcdef"";
        String[] set = {""xyz""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testKeepNoMatch() throws Exception {
        // No characters in set, so nothing is kept
        String input = ""abcdef"";
        String[] set = {""xyz""};
        boolean expect = true;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testDeleteAll() throws Exception {
        // All characters in set, so all are deleted
        String input = ""aaaa"";
        String[] set = {""a""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testKeepAll() throws Exception {
        // All characters in set, so all are kept
        String input = ""bbbb"";
        String[] set = {""b""};
        boolean expect = true;
        String result = invokeModify(input, set, expect);
        assertEquals(""bbbb"", result);
    }

    @Test
    public void testEmptyString() throws Exception {
        // Empty input string
        String input = """";
        String[] set = {""a""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testEmptySet() throws Exception {
        // Empty set: nothing to match, so for delete, nothing is deleted; for keep, nothing is kept
        String input = ""abc"";
        String[] set = {};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testNullSet() throws Exception {
        // Null set: should behave as empty set
        String input = ""abc"";
        String[] set = null;
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testNullString() throws Exception {
        // Null string: per class javadoc, should handle gracefully, but method expects non-null per JavaDoc
        try {
            invokeModify(null, new String[]{""a""}, false);
            fail(""Expected NullPointerException or similar for null input string"");
        } catch (Exception e) {
            // Acceptable: underlying method may throw NullPointerException or InvocationTargetException wrapping it
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NullPointerException);
        }
    }

    @Test
    public void testStringWithSpecialCharacters() throws Exception {
        // String with special characters, set includes some of them
        String input = ""a!b@c#d$"";
        String[] set = {""!@#$""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcd"", result);

        result = invokeModify(input, set, true);
        assertEquals(""!@#$"", result);
    }

    @Test
    public void testUnicodeCharacters() throws Exception {
        // Unicode characters in string and set
        String input = ""a\u20ACb\u20ACc"";
        String[] set = {""\u20AC""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals(""\u20AC\u20AC"", result);
    }

    @Test
    public void testLargeInput() throws Exception {
        // Large input string
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String input = sb.toString();
        String[] set = {""b""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(input.replace(""b"", """"), result);

        result = invokeModify(input, set, true);
        StringBuilder expected = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            expected.append(""b"");
        }
        assertEquals(expected.toString(), result);
    }

    @Test
    public void testSetWithMultipleRanges() throws Exception {
        // Set with multiple character ranges
        String input = ""abcdef123456"";
        String[] set = {""a-f"", ""1-3""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""456"", result);

        result = invokeModify(input, set, true);
        assertEquals(""abcdef123"", result);
    }

    @Test
    public void testSetWithOverlappingRanges() throws Exception {
        // Set with overlapping ranges
        String input = ""abcdef"";
        String[] set = {""a-c"", ""b-d""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""ef"", result);

        result = invokeModify(input, set, true);
        assertEquals(""abcd"", result);
    }

    @Test
    public void testSetWithNullElement() throws Exception {
        // Set contains null element
        String input = ""abc"";
        String[] set = {null};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testSetWithEmptyStringElement() throws Exception {
        // Set contains empty string element
        String input = ""abc"";
        String[] set = {""""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithSurrogatePairs() throws Exception {
        // String with surrogate pairs (emojis)
        String input = ""a\uD83D\uDE00b""; // a😀b
        String[] set = {""\uD83D\uDE00""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        // Since the method works on char, not code point, the emoji will be split and not matched
        assertEquals(""a\uD83D\uDE00b"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testSetWithWhitespace() throws Exception {
        // Set includes whitespace
        String input = ""a b\tc\nd"";
        String[] set = {"" \t\n""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcd"", result);

        result = invokeModify(input, set, true);
        assertEquals("" \t\n"", result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

public class CharSetUtils_modify_java_lang_String_java_lang_String_array_boolean_Test {

    // Helper to invoke the private static method via reflection
    private String invokeModify(String str, String[] set, boolean expect) throws Exception {
        Method method = CharSetUtils.class.getDeclaredMethod(""modify"", String.class, String[].class, boolean.class);
        method.setAccessible(true);
        return (String) method.invoke(null, str, set, expect);
    }

    @Test
    public void testDeleteTypical() throws Exception {
        // Delete all vowels from the string
        String input = ""Hello World"";
        String[] set = {""aeiou""};
        boolean expect = false; // delete
        String result = invokeModify(input, set, expect);
        assertEquals(""Hll Wrld"", result);
    }

    @Test
    public void testKeepTypical() throws Exception {
        // Keep only vowels from the string
        String input = ""Hello World"";
        String[] set = {""aeiou""};
        boolean expect = true; // keep
        String result = invokeModify(input, set, expect);
        assertEquals(""eoo"", result);
    }

    @Test
    public void testDeleteNoMatch() throws Exception {
        // No characters in set, so nothing is deleted
        String input = ""abcdef"";
        String[] set = {""xyz""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcdef"", result);
    }

    @Test
    public void testKeepNoMatch() throws Exception {
        // No characters in set, so nothing is kept
        String input = ""abcdef"";
        String[] set = {""xyz""};
        boolean expect = true;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testDeleteAll() throws Exception {
        // All characters in set, so all are deleted
        String input = ""aaaa"";
        String[] set = {""a""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testKeepAll() throws Exception {
        // All characters in set, so all are kept
        String input = ""bbbb"";
        String[] set = {""b""};
        boolean expect = true;
        String result = invokeModify(input, set, expect);
        assertEquals(""bbbb"", result);
    }

    @Test
    public void testEmptyString() throws Exception {
        // Empty input string
        String input = """";
        String[] set = {""a""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals("""", result);
    }

    @Test
    public void testEmptySet() throws Exception {
        // Empty set: nothing to match, so for delete, nothing is deleted; for keep, nothing is kept
        String input = ""abc"";
        String[] set = {};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testNullSet() throws Exception {
        // Null set: should behave as empty set
        String input = ""abc"";
        String[] set = null;
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testNullString() throws Exception {
        // Null string: per class javadoc, should handle gracefully, but method expects non-null per JavaDoc
        try {
            invokeModify(null, new String[]{""a""}, false);
            fail(""Expected NullPointerException or similar for null input string"");
        } catch (Exception e) {
            // Acceptable: underlying method may throw NullPointerException or InvocationTargetException wrapping it
            Throwable cause = e.getCause();
            assertTrue(cause instanceof NullPointerException);
        }
    }

    @Test
    public void testStringWithSpecialCharacters() throws Exception {
        // String with special characters, set includes some of them
        String input = ""a!b@c#d$"";
        String[] set = {""!@#$""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcd"", result);

        result = invokeModify(input, set, true);
        assertEquals(""!@#$"", result);
    }

    @Test
    public void testUnicodeCharacters() throws Exception {
        // Unicode characters in string and set
        String input = ""a\u20ACb\u20ACc"";
        String[] set = {""\u20AC""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals(""\u20AC\u20AC"", result);
    }

    @Test
    public void testLargeInput() throws Exception {
        // Large input string
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String input = sb.toString();
        String[] set = {""b""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(input.replace(""b"", """"), result);

        result = invokeModify(input, set, true);
        StringBuilder expected = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            expected.append(""b"");
        }
        assertEquals(expected.toString(), result);
    }

    @Test
    public void testSetWithMultipleRanges() throws Exception {
        // Set with multiple character ranges
        String input = ""abcdef123456"";
        String[] set = {""a-f"", ""1-3""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""456"", result);

        result = invokeModify(input, set, true);
        assertEquals(""abcdef123"", result);
    }

    @Test
    public void testSetWithOverlappingRanges() throws Exception {
        // Set with overlapping ranges
        String input = ""abcdef"";
        String[] set = {""a-c"", ""b-d""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""ef"", result);

        result = invokeModify(input, set, true);
        assertEquals(""abcd"", result);
    }

    @Test
    public void testSetWithNullElement() throws Exception {
        // Set contains null element
        String input = ""abc"";
        String[] set = {null};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testSetWithEmptyStringElement() throws Exception {
        // Set contains empty string element
        String input = ""abc"";
        String[] set = {""""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abc"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithSurrogatePairs() throws Exception {
        // String with surrogate pairs (emojis)
        String input = ""a\uD83D\uDE00b""; // a😀b
        String[] set = {""\uD83D\uDE00""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        // Since the method works on char, not code point, the emoji will be split and not matched
        assertEquals(""a\uD83D\uDE00b"", result);

        result = invokeModify(input, set, true);
        assertEquals("""", result);
    }

    @Test
    public void testSetWithWhitespace() throws Exception {
        // Set includes whitespace
        String input = ""a b\tc\nd"";
        String[] set = {"" \t\n""};
        boolean expect = false;
        String result = invokeModify(input, set, expect);
        assertEquals(""abcd"", result);

        result = invokeModify(input, set, true);
        assertEquals("" \t\n"", result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_modify_java_lang_String_java_lang_String_array_boolean_Test.java
"org.apache.commons.lang3.CharSetUtils.count(java.lang.String, java.lang.String[])","int count(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack10; $stack8; $stack9; c; chars; count; l4; l5; l6;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack8 != 0 goto label1;\n    $stack9 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack9 == 0 goto label2;\n\n  label1:\n    return 0;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    count = 0;\n    l4 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    l5 = lengthof l4;\n    l6 = 0;\n\n  label3:\n    if l6 >= l5 goto label5;\n    c = l4[l6];\n    $stack10 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);\n\n    if $stack10 == 0 goto label4;\n    count = count + 1;\n\n  label4:\n    l6 = l6 + 1;\n\n    goto label3;\n\n  label5:\n    return count;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack9 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via l4 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: int count(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack10 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand returns the number of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.count(null; *)        = 0\nCharSetUtils.count(""; *)          = 0\nCharSetUtils.count(*; null)        = 0\nCharSetUtils.count(*; "")          = 0\nCharSetUtils.count(hello""; ""k-p"") = 3\nCharSetUtils.count(""hello""; ""a-e"") = 1\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to count characters in; may be null\n@param set String[] set of characters to count; may be null\n@return the character count; zero if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_count_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testCount_NullString_NonNullSet() {
        String str = null;
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyString_NonNullSet() {
        String str = """";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_NullSet() {
        String str = ""hello"";
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_EmptySet() {
        String str = ""hello"";
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithEmptyString() {
        String str = ""hello"";
        String[] set = new String[] { """" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithNullElement() {
        String str = ""hello"";
        String[] set = new String[] { null };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithNullAndEmpty() {
        String str = ""hello"";
        String[] set = new String[] { null, """" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_Example_KtoP() {
        String str = ""hello"";
        String[] set = new String[] { ""k-p"" };
        int result = CharSetUtils.count(str, set);
        // 'l', 'l', 'o' are in 'k-p' => 3
        assertEquals(3, result);
    }

    @Test
    public void testCount_Example_AtoE() {
        String str = ""hello"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        // Only 'e' is in 'a-e' => 1
        assertEquals(1, result);
    }

    @Test
    public void testCount_AllCharsMatch() {
        String str = ""abcde"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(5, result);
    }

    @Test
    public void testCount_NoCharsMatch() {
        String str = ""xyz"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_MixedCase() {
        String str = ""aAbBcC"";
        String[] set = new String[] { ""a-c"" };
        int result = CharSetUtils.count(str, set);
        // Only 'a', 'b', 'c' (lowercase) match
        assertEquals(3, result);
    }

    @Test
    public void testCount_SpecialCharacters() {
        String str = ""!@#$%^"";
        String[] set = new String[] { ""!-#"" };
        int result = CharSetUtils.count(str, set);
        // '!', '@', '#' are in '!-#'
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithMultipleRanges() {
        String str = ""abcdefxyz"";
        String[] set = new String[] { ""a-c"", ""x-z"" };
        int result = CharSetUtils.count(str, set);
        // 'a', 'b', 'c', 'x', 'y', 'z' => 6
        assertEquals(6, result);
    }

    @Test
    public void testCount_SetWithOverlappingRanges() {
        String str = ""abcdef"";
        String[] set = new String[] { ""a-d"", ""c-f"" };
        int result = CharSetUtils.count(str, set);
        // 'a', 'b', 'c', 'd', 'e', 'f' => 6
        assertEquals(6, result);
    }

    @Test
    public void testCount_SetWithSingleChar() {
        String str = ""banana"";
        String[] set = new String[] { ""a"" };
        int result = CharSetUtils.count(str, set);
        // 'a' appears 3 times
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithWhitespace() {
        String str = ""a b c"";
        String[] set = new String[] { "" "" };
        int result = CharSetUtils.count(str, set);
        // 2 spaces
        assertEquals(2, result);
    }

    @Test
    public void testCount_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""abc"");
        }
        String str = sb.toString();
        String[] set = new String[] { ""a"" };
        int result = CharSetUtils.count(str, set);
        // 1000 times 'a'
        assertEquals(1000, result);
    }

    @Test
    public void testCount_SetWithNullStringAndNullSet() {
        String str = null;
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_SetWithNullStringAndEmptySet() {
        String str = null;
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyStringAndNullSet() {
        String str = """";
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyStringAndEmptySet() {
        String str = """";
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_SetWithUnicodeRange() {
        String str = ""αβγδε"";
        String[] set = new String[] { ""α-γ"" };
        int result = CharSetUtils.count(str, set);
        // 'α', 'β', 'γ' => 3
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithSurrogatePairs() {
        // Surrogate pairs are not single chars, so should not match
        String str = ""𝄞𝄢"";
        String[] set = new String[] { ""𝄞"" };
        int result = CharSetUtils.count(str, set);
        // Should be 0, as '𝄞' is a surrogate pair, not a single char
        assertEquals(0, result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_count_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testCount_NullString_NonNullSet() {
        String str = null;
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyString_NonNullSet() {
        String str = """";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_NullSet() {
        String str = ""hello"";
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_EmptySet() {
        String str = ""hello"";
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithEmptyString() {
        String str = ""hello"";
        String[] set = new String[] { """" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithNullElement() {
        String str = ""hello"";
        String[] set = new String[] { null };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_NonNullString_SetWithNullAndEmpty() {
        String str = ""hello"";
        String[] set = new String[] { null, """" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_Example_KtoP() {
        String str = ""hello"";
        String[] set = new String[] { ""k-p"" };
        int result = CharSetUtils.count(str, set);
        // 'l', 'l', 'o' are in 'k-p' => 3
        assertEquals(3, result);
    }

    @Test
    public void testCount_Example_AtoE() {
        String str = ""hello"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        // Only 'e' is in 'a-e' => 1
        assertEquals(1, result);
    }

    @Test
    public void testCount_AllCharsMatch() {
        String str = ""abcde"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(5, result);
    }

    @Test
    public void testCount_NoCharsMatch() {
        String str = ""xyz"";
        String[] set = new String[] { ""a-e"" };
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_MixedCase() {
        String str = ""aAbBcC"";
        String[] set = new String[] { ""a-c"" };
        int result = CharSetUtils.count(str, set);
        // Only 'a', 'b', 'c' (lowercase) match
        assertEquals(3, result);
    }

    @Test
    public void testCount_SpecialCharacters() {
        String str = ""!@#$%^"";
        String[] set = new String[] { ""!-#"" };
        int result = CharSetUtils.count(str, set);
        // '!', '@', '#' are in '!-#'
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithMultipleRanges() {
        String str = ""abcdefxyz"";
        String[] set = new String[] { ""a-c"", ""x-z"" };
        int result = CharSetUtils.count(str, set);
        // 'a', 'b', 'c', 'x', 'y', 'z' => 6
        assertEquals(6, result);
    }

    @Test
    public void testCount_SetWithOverlappingRanges() {
        String str = ""abcdef"";
        String[] set = new String[] { ""a-d"", ""c-f"" };
        int result = CharSetUtils.count(str, set);
        // 'a', 'b', 'c', 'd', 'e', 'f' => 6
        assertEquals(6, result);
    }

    @Test
    public void testCount_SetWithSingleChar() {
        String str = ""banana"";
        String[] set = new String[] { ""a"" };
        int result = CharSetUtils.count(str, set);
        // 'a' appears 3 times
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithWhitespace() {
        String str = ""a b c"";
        String[] set = new String[] { "" "" };
        int result = CharSetUtils.count(str, set);
        // 2 spaces
        assertEquals(2, result);
    }

    @Test
    public void testCount_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""abc"");
        }
        String str = sb.toString();
        String[] set = new String[] { ""a"" };
        int result = CharSetUtils.count(str, set);
        // 1000 times 'a'
        assertEquals(1000, result);
    }

    @Test
    public void testCount_SetWithNullStringAndNullSet() {
        String str = null;
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_SetWithNullStringAndEmptySet() {
        String str = null;
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyStringAndNullSet() {
        String str = """";
        String[] set = null;
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_EmptyStringAndEmptySet() {
        String str = """";
        String[] set = new String[0];
        int result = CharSetUtils.count(str, set);
        assertEquals(0, result);
    }

    @Test
    public void testCount_SetWithUnicodeRange() {
        String str = ""αβγδε"";
        String[] set = new String[] { ""α-γ"" };
        int result = CharSetUtils.count(str, set);
        // 'α', 'β', 'γ' => 3
        assertEquals(3, result);
    }

    @Test
    public void testCount_SetWithSurrogatePairs() {
        // Surrogate pairs are not single chars, so should not match
        String str = ""𝄞𝄢"";
        String[] set = new String[] { ""𝄞"" };
        int result = CharSetUtils.count(str, set);
        // Should be 0, as '𝄞' is a surrogate pair, not a single char
        assertEquals(0, result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_count_java_lang_String_java_lang_StringArray_Test.java
"org.apache.commons.lang3.CharSetUtils.containsAny(java.lang.String, java.lang.String[])","boolean containsAny(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack7; $stack8; $stack9; c; chars; l3; l4; l5;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label1;\n    $stack8 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack8 == 0 goto label2;\n\n  label1:\n    return 0;\n\n  label2:\n    chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\n    l3 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    l4 = lengthof l3;\n    l5 = 0;\n\n  label3:\n    if l5 >= l4 goto label5;\n    c = l3[l5];\n    $stack9 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);\n\n    if $stack9 == 0 goto label4;\n\n    return 1;\n\n  label4:\n    l5 = l5 + 1;\n\n    goto label3;\n\n  label5:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack8 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <java.lang.String: char[] toCharArray()> via l3 = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: void <clinit>()> via chars = staticinvoke <org.apache.commons.lang3.CharSet: org.apache.commons.lang3.CharSet getInstance(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: boolean containsAny(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSet: boolean contains(char)> via $stack9 = virtualinvoke chars.<org.apache.commons.lang3.CharSet: boolean contains(char)>(c);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand identifies whether any of the characters are present in the specified string.</p>\n\n<pre>\nCharSetUtils.containsAny(null; *)        = false\nCharSetUtils.containsAny(""; *)          = false\nCharSetUtils.containsAny(*; null)        = false\nCharSetUtils.containsAny(*; "")          = false\nCharSetUtils.containsAny(hello""; ""k-p"") = true\nCharSetUtils.containsAny(""hello""; ""a-d"") = false\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to look for characters in; may be null\n@param set String[] set of characters to identify; may be null\n@return whether or not the characters in the set are in the primary string\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return false;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            return true;\n        }\n    }\n    return false;\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_containsAny_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testContainsAny_NullString_NonNullSet() {
        String str = null;
        String[] set = new String[] {""a"", ""b""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_NonNullSet() {
        String str = """";
        String[] set = new String[] {""a"", ""b""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_NullSet() {
        String str = ""hello"";
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_EmptySet() {
        String str = ""hello"";
        String[] set = new String[0];
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NullString_NullSet() {
        String str = null;
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_EmptySet() {
        String str = """";
        String[] set = new String[0];
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_NullSet() {
        String str = """";
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_SetWithEmptyString() {
        String str = ""hello"";
        String[] set = new String[] {""""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringContainsAnyCharInSet() {
        String str = ""hello"";
        String[] set = new String[] {""k-p""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringDoesNotContainAnyCharInSet() {
        String str = ""hello"";
        String[] set = new String[] {""a-d""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringContainsCharAtStartOfSetRange() {
        String str = ""apple"";
        String[] set = new String[] {""a-c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringContainsCharAtEndOfSetRange() {
        String str = ""zebra"";
        String[] set = new String[] {""y-z""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithAllCharsInSet() {
        String str = ""abc"";
        String[] set = new String[] {""a"", ""b"", ""c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithNoCharsInSet() {
        String str = ""xyz"";
        String[] set = new String[] {""a"", ""b"", ""c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringWithSpecialCharacters() {
        String str = ""hello!"";
        String[] set = new String[] {""!""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithWhitespaceInSet() {
        String str = ""hello world"";
        String[] set = new String[] {"" ""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithUnicodeCharacters() {
        String str = ""héllo"";
        String[] set = new String[] {""é""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithSurrogatePairs() {
        String str = ""hello\uD83D\uDE00"";
        String[] set = new String[] {""\uD83D\uDE00""};
        boolean result = CharSetUtils.containsAny(str, set);
        // Surrogate pairs are not single chars, so should be false
        assertFalse(result);
    }

    @Test
    public void testContainsAny_SetWithNullElement() {
        String str = ""hello"";
        String[] set = new String[] {null, ""e""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_SetWithEmptyAndNonEmptyElements() {
        String str = ""hello"";
        String[] set = new String[] {"""", ""e""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithRepeatedCharsInSet() {
        String str = ""banana"";
        String[] set = new String[] {""a"", ""a"", ""n""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_LargeStringAndSet() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""x"");
        }
        String str = sb.toString();
        String[] set = new String[] {""y"", ""z""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_LargeSetWithMatchingChar() {
        String str = ""hello"";
        String[] set = new String[1000];
        for (int i = 0; i < 999; i++) {
            set[i] = String.valueOf((char)('a' + (i % 26)));
        }
        set[999] = ""h"";
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_containsAny_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testContainsAny_NullString_NonNullSet() {
        String str = null;
        String[] set = new String[] {""a"", ""b""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_NonNullSet() {
        String str = """";
        String[] set = new String[] {""a"", ""b""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_NullSet() {
        String str = ""hello"";
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_EmptySet() {
        String str = ""hello"";
        String[] set = new String[0];
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NullString_NullSet() {
        String str = null;
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_EmptySet() {
        String str = """";
        String[] set = new String[0];
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_EmptyString_NullSet() {
        String str = """";
        String[] set = null;
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_NonEmptyString_SetWithEmptyString() {
        String str = ""hello"";
        String[] set = new String[] {""""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringContainsAnyCharInSet() {
        String str = ""hello"";
        String[] set = new String[] {""k-p""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringDoesNotContainAnyCharInSet() {
        String str = ""hello"";
        String[] set = new String[] {""a-d""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringContainsCharAtStartOfSetRange() {
        String str = ""apple"";
        String[] set = new String[] {""a-c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringContainsCharAtEndOfSetRange() {
        String str = ""zebra"";
        String[] set = new String[] {""y-z""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithAllCharsInSet() {
        String str = ""abc"";
        String[] set = new String[] {""a"", ""b"", ""c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithNoCharsInSet() {
        String str = ""xyz"";
        String[] set = new String[] {""a"", ""b"", ""c""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_StringWithSpecialCharacters() {
        String str = ""hello!"";
        String[] set = new String[] {""!""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithWhitespaceInSet() {
        String str = ""hello world"";
        String[] set = new String[] {"" ""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithUnicodeCharacters() {
        String str = ""héllo"";
        String[] set = new String[] {""é""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithSurrogatePairs() {
        String str = ""hello\uD83D\uDE00"";
        String[] set = new String[] {""\uD83D\uDE00""};
        boolean result = CharSetUtils.containsAny(str, set);
        // Surrogate pairs are not single chars, so should be false
        assertFalse(result);
    }

    @Test
    public void testContainsAny_SetWithNullElement() {
        String str = ""hello"";
        String[] set = new String[] {null, ""e""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_SetWithEmptyAndNonEmptyElements() {
        String str = ""hello"";
        String[] set = new String[] {"""", ""e""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_StringWithRepeatedCharsInSet() {
        String str = ""banana"";
        String[] set = new String[] {""a"", ""a"", ""n""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }

    @Test
    public void testContainsAny_LargeStringAndSet() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""x"");
        }
        String str = sb.toString();
        String[] set = new String[] {""y"", ""z""};
        boolean result = CharSetUtils.containsAny(str, set);
        assertFalse(result);
    }

    @Test
    public void testContainsAny_LargeSetWithMatchingChar() {
        String str = ""hello"";
        String[] set = new String[1000];
        for (int i = 0; i < 999; i++) {
            set[i] = String.valueOf((char)('a' + (i % 26)));
        }
        set[999] = ""h"";
        boolean result = CharSetUtils.containsAny(str, set);
        assertTrue(result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_containsAny_java_lang_String_java_lang_StringArray_Test.java
"org.apache.commons.lang3.CharSetUtils.delete(java.lang.String, java.lang.String[])","java.lang.String delete(java.lang.String,java.lang.String[])",{\n    java.lang.String str;\n    java.lang.String[] set;\n    unknown $stack2; $stack3; $stack4;\n\n\n    str := @parameter0: java.lang.String;\n    set := @parameter1: java.lang.String[];\n    $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack2 != 0 goto label1;\n    $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\n\n    if $stack3 == 0 goto label2;\n\n  label1:\n    return str;\n\n  label2:\n    $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 0);\n\n    return $stack4;\n}\n,Call:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])> via $stack3 = staticinvoke <org.apache.commons.lang3.CharSetUtils: boolean deepEmpty(java.lang.String[])>(set);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)> via $stack4 = staticinvoke <org.apache.commons.lang3.CharSetUtils: java.lang.String modify(java.lang.String;java.lang.String[];boolean)>(str; set; 0);\nCall:<org.apache.commons.lang3.CharSetUtils: java.lang.String delete(java.lang.String;java.lang.String[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack2 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Takes an argument in set-syntax; see evaluateSet;\nand deletes any of characters present in the specified string.</p>\n\n<pre>\nCharSetUtils.delete(null; *)        = null\nCharSetUtils.delete(""; *)          = ""\nCharSetUtils.delete(*; null)        = *\nCharSetUtils.delete(*; "")          = *\nCharSetUtils.delete(hello""; ""hl"")  = ""eo""\nCharSetUtils.delete(""hello""; ""le"")  = ""ho""\n</pre>\n\n@see CharSet#getInstance(java.lang.String...) for set-syntax.\n@param str String to delete characters from; may be null\n@param set String[] set of characters to delete; may be null\n@return the modified String; {@code null} if null string input\n""",{\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str; set; false);\n},[],<p>Operations on {@code CharSet} instances.</p>\n\n<p>This class handles {@code null} input gracefully.\nAn exception will not be thrown for a {@code null} input.\nEach method documents its behaviour in more detail.</p>\n\n<p>#ThreadSafe#</p>\n\n@see CharSet\n@since 1.0\n@version $Id$\n,/**\n * <p>CharSetUtils instances should NOT be constructed in standard programming.\n * Instead; the class should be used as {@code CharSetUtils.evaluateSet(null);}.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean instance\n * to operate.</p>\n */\npublic CharSetUtils() {\n    super();\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_delete_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testDelete_NullString_NullSet() {
        String result = CharSetUtils.delete(null, null);
        assertNull(""Expected null when both str and set are null"", result);
    }

    @Test
    public void testDelete_NullString_NonNullSet() {
        String[] set = {""abc"", ""xyz""};
        String result = CharSetUtils.delete(null, set);
        assertNull(""Expected null when str is null and set is non-null"", result);
    }

    @Test
    public void testDelete_EmptyString_NullSet() {
        String result = CharSetUtils.delete("""", null);
        assertEquals(""Expected empty string when str is empty and set is null"", """", result);
    }

    @Test
    public void testDelete_EmptyString_EmptySet() {
        String[] set = {};
        String result = CharSetUtils.delete("""", set);
        assertEquals(""Expected empty string when str is empty and set is empty"", """", result);
    }

    @Test
    public void testDelete_EmptyString_NonEmptySet() {
        String[] set = {""a"", ""b""};
        String result = CharSetUtils.delete("""", set);
        assertEquals(""Expected empty string when str is empty and set is non-empty"", """", result);
    }

    @Test
    public void testDelete_NonEmptyString_NullSet() {
        String result = CharSetUtils.delete(""abc"", null);
        assertEquals(""Expected original string when set is null"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_EmptySet() {
        String[] set = {};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set is empty"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithEmptyString() {
        String[] set = {""""};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set contains only empty string"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithNullElement() {
        String[] set = {null};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set contains null element"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithWhitespace() {
        String[] set = {"" ""};
        String result = CharSetUtils.delete(""a b c"", set);
        assertEquals(""Expected string with spaces removed"", ""abc"", result);
    }

    @Test
    public void testDelete_ExampleFromJavadoc_hello_hl() {
        String[] set = {""hl""};
        String result = CharSetUtils.delete(""hello"", set);
        assertEquals(""Expected 'eo' when deleting 'h' and 'l' from 'hello'"", ""eo"", result);
    }

    @Test
    public void testDelete_ExampleFromJavadoc_hello_le() {
        String[] set = {""le""};
        String result = CharSetUtils.delete(""hello"", set);
        assertEquals(""Expected 'ho' when deleting 'l' and 'e' from 'hello'"", ""ho"", result);
    }

    @Test
    public void testDelete_StringWithAllCharsInSet() {
        String[] set = {""abc""};
        String result = CharSetUtils.delete(""abcabc"", set);
        assertEquals(""Expected empty string when all chars are deleted"", """", result);
    }

    @Test
    public void testDelete_StringWithNoCharsInSet() {
        String[] set = {""xyz""};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when no chars match set"", ""abc"", result);
    }

    @Test
    public void testDelete_StringWithSpecialCharacters() {
        String[] set = {""!@#""};
        String result = CharSetUtils.delete(""a!b@c#d"", set);
        assertEquals(""Expected string with special characters removed"", ""abcd"", result);
    }

    @Test
    public void testDelete_StringWithUnicodeCharacters() {
        String[] set = {""\u00E9""};
        String result = CharSetUtils.delete(""café"", set);
        assertEquals(""Expected string with é removed"", ""caf"", result);
    }

    @Test
    public void testDelete_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String input = sb.toString();
        String[] set = {""a""};
        String result = CharSetUtils.delete(input, set);
        assertEquals(""Expected string with all 'a' removed"", input.replace(""a"", """"), result);
    }

    @Test
    public void testDelete_SetWithMultipleSets() {
        String[] set = {""aeiou"", ""xyz""};
        String result = CharSetUtils.delete(""The quick brown fox jumps over the lazy dog"", set);
        assertEquals(""Expected string with vowels and xyz removed"", ""Th qck brwn f jmps vr th l d g"", result);
    }

    @Test
    public void testDelete_StringWithNullsInSet() {
        String[] set = {null, ""a""};
        String result = CharSetUtils.delete(""banana"", set);
        assertEquals(""Expected string with 'a' removed"", ""bnn"", result);
    }

    @Test
    public void testDelete_StringWithEmptyStringInSet() {
        String[] set = {"""", ""b""};
        String result = CharSetUtils.delete(""bob"", set);
        assertEquals(""Expected string with 'b' removed"", ""o"", result);
    }

    @Test
    public void testDelete_StringWithSetContainingWhitespaceAndNull() {
        String[] set = {"" "", null};
        String result = CharSetUtils.delete(""a b c"", set);
        assertEquals(""Expected string with spaces removed"", ""abc"", result);
    }

    @Test
    public void testDelete_StringWithSurrogatePairs() {
        String smiley = ""\uD83D\uDE00""; // 😀
        String input = ""a"" + smiley + ""b"";
        String[] set = {smiley};
        String result = CharSetUtils.delete(input, set);
        assertEquals(""Expected string with emoji removed"", ""ab"", result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;

public class CharSetUtils_delete_java_lang_String_java_lang_StringArray_Test {

    @Test
    public void testDelete_NullString_NullSet() {
        String result = CharSetUtils.delete(null, null);
        assertNull(""Expected null when both str and set are null"", result);
    }

    @Test
    public void testDelete_NullString_NonNullSet() {
        String[] set = {""abc"", ""xyz""};
        String result = CharSetUtils.delete(null, set);
        assertNull(""Expected null when str is null and set is non-null"", result);
    }

    @Test
    public void testDelete_EmptyString_NullSet() {
        String result = CharSetUtils.delete("""", null);
        assertEquals(""Expected empty string when str is empty and set is null"", """", result);
    }

    @Test
    public void testDelete_EmptyString_EmptySet() {
        String[] set = {};
        String result = CharSetUtils.delete("""", set);
        assertEquals(""Expected empty string when str is empty and set is empty"", """", result);
    }

    @Test
    public void testDelete_EmptyString_NonEmptySet() {
        String[] set = {""a"", ""b""};
        String result = CharSetUtils.delete("""", set);
        assertEquals(""Expected empty string when str is empty and set is non-empty"", """", result);
    }

    @Test
    public void testDelete_NonEmptyString_NullSet() {
        String result = CharSetUtils.delete(""abc"", null);
        assertEquals(""Expected original string when set is null"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_EmptySet() {
        String[] set = {};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set is empty"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithEmptyString() {
        String[] set = {""""};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set contains only empty string"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithNullElement() {
        String[] set = {null};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when set contains null element"", ""abc"", result);
    }

    @Test
    public void testDelete_NonEmptyString_SetWithWhitespace() {
        String[] set = {"" ""};
        String result = CharSetUtils.delete(""a b c"", set);
        assertEquals(""Expected string with spaces removed"", ""abc"", result);
    }

    @Test
    public void testDelete_ExampleFromJavadoc_hello_hl() {
        String[] set = {""hl""};
        String result = CharSetUtils.delete(""hello"", set);
        assertEquals(""Expected 'eo' when deleting 'h' and 'l' from 'hello'"", ""eo"", result);
    }

    @Test
    public void testDelete_ExampleFromJavadoc_hello_le() {
        String[] set = {""le""};
        String result = CharSetUtils.delete(""hello"", set);
        assertEquals(""Expected 'ho' when deleting 'l' and 'e' from 'hello'"", ""ho"", result);
    }

    @Test
    public void testDelete_StringWithAllCharsInSet() {
        String[] set = {""abc""};
        String result = CharSetUtils.delete(""abcabc"", set);
        assertEquals(""Expected empty string when all chars are deleted"", """", result);
    }

    @Test
    public void testDelete_StringWithNoCharsInSet() {
        String[] set = {""xyz""};
        String result = CharSetUtils.delete(""abc"", set);
        assertEquals(""Expected original string when no chars match set"", ""abc"", result);
    }

    @Test
    public void testDelete_StringWithSpecialCharacters() {
        String[] set = {""!@#""};
        String result = CharSetUtils.delete(""a!b@c#d"", set);
        assertEquals(""Expected string with special characters removed"", ""abcd"", result);
    }

    @Test
    public void testDelete_StringWithUnicodeCharacters() {
        String[] set = {""\u00E9""};
        String result = CharSetUtils.delete(""café"", set);
        assertEquals(""Expected string with é removed"", ""caf"", result);
    }

    @Test
    public void testDelete_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""abc"");
        }
        String input = sb.toString();
        String[] set = {""a""};
        String result = CharSetUtils.delete(input, set);
        assertEquals(""Expected string with all 'a' removed"", input.replace(""a"", """"), result);
    }

    @Test
    public void testDelete_SetWithMultipleSets() {
        String[] set = {""aeiou"", ""xyz""};
        String result = CharSetUtils.delete(""The quick brown fox jumps over the lazy dog"", set);
        assertEquals(""Expected string with vowels and xyz removed"", ""Th qck brwn f jmps vr th l d g"", result);
    }

    @Test
    public void testDelete_StringWithNullsInSet() {
        String[] set = {null, ""a""};
        String result = CharSetUtils.delete(""banana"", set);
        assertEquals(""Expected string with 'a' removed"", ""bnn"", result);
    }

    @Test
    public void testDelete_StringWithEmptyStringInSet() {
        String[] set = {"""", ""b""};
        String result = CharSetUtils.delete(""bob"", set);
        assertEquals(""Expected string with 'b' removed"", ""o"", result);
    }

    @Test
    public void testDelete_StringWithSetContainingWhitespaceAndNull() {
        String[] set = {"" "", null};
        String result = CharSetUtils.delete(""a b c"", set);
        assertEquals(""Expected string with spaces removed"", ""abc"", result);
    }

    @Test
    public void testDelete_StringWithSurrogatePairs() {
        String smiley = ""\uD83D\uDE00""; // 😀
        String input = ""a"" + smiley + ""b"";
        String[] set = {smiley};
        String result = CharSetUtils.delete(input, set);
        assertEquals(""Expected string with emoji removed"", ""ab"", result);
    }
}
",src/test/java/org/apache/commons/lang3/CharSetUtils_delete_java_lang_String_java_lang_StringArray_Test.java
org.apache.commons.lang3.CharRange.contains(org.apache.commons.lang3.CharRange),boolean contains(org.apache.commons.lang3.CharRange),"{\n    org.apache.commons.lang3.CharRange range; this;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack2; $stack20; $stack21; $stack22; $stack23; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    range := @parameter0: org.apache.commons.lang3.CharRange;\n\n    if range != null goto label01;\n    $stack23 = new java.lang.IllegalArgumentException;\n    specialinvoke $stack23.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(The Range must not be null"");\n\n    throw $stack23;\n\n  label01:\n    $stack2 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack2 == 0 goto label08;\n    $stack12 = range.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack12 == 0 goto label04;\n    $stack19 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack18 = range.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack19 < $stack18 goto label02;\n    $stack21 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack20 = range.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack21 > $stack20 goto label02;\n    $stack22 = 1;\n\n    goto label03;\n\n  label02:\n    $stack22 = 0;\n\n  label03:\n    return $stack22;\n\n  label04:\n    $stack14 = range.<org.apache.commons.lang3.CharRange: char end>;\n    $stack13 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack14 < $stack13 goto label05;\n    $stack16 = range.<org.apache.commons.lang3.CharRange: char start>;\n    $stack15 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack16 <= $stack15 goto label06;\n\n  label05:\n    $stack17 = 1;\n\n    goto label07;\n\n  label06:\n    $stack17 = 0;\n\n  label07:\n    return $stack17;\n\n  label08:\n    $stack3 = range.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack3 == 0 goto label11;\n    $stack9 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack9 != 0 goto label09;\n    $stack10 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack10 != 65535 goto label09;\n    $stack11 = 1;\n\n    goto label10;\n\n  label09:\n    $stack11 = 0;\n\n  label10:\n    return $stack11;\n\n  label11:\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack4 = range.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack5 > $stack4 goto label12;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack6 = range.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack7 < $stack6 goto label12;\n    $stack8 = 1;\n\n    goto label13;\n\n  label12:\n    $stack8 = 0;\n\n  label13:\n    return $stack8;\n}\n""","Call:<org.apache.commons.lang3.CharRange: boolean contains(org.apache.commons.lang3.CharRange)> -> <java.lang.IllegalArgumentException: void <init>(java.lang.String)> via specialinvoke $stack23.<java.lang.IllegalArgumentException: void <init>(java.lang.String)>(The Range must not be null"");""",[public ],[final ],<p>Are all the characters of the passed in range contained in\nthis range.</p>\n\n@param range the range to check against\n@return {@code true} if this range entirely contains the input range\n@throws IllegalArgumentException if {@code null} input\n,"{\n    if (range == null) {\n        throw new IllegalArgumentException(The Range must not be null"");\n    }\n    if (negated) {\n        if (range.negated) {\n            return start >= range.start && end <= range.end;\n        }\n        return range.end < start || range.start > end;\n    }\n    if (range.negated) {\n        return start == 0 && end == Character.MAX_VALUE;\n    }\n    return start <= range.start && end >= range.end;\n}""",[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_contains_org_apache_commons_lang3_CharRange_Test {

    // Helper to create CharRange via reflection (since constructor is private)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set private field (for iToString if needed)
    private void setPrivateField(Object obj, String fieldName, Object value) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    @Test
    public void testContains_NullRange_ThrowsException() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        try {
            cr.contains(null);
            fail(""Expected IllegalArgumentException for null input"");
        } catch (IllegalArgumentException e) {
            assertEquals(""The Range must not be null"", e.getMessage());
        }
    }

    @Test
    public void testContains_BothNegated_Contained() throws Exception {
        // this: negated, range: negated, this.start >= range.start && this.end <= range.end
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('c', 'x', true);
        assertTrue(outer.contains(inner));
    }

    @Test
    public void testContains_BothNegated_NotContained_Start() throws Exception {
        // this: negated, range: negated, this.start < range.start
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('a', 'x', true);
        assertFalse(outer.contains(inner));
    }

    @Test
    public void testContains_BothNegated_NotContained_End() throws Exception {
        // this: negated, range: negated, this.end > range.end
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('c', 'z', true);
        assertFalse(outer.contains(inner));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Disjoint_Left() throws Exception {
        // this: negated, range: not negated, range.end < this.start
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'c', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Disjoint_Right() throws Exception {
        // this: negated, range: not negated, range.start > this.end
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('n', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Overlap() throws Exception {
        // this: negated, range: not negated, overlap (should be false)
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('f', 'h', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_TouchingStart() throws Exception {
        // this: negated, range: not negated, range.end == this.start - 1
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'c', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_TouchingEnd() throws Exception {
        // this: negated, range: not negated, range.start == this.end + 1
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('n', 'n', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_WholeRange() throws Exception {
        // this: not negated, range: negated, this.start == 0 && this.end == Character.MAX_VALUE
        CharRange cr = createCharRange((char)0, Character.MAX_VALUE, false);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_NotWholeRange() throws Exception {
        // this: not negated, range: negated, this.start != 0 || this.end != Character.MAX_VALUE
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('b', 'y', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_Contained() throws Exception {
        // this: not negated, range: not negated, this.start <= range.start && this.end >= range.end
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('c', 'x', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_NotContained_Start() throws Exception {
        // this: not negated, range: not negated, this.start > range.start
        CharRange cr = createCharRange('c', 'z', false);
        CharRange range = createCharRange('a', 'x', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_NotContained_End() throws Exception {
        // this: not negated, range: not negated, this.end < range.end
        CharRange cr = createCharRange('a', 'x', false);
        CharRange range = createCharRange('c', 'z', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_EqualRanges() throws Exception {
        // this: not negated, range: not negated, equal
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_EqualRanges() throws Exception {
        // this: negated, range: negated, equal
        CharRange cr = createCharRange('a', 'z', true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapAtStart() throws Exception {
        // this: negated, range: not negated, range.end == this.start
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'd', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapAtEnd() throws Exception {
        // this: negated, range: not negated, range.start == this.end
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('m', 'z', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_SingleCharContained() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('m', 'm', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_SingleCharNotContained() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('A', 'A', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_SingleCharContained() throws Exception {
        CharRange cr = createCharRange('b', 'y', true);
        CharRange range = createCharRange('c', 'c', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_SingleCharNotContained() throws Exception {
        CharRange cr = createCharRange('b', 'y', true);
        CharRange range = createCharRange('a', 'z', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_WholeRangeFalse() throws Exception {
        // this: not negated, range: negated, but this.start != 0
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('b', 'y', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapFull() throws Exception {
        // this: negated, range: not negated, range fully inside negated range
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('e', 'l', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_EmptyRange() throws Exception {
        // this: negated, range: not negated, empty range (start > end, should be normalized)
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('z', 'a', false); // normalized to ('a','z')
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_EmptyRange() throws Exception {
        // start > end, should be normalized to ('a','z')
        CharRange cr = createCharRange('z', 'a', false); // normalized to ('a','z')
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_EmptyRange() throws Exception {
        // start > end, should be normalized to ('a','z')
        CharRange cr = createCharRange('z', 'a', true); // normalized to ('a','z')
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_CharMinMax() throws Exception {
        CharRange cr = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_CharMaxMin() throws Exception {
        // start > end, should be normalized
        CharRange cr = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_CharMinMax() throws Exception {
        CharRange cr = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_CharMaxMin() throws Exception {
        // start > end, should be normalized
        CharRange cr = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_contains_org_apache_commons_lang3_CharRange_Test {

    // Helper to create CharRange via reflection (since constructor is private)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set private field (for iToString if needed)
    private void setPrivateField(Object obj, String fieldName, Object value) throws Exception {
        Field f = obj.getClass().getDeclaredField(fieldName);
        f.setAccessible(true);
        f.set(obj, value);
    }

    @Test
    public void testContains_NullRange_ThrowsException() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        try {
            cr.contains(null);
            fail(""Expected IllegalArgumentException for null input"");
        } catch (IllegalArgumentException e) {
            assertEquals(""The Range must not be null"", e.getMessage());
        }
    }

    @Test
    public void testContains_BothNegated_Contained() throws Exception {
        // this: negated, range: negated, this.start >= range.start && this.end <= range.end
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('c', 'x', true);
        assertTrue(outer.contains(inner));
    }

    @Test
    public void testContains_BothNegated_NotContained_Start() throws Exception {
        // this: negated, range: negated, this.start < range.start
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('a', 'x', true);
        assertFalse(outer.contains(inner));
    }

    @Test
    public void testContains_BothNegated_NotContained_End() throws Exception {
        // this: negated, range: negated, this.end > range.end
        CharRange outer = createCharRange('b', 'y', true);
        CharRange inner = createCharRange('c', 'z', true);
        assertFalse(outer.contains(inner));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Disjoint_Left() throws Exception {
        // this: negated, range: not negated, range.end < this.start
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'c', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Disjoint_Right() throws Exception {
        // this: negated, range: not negated, range.start > this.end
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('n', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_Overlap() throws Exception {
        // this: negated, range: not negated, overlap (should be false)
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('f', 'h', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_TouchingStart() throws Exception {
        // this: negated, range: not negated, range.end == this.start - 1
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'c', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_TouchingEnd() throws Exception {
        // this: negated, range: not negated, range.start == this.end + 1
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('n', 'n', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_WholeRange() throws Exception {
        // this: not negated, range: negated, this.start == 0 && this.end == Character.MAX_VALUE
        CharRange cr = createCharRange((char)0, Character.MAX_VALUE, false);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_NotWholeRange() throws Exception {
        // this: not negated, range: negated, this.start != 0 || this.end != Character.MAX_VALUE
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('b', 'y', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_Contained() throws Exception {
        // this: not negated, range: not negated, this.start <= range.start && this.end >= range.end
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('c', 'x', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_NotContained_Start() throws Exception {
        // this: not negated, range: not negated, this.start > range.start
        CharRange cr = createCharRange('c', 'z', false);
        CharRange range = createCharRange('a', 'x', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_NotContained_End() throws Exception {
        // this: not negated, range: not negated, this.end < range.end
        CharRange cr = createCharRange('a', 'x', false);
        CharRange range = createCharRange('c', 'z', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_EqualRanges() throws Exception {
        // this: not negated, range: not negated, equal
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_EqualRanges() throws Exception {
        // this: negated, range: negated, equal
        CharRange cr = createCharRange('a', 'z', true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapAtStart() throws Exception {
        // this: negated, range: not negated, range.end == this.start
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('a', 'd', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapAtEnd() throws Exception {
        // this: negated, range: not negated, range.start == this.end
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('m', 'z', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_SingleCharContained() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('m', 'm', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_SingleCharNotContained() throws Exception {
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('A', 'A', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_SingleCharContained() throws Exception {
        CharRange cr = createCharRange('b', 'y', true);
        CharRange range = createCharRange('c', 'c', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_SingleCharNotContained() throws Exception {
        CharRange cr = createCharRange('b', 'y', true);
        CharRange range = createCharRange('a', 'z', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNotNegated_RangeNegated_WholeRangeFalse() throws Exception {
        // this: not negated, range: negated, but this.start != 0
        CharRange cr = createCharRange('a', 'z', false);
        CharRange range = createCharRange('b', 'y', true);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_OverlapFull() throws Exception {
        // this: negated, range: not negated, range fully inside negated range
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('e', 'l', false);
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_ThisNegated_RangeNotNegated_EmptyRange() throws Exception {
        // this: negated, range: not negated, empty range (start > end, should be normalized)
        CharRange cr = createCharRange('d', 'm', true);
        CharRange range = createCharRange('z', 'a', false); // normalized to ('a','z')
        assertFalse(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_EmptyRange() throws Exception {
        // start > end, should be normalized to ('a','z')
        CharRange cr = createCharRange('z', 'a', false); // normalized to ('a','z')
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_EmptyRange() throws Exception {
        // start > end, should be normalized to ('a','z')
        CharRange cr = createCharRange('z', 'a', true); // normalized to ('a','z')
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_CharMinMax() throws Exception {
        CharRange cr = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNotNegated_CharMaxMin() throws Exception {
        // start > end, should be normalized
        CharRange cr = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_CharMinMax() throws Exception {
        CharRange cr = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }

    @Test
    public void testContains_BothNegated_CharMaxMin() throws Exception {
        // start > end, should be normalized
        CharRange cr = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true);
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(cr.contains(range));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_contains_org_apache_commons_lang3_CharRange_Test.java
org.apache.commons.lang3.CharRange.is(char),org.apache.commons.lang3.CharRange is(char),{\n    char ch;\n    unknown $stack1;\n\n\n    ch := @parameter0: char;\n    $stack1 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 0);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange is(char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 0);,[public ; static ],[final ],<p>Constructs a {@code CharRange} over a single character.</p>\n\n@param ch only character in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(ch; ch; false);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;
import java.lang.reflect.Constructor;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.io.Serializable;

public class CharRange_is_char_Test {

    @Test
    public void testIs_withLowercaseLetter() throws Exception {
        char ch = 'a';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        // Check start, end, negated fields via reflection
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withUppercaseLetter() throws Exception {
        char ch = 'Z';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withDigit() throws Exception {
        char ch = '5';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withSpecialCharacter() throws Exception {
        char ch = '#';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withMinCharValue() throws Exception {
        char ch = Character.MIN_VALUE;
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withMaxCharValue() throws Exception {
        char ch = Character.MAX_VALUE;
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withSurrogateChar() throws Exception {
        char ch = '\uD800'; // High surrogate
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withWhitespaceChar() throws Exception {
        char ch = ' ';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withControlChar() throws Exception {
        char ch = '\n';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_toStringAndImmutability() throws Exception {
        char ch = 'x';
        CharRange range = CharRange.is(ch);
        String str1 = range.toString();
        String str2 = range.toString();
        assertEquals(str1, str2);
        // Try to mutate fields (should not be possible)
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        try {
            startField.setChar(range, 'y');
            fail(""Should not be able to modify final field"");
        } catch (IllegalAccessException | IllegalArgumentException expected) {
            // Expected: cannot modify final field
        }
    }

    @Test
    public void testIs_withSupplementaryCharValue() throws Exception {
        // Supplementary chars are outside char range, but test with high/low surrogates
        char highSurrogate = '\uDBFF';
        char lowSurrogate = '\uDC00';
        CharRange rangeHigh = CharRange.is(highSurrogate);
        CharRange rangeLow = CharRange.is(lowSurrogate);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(highSurrogate, startField.getChar(rangeHigh));
        assertEquals(highSurrogate, endField.getChar(rangeHigh));
        assertFalse(negatedField.getBoolean(rangeHigh));
        assertEquals(lowSurrogate, startField.getChar(rangeLow));
        assertEquals(lowSurrogate, endField.getChar(rangeLow));
        assertFalse(negatedField.getBoolean(rangeLow));
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;
import java.lang.reflect.Constructor;
import java.util.NoSuchElementException;
import java.util.Iterator;
import java.io.Serializable;

public class CharRange_is_char_Test {

    @Test
    public void testIs_withLowercaseLetter() throws Exception {
        char ch = 'a';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        // Check start, end, negated fields via reflection
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withUppercaseLetter() throws Exception {
        char ch = 'Z';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withDigit() throws Exception {
        char ch = '5';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withSpecialCharacter() throws Exception {
        char ch = '#';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withMinCharValue() throws Exception {
        char ch = Character.MIN_VALUE;
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withMaxCharValue() throws Exception {
        char ch = Character.MAX_VALUE;
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withSurrogateChar() throws Exception {
        char ch = '\uD800'; // High surrogate
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withWhitespaceChar() throws Exception {
        char ch = ' ';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_withControlChar() throws Exception {
        char ch = '\n';
        CharRange range = CharRange.is(ch);
        assertNotNull(range);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(ch, startField.getChar(range));
        assertEquals(ch, endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testIs_toStringAndImmutability() throws Exception {
        char ch = 'x';
        CharRange range = CharRange.is(ch);
        String str1 = range.toString();
        String str2 = range.toString();
        assertEquals(str1, str2);
        // Try to mutate fields (should not be possible)
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        try {
            startField.setChar(range, 'y');
            fail(""Should not be able to modify final field"");
        } catch (IllegalAccessException | IllegalArgumentException expected) {
            // Expected: cannot modify final field
        }
    }

    @Test
    public void testIs_withSupplementaryCharValue() throws Exception {
        // Supplementary chars are outside char range, but test with high/low surrogates
        char highSurrogate = '\uDBFF';
        char lowSurrogate = '\uDC00';
        CharRange rangeHigh = CharRange.is(highSurrogate);
        CharRange rangeLow = CharRange.is(lowSurrogate);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals(highSurrogate, startField.getChar(rangeHigh));
        assertEquals(highSurrogate, endField.getChar(rangeHigh));
        assertFalse(negatedField.getBoolean(rangeHigh));
        assertEquals(lowSurrogate, startField.getChar(rangeLow));
        assertEquals(lowSurrogate, endField.getChar(rangeLow));
        assertFalse(negatedField.getBoolean(rangeLow));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_is_char_Test.java
org.apache.commons.lang3.CharRange.iterator(),java.util.Iterator iterator(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = new org.apache.commons.lang3.CharRange$CharacterIterator;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)>(this; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: java.util.Iterator iterator()> -> <org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange$CharacterIterator: void <init>(org.apache.commons.lang3.CharRange;org.apache.commons.lang3.CharRange$1)>(this; null);,[public ],[final ],<p>Returns an iterator which can be used to walk through the characters described by this range.</p>\n\n<p>#NotThreadSafe# the iterator is not thread-safe</p>\n\n@return an iterator to the chars represented by this range\n@since 2.5\n,{\n    return new CharacterIterator(this);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_iterator__Test {

    // Helper: Expose a concrete CharRange since the constructor is private
    private static class TestCharRange extends CharRange {
        // Expose a public constructor for testing
        public TestCharRange(char start, char end, boolean negated) {
            super(start, end, negated);
        }
    }

    // Helper: Use reflection to access the private constructor of CharRange
    private CharRange createCharRange(char start, char end, boolean negated) {
        try {
            java.lang.reflect.Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
            ctor.setAccessible(true);
            return ctor.newInstance(start, end, negated);
        } catch (Exception e) {
            throw new RuntimeException(""Failed to create CharRange instance via reflection"", e);
        }
    }

    @Test
    public void testIterator_NormalRange() {
        // Range: 'a' to 'e', not negated
        CharRange range = createCharRange('a', 'e', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('a'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('b'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('c'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('d'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('e'), it.next());
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_SingleCharRange() {
        // Range: 'z' to 'z', not negated
        CharRange range = createCharRange('z', 'z', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('z'), it.next());
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_ReversedRange() {
        // Range: 'e' to 'a', not negated (should be normalized to 'a' to 'e')
        CharRange range = createCharRange('e', 'a', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('a'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('b'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('c'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('d'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('e'), it.next());
        assertFalse(it.hasNext());
    }

    @Test
    public void testIterator_NegatedRange() {
        // Range: 'b' to 'd', negated (should iterate over all chars except 'b', 'c', 'd')
        CharRange range = createCharRange('b', 'd', true);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        // Should start at Character.MIN_VALUE and skip 'b', 'c', 'd' up to Character.MAX_VALUE
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            assertTrue(ch < 'b' || ch > 'd');
            count++;
        }
        // There are 65536 chars in total, minus 3 excluded
        assertEquals(65536 - 3, count);
    }

    @Test
    public void testIterator_EmptyRange() {
        // Range: '\u0000' to '\u0000', not negated
        CharRange range = createCharRange('\u0000', '\u0000', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('\u0000'), it.next());
        assertFalse(it.hasNext());
    }

    @Test
    public void testIterator_NegatedFullRange() {
        // Range: Character.MIN_VALUE to Character.MAX_VALUE, negated (should be empty)
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_FullRange() {
        // Range: Character.MIN_VALUE to Character.MAX_VALUE, not negated (should cover all chars)
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Iterator<?> it = range.iterator();
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            count++;
        }
        assertEquals(65536, count);
    }

    @Test
    public void testIterator_NegatedSingleChar() {
        // Range: 'x' to 'x', negated (should iterate all except 'x')
        CharRange range = createCharRange('x', 'x', true);
        Iterator<?> it = range.iterator();
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            assertTrue(ch != 'x');
            count++;
        }
        assertEquals(65536 - 1, count);
    }

    @Test
    public void testIterator_RemoveUnsupported() {
        // Range: 'a' to 'b', not negated
        CharRange range = createCharRange('a', 'b', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        try {
            it.remove();
            fail(""Expected UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }
}
```","package org.apache.commons.lang3;

import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_iterator__Test {

    // Helper: Expose a concrete CharRange since the constructor is private
    private static class TestCharRange extends CharRange {
        // Expose a public constructor for testing
        public TestCharRange(char start, char end, boolean negated) {
            super(start, end, negated);
        }
    }

    // Helper: Use reflection to access the private constructor of CharRange
    private CharRange createCharRange(char start, char end, boolean negated) {
        try {
            java.lang.reflect.Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
            ctor.setAccessible(true);
            return ctor.newInstance(start, end, negated);
        } catch (Exception e) {
            throw new RuntimeException(""Failed to create CharRange instance via reflection"", e);
        }
    }

    @Test
    public void testIterator_NormalRange() {
        // Range: 'a' to 'e', not negated
        CharRange range = createCharRange('a', 'e', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('a'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('b'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('c'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('d'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('e'), it.next());
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_SingleCharRange() {
        // Range: 'z' to 'z', not negated
        CharRange range = createCharRange('z', 'z', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('z'), it.next());
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_ReversedRange() {
        // Range: 'e' to 'a', not negated (should be normalized to 'a' to 'e')
        CharRange range = createCharRange('e', 'a', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('a'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('b'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('c'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('d'), it.next());
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('e'), it.next());
        assertFalse(it.hasNext());
    }

    @Test
    public void testIterator_NegatedRange() {
        // Range: 'b' to 'd', negated (should iterate over all chars except 'b', 'c', 'd')
        CharRange range = createCharRange('b', 'd', true);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        // Should start at Character.MIN_VALUE and skip 'b', 'c', 'd' up to Character.MAX_VALUE
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            assertTrue(ch < 'b' || ch > 'd');
            count++;
        }
        // There are 65536 chars in total, minus 3 excluded
        assertEquals(65536 - 3, count);
    }

    @Test
    public void testIterator_EmptyRange() {
        // Range: '\u0000' to '\u0000', not negated
        CharRange range = createCharRange('\u0000', '\u0000', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertTrue(it.hasNext());
        assertEquals(Character.valueOf('\u0000'), it.next());
        assertFalse(it.hasNext());
    }

    @Test
    public void testIterator_NegatedFullRange() {
        // Range: Character.MIN_VALUE to Character.MAX_VALUE, negated (should be empty)
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        assertFalse(it.hasNext());
        try {
            it.next();
            fail(""Expected NoSuchElementException"");
        } catch (NoSuchElementException ex) {
            // expected
        }
    }

    @Test
    public void testIterator_FullRange() {
        // Range: Character.MIN_VALUE to Character.MAX_VALUE, not negated (should cover all chars)
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        Iterator<?> it = range.iterator();
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            count++;
        }
        assertEquals(65536, count);
    }

    @Test
    public void testIterator_NegatedSingleChar() {
        // Range: 'x' to 'x', negated (should iterate all except 'x')
        CharRange range = createCharRange('x', 'x', true);
        Iterator<?> it = range.iterator();
        int count = 0;
        while (it.hasNext()) {
            Character ch = (Character) it.next();
            assertNotNull(ch);
            assertTrue(ch != 'x');
            count++;
        }
        assertEquals(65536 - 1, count);
    }

    @Test
    public void testIterator_RemoveUnsupported() {
        // Range: 'a' to 'b', not negated
        CharRange range = createCharRange('a', 'b', false);
        Iterator<?> it = range.iterator();
        assertNotNull(it);
        try {
            it.remove();
            fail(""Expected UnsupportedOperationException"");
        } catch (UnsupportedOperationException ex) {
            // expected
        }
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_iterator__Test.java
org.apache.commons.lang3.CharRange.hashCode(),int hashCode(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1; $stack2; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack3 = 83 + $stack1;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack4 = 7 * $stack2;\n    $stack6 = $stack3 + $stack4;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack5 == 0 goto label1;\n    $stack8 = 1;\n\n    goto label2;\n\n  label1:\n    $stack8 = 0;\n\n  label2:\n    $stack7 = $stack6 + $stack8;\n\n    return $stack7;\n}\n,,[public ],[final ],<p>Gets a hashCode compatible with the equals method.</p>\n\n@return a suitable hashCode\n,{\n    return 83 + start + 7 * end + (negated ? 1 : 0);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_hashCode__Test {

    // Helper method to create a CharRange instance via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testHashCode_NonNegated_NormalRange() throws Exception {
        // start < end, negated = false
        CharRange range = createCharRange('a', 'e', false);
        int expected = 83 + 'a' + 7 * 'e' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_Negated_NormalRange() throws Exception {
        // start < end, negated = true
        CharRange range = createCharRange('a', 'e', true);
        int expected = 83 + 'a' + 7 * 'e' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_NonNegated_ReversedRange() throws Exception {
        // start > end, negated = false
        // The constructor swaps start and end
        CharRange range = createCharRange('z', 'a', false);
        // After swap: start = 'a', end = 'z'
        int expected = 83 + 'a' + 7 * 'z' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_Negated_ReversedRange() throws Exception {
        // start > end, negated = true
        // The constructor swaps start and end
        CharRange range = createCharRange('z', 'a', true);
        // After swap: start = 'a', end = 'z'
        int expected = 83 + 'a' + 7 * 'z' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_SingleChar_NonNegated() throws Exception {
        // start == end, negated = false
        CharRange range = createCharRange('x', 'x', false);
        int expected = 83 + 'x' + 7 * 'x' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_SingleChar_Negated() throws Exception {
        // start == end, negated = true
        CharRange range = createCharRange('x', 'x', true);
        int expected = 83 + 'x' + 7 * 'x' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinChar_NonNegated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MIN_VALUE, negated = false
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MIN_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxChar_Negated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MAX_VALUE, negated = true
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        int expected = 83 + Character.MAX_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinToMax_NonNegated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MAX_VALUE, negated = false
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinToMax_Negated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MAX_VALUE, negated = true
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxToMin_NonNegated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MIN_VALUE, negated = false
        // Should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxToMin_Negated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MIN_VALUE, negated = true
        // Should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_ReflectionAccessToFields() throws Exception {
        // Directly set fields to test edge cases, e.g., transient/corrupted state
        CharRange range = createCharRange('a', 'b', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);

        startField.setChar(range, 'q');
        endField.setChar(range, 'w');
        negatedField.setBoolean(range, true);

        int expected = 83 + 'q' + 7 * 'w' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_ReflectionAccessToFields_NonNegated() throws Exception {
        // Directly set fields to test edge cases, negated = false
        CharRange range = createCharRange('a', 'b', true);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);

        startField.setChar(range, 'm');
        endField.setChar(range, 'n');
        negatedField.setBoolean(range, false);

        int expected = 83 + 'm' + 7 * 'n' + 0;
        assertEquals(expected, range.hashCode());
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_hashCode__Test {

    // Helper method to create a CharRange instance via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testHashCode_NonNegated_NormalRange() throws Exception {
        // start < end, negated = false
        CharRange range = createCharRange('a', 'e', false);
        int expected = 83 + 'a' + 7 * 'e' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_Negated_NormalRange() throws Exception {
        // start < end, negated = true
        CharRange range = createCharRange('a', 'e', true);
        int expected = 83 + 'a' + 7 * 'e' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_NonNegated_ReversedRange() throws Exception {
        // start > end, negated = false
        // The constructor swaps start and end
        CharRange range = createCharRange('z', 'a', false);
        // After swap: start = 'a', end = 'z'
        int expected = 83 + 'a' + 7 * 'z' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_Negated_ReversedRange() throws Exception {
        // start > end, negated = true
        // The constructor swaps start and end
        CharRange range = createCharRange('z', 'a', true);
        // After swap: start = 'a', end = 'z'
        int expected = 83 + 'a' + 7 * 'z' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_SingleChar_NonNegated() throws Exception {
        // start == end, negated = false
        CharRange range = createCharRange('x', 'x', false);
        int expected = 83 + 'x' + 7 * 'x' + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_SingleChar_Negated() throws Exception {
        // start == end, negated = true
        CharRange range = createCharRange('x', 'x', true);
        int expected = 83 + 'x' + 7 * 'x' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinChar_NonNegated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MIN_VALUE, negated = false
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MIN_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxChar_Negated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MAX_VALUE, negated = true
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, true);
        int expected = 83 + Character.MAX_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinToMax_NonNegated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MAX_VALUE, negated = false
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MinToMax_Negated() throws Exception {
        // start = Character.MIN_VALUE, end = Character.MAX_VALUE, negated = true
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxToMin_NonNegated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MIN_VALUE, negated = false
        // Should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 0;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_MaxToMin_Negated() throws Exception {
        // start = Character.MAX_VALUE, end = Character.MIN_VALUE, negated = true
        // Should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true);
        int expected = 83 + Character.MIN_VALUE + 7 * Character.MAX_VALUE + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_ReflectionAccessToFields() throws Exception {
        // Directly set fields to test edge cases, e.g., transient/corrupted state
        CharRange range = createCharRange('a', 'b', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);

        startField.setChar(range, 'q');
        endField.setChar(range, 'w');
        negatedField.setBoolean(range, true);

        int expected = 83 + 'q' + 7 * 'w' + 1;
        assertEquals(expected, range.hashCode());
    }

    @Test
    public void testHashCode_ReflectionAccessToFields_NonNegated() throws Exception {
        // Directly set fields to test edge cases, negated = false
        CharRange range = createCharRange('a', 'b', true);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);

        startField.setChar(range, 'm');
        endField.setChar(range, 'n');
        negatedField.setBoolean(range, false);

        int expected = 83 + 'm' + 7 * 'n' + 0;
        assertEquals(expected, range.hashCode());
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_hashCode__Test.java
org.apache.commons.lang3.CharRange.getEnd(),char getEnd(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Gets the end character for this character range.</p>\n\n@return the end char (inclusive)\n,{\n    return this.end;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_getEnd__Test {

    // Helper method to create a CharRange instance with given start, end, and negated values
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testGetEnd_NormalRange() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        char result = range.getEnd();
        assertEquals('z', result);
    }

    @Test
    public void testGetEnd_SingleCharRange() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        char result = range.getEnd();
        assertEquals('x', result);
    }

    @Test
    public void testGetEnd_NegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'f', true);
        char result = range.getEnd();
        assertEquals('f', result);
    }

    @Test
    public void testGetEnd_ReversedOrder() throws Exception {
        // The constructor should swap start and end if start > end
        CharRange range = createCharRange('z', 'a', false);
        char result = range.getEnd();
        assertEquals('z', result);
    }

    @Test
    public void testGetEnd_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, 'm', false);
        char result = range.getEnd();
        assertEquals('m', result);
    }

    @Test
    public void testGetEnd_MaxChar() throws Exception {
        CharRange range = createCharRange('a', Character.MAX_VALUE, false);
        char result = range.getEnd();
        assertEquals(Character.MAX_VALUE, result);
    }

    @Test
    public void testGetEnd_MinToMaxChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        char result = range.getEnd();
        assertEquals(Character.MAX_VALUE, result);
    }

    @Test
    public void testGetEnd_PrivateFieldReflection() throws Exception {
        // Test that getEnd() returns the actual value of the private field 'end'
        CharRange range = createCharRange('a', 'b', false);
        Field endField = CharRange.class.getDeclaredField(""end"");
        endField.setAccessible(true);
        endField.setChar(range, 'q');
        char result = range.getEnd();
        assertEquals('q', result);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_getEnd__Test {

    // Helper method to create a CharRange instance with given start, end, and negated values
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testGetEnd_NormalRange() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        char result = range.getEnd();
        assertEquals('z', result);
    }

    @Test
    public void testGetEnd_SingleCharRange() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        char result = range.getEnd();
        assertEquals('x', result);
    }

    @Test
    public void testGetEnd_NegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'f', true);
        char result = range.getEnd();
        assertEquals('f', result);
    }

    @Test
    public void testGetEnd_ReversedOrder() throws Exception {
        // The constructor should swap start and end if start > end
        CharRange range = createCharRange('z', 'a', false);
        char result = range.getEnd();
        assertEquals('z', result);
    }

    @Test
    public void testGetEnd_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, 'm', false);
        char result = range.getEnd();
        assertEquals('m', result);
    }

    @Test
    public void testGetEnd_MaxChar() throws Exception {
        CharRange range = createCharRange('a', Character.MAX_VALUE, false);
        char result = range.getEnd();
        assertEquals(Character.MAX_VALUE, result);
    }

    @Test
    public void testGetEnd_MinToMaxChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        char result = range.getEnd();
        assertEquals(Character.MAX_VALUE, result);
    }

    @Test
    public void testGetEnd_PrivateFieldReflection() throws Exception {
        // Test that getEnd() returns the actual value of the private field 'end'
        CharRange range = createCharRange('a', 'b', false);
        Field endField = CharRange.class.getDeclaredField(""end"");
        endField.setAccessible(true);
        endField.setChar(range, 'q');
        char result = range.getEnd();
        assertEquals('q', result);
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_getEnd__Test.java
org.apache.commons.lang3.CharRange.isNegated(),boolean isNegated(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Is this {@code CharRange} negated.</p>\n\n<p>A negated range includes everything except that defined by the\nstart and end characters.</p>\n\n@return {@code true} if negated\n,{\n    return negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_isNegated__Test {

    // Helper method to create CharRange instances via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        java.lang.reflect.Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testIsNegated_trueForNegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(""Expected isNegated() to return true for negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_falseForNonNegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertFalse(""Expected isNegated() to return false for non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_singleCharRangeNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        assertTrue(""Expected isNegated() to return true for single char negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_singleCharRangeNonNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        assertFalse(""Expected isNegated() to return false for single char non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_reversedRangeNegated() throws Exception {
        // start > end, should be swapped internally
        CharRange range = createCharRange('z', 'a', true);
        assertTrue(""Expected isNegated() to return true for reversed negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_reversedRangeNonNegated() throws Exception {
        // start > end, should be swapped internally
        CharRange range = createCharRange('z', 'a', false);
        assertFalse(""Expected isNegated() to return false for reversed non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_minCharMaxCharNegated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertTrue(""Expected isNegated() to return true for full char range negated"", range.isNegated());
    }

    @Test
    public void testIsNegated_minCharMaxCharNonNegated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertFalse(""Expected isNegated() to return false for full char range non-negated"", range.isNegated());
    }

    @Test
    public void testIsNegated_reflectionAccess() throws Exception {
        // Directly set the 'negated' field via reflection to true
        CharRange range = createCharRange('a', 'b', false);
        java.lang.reflect.Field negatedField = CharRange.class.getDeclaredField(""negated"");
        negatedField.setAccessible(true);
        negatedField.setBoolean(range, true);
        assertTrue(""Expected isNegated() to return true after reflection set"", range.isNegated());

        // Set to false
        negatedField.setBoolean(range, false);
        assertFalse(""Expected isNegated() to return false after reflection set"", range.isNegated());
    }

    @Test
    public void testIsNegated_multipleInstances() throws Exception {
        CharRange range1 = createCharRange('a', 'b', true);
        CharRange range2 = createCharRange('c', 'd', false);
        CharRange range3 = createCharRange('e', 'f', true);
        assertTrue(range1.isNegated());
        assertFalse(range2.isNegated());
        assertTrue(range3.isNegated());
    }

    @Test
    public void testIsNegated_extremeValues() throws Exception {
        CharRange range = createCharRange('\u0000', '\uffff', true);
        assertTrue(range.isNegated());
        range = createCharRange('\u0000', '\uffff', false);
        assertFalse(range.isNegated());
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_isNegated__Test {

    // Helper method to create CharRange instances via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        java.lang.reflect.Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testIsNegated_trueForNegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'z', true);
        assertTrue(""Expected isNegated() to return true for negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_falseForNonNegatedRange() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertFalse(""Expected isNegated() to return false for non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_singleCharRangeNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        assertTrue(""Expected isNegated() to return true for single char negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_singleCharRangeNonNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        assertFalse(""Expected isNegated() to return false for single char non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_reversedRangeNegated() throws Exception {
        // start > end, should be swapped internally
        CharRange range = createCharRange('z', 'a', true);
        assertTrue(""Expected isNegated() to return true for reversed negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_reversedRangeNonNegated() throws Exception {
        // start > end, should be swapped internally
        CharRange range = createCharRange('z', 'a', false);
        assertFalse(""Expected isNegated() to return false for reversed non-negated range"", range.isNegated());
    }

    @Test
    public void testIsNegated_minCharMaxCharNegated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertTrue(""Expected isNegated() to return true for full char range negated"", range.isNegated());
    }

    @Test
    public void testIsNegated_minCharMaxCharNonNegated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertFalse(""Expected isNegated() to return false for full char range non-negated"", range.isNegated());
    }

    @Test
    public void testIsNegated_reflectionAccess() throws Exception {
        // Directly set the 'negated' field via reflection to true
        CharRange range = createCharRange('a', 'b', false);
        java.lang.reflect.Field negatedField = CharRange.class.getDeclaredField(""negated"");
        negatedField.setAccessible(true);
        negatedField.setBoolean(range, true);
        assertTrue(""Expected isNegated() to return true after reflection set"", range.isNegated());

        // Set to false
        negatedField.setBoolean(range, false);
        assertFalse(""Expected isNegated() to return false after reflection set"", range.isNegated());
    }

    @Test
    public void testIsNegated_multipleInstances() throws Exception {
        CharRange range1 = createCharRange('a', 'b', true);
        CharRange range2 = createCharRange('c', 'd', false);
        CharRange range3 = createCharRange('e', 'f', true);
        assertTrue(range1.isNegated());
        assertFalse(range2.isNegated());
        assertTrue(range3.isNegated());
    }

    @Test
    public void testIsNegated_extremeValues() throws Exception {
        CharRange range = createCharRange('\u0000', '\uffff', true);
        assertTrue(range.isNegated());
        range = createCharRange('\u0000', '\uffff', false);
        assertFalse(range.isNegated());
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_isNegated__Test.java
"org.apache.commons.lang3.CharRange.isNotIn(char, char)","org.apache.commons.lang3.CharRange isNotIn(char,char)",{\n    char end; start;\n    unknown $stack2;\n\n\n    start := @parameter0: char;\n    end := @parameter1: char;\n    $stack2 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 1);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isNotIn(char;char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 1);,[public ; static ],[final ],<p>Constructs a negated {@code CharRange} over a set of characters.</p>\n\n@param start first character; inclusive; in this range\n@param end last character; inclusive; in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(start; end; true);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_isNotIn_char_char_Test {

    @Test
    public void testIsNotIn_NormalRange() throws Exception {
        char start = 'a';
        char end = 'z';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('a', getStart(range));
        assertEquals('z', getEnd(range));
    }

    @Test
    public void testIsNotIn_ReversedRange() throws Exception {
        char start = 'z';
        char end = 'a';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('a', getStart(range));
        assertEquals('z', getEnd(range));
    }

    @Test
    public void testIsNotIn_SingleCharRange() throws Exception {
        char start = 'm';
        char end = 'm';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('m', getStart(range));
        assertEquals('m', getEnd(range));
    }

    @Test
    public void testIsNotIn_MinMaxChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_MaxMinChar() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_NonPrintableChars() throws Exception {
        char start = 0x0000;
        char end = 0x001F;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)0x0000, getStart(range));
        assertEquals((char)0x001F, getEnd(range));
    }

    @Test
    public void testIsNotIn_UpperBoundary() throws Exception {
        char start = (char)65534;
        char end = (char)65535;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)65534, getStart(range));
        assertEquals((char)65535, getEnd(range));
    }

    @Test
    public void testIsNotIn_LowerBoundary() throws Exception {
        char start = (char)0;
        char end = (char)1;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)0, getStart(range));
        assertEquals((char)1, getEnd(range));
    }

    @Test
    public void testIsNotIn_SameMinChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MIN_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_SameMaxChar() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MAX_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    // Helper methods to access private fields via reflection
    private char getStart(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""start"");
        field.setAccessible(true);
        return field.getChar(range);
    }

    private char getEnd(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""end"");
        field.setAccessible(true);
        return field.getChar(range);
    }

    private boolean getNegated(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""negated"");
        field.setAccessible(true);
        return field.getBoolean(range);
    }
}
```","package org.apache.commons.lang3;

import java.io.Serializable;
import java.util.Iterator;
import java.util.NoSuchElementException;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_isNotIn_char_char_Test {

    @Test
    public void testIsNotIn_NormalRange() throws Exception {
        char start = 'a';
        char end = 'z';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('a', getStart(range));
        assertEquals('z', getEnd(range));
    }

    @Test
    public void testIsNotIn_ReversedRange() throws Exception {
        char start = 'z';
        char end = 'a';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('a', getStart(range));
        assertEquals('z', getEnd(range));
    }

    @Test
    public void testIsNotIn_SingleCharRange() throws Exception {
        char start = 'm';
        char end = 'm';
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals('m', getStart(range));
        assertEquals('m', getEnd(range));
    }

    @Test
    public void testIsNotIn_MinMaxChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_MaxMinChar() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_NonPrintableChars() throws Exception {
        char start = 0x0000;
        char end = 0x001F;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)0x0000, getStart(range));
        assertEquals((char)0x001F, getEnd(range));
    }

    @Test
    public void testIsNotIn_UpperBoundary() throws Exception {
        char start = (char)65534;
        char end = (char)65535;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)65534, getStart(range));
        assertEquals((char)65535, getEnd(range));
    }

    @Test
    public void testIsNotIn_LowerBoundary() throws Exception {
        char start = (char)0;
        char end = (char)1;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals((char)0, getStart(range));
        assertEquals((char)1, getEnd(range));
    }

    @Test
    public void testIsNotIn_SameMinChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MIN_VALUE, getStart(range));
        assertEquals(Character.MIN_VALUE, getEnd(range));
    }

    @Test
    public void testIsNotIn_SameMaxChar() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isNotIn(start, end);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(Character.MAX_VALUE, getStart(range));
        assertEquals(Character.MAX_VALUE, getEnd(range));
    }

    // Helper methods to access private fields via reflection
    private char getStart(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""start"");
        field.setAccessible(true);
        return field.getChar(range);
    }

    private char getEnd(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""end"");
        field.setAccessible(true);
        return field.getChar(range);
    }

    private boolean getNegated(CharRange range) throws Exception {
        java.lang.reflect.Field field = CharRange.class.getDeclaredField(""negated"");
        field.setAccessible(true);
        return field.getBoolean(range);
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_isNotIn_char_char_Test.java
org.apache.commons.lang3.CharRange.equals(java.lang.Object),boolean equals(java.lang.Object),{\n    java.lang.Object obj;\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack10; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9; other;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    obj := @parameter0: java.lang.Object;\n\n    if obj != this goto label1;\n\n    return 1;\n\n  label1:\n    $stack3 = obj instanceof org.apache.commons.lang3.CharRange;\n\n    if $stack3 != 0 goto label2;\n\n    return 0;\n\n  label2:\n    other = (org.apache.commons.lang3.CharRange) obj;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack4 = other.<org.apache.commons.lang3.CharRange: char start>;\n\n    if $stack5 != $stack4 goto label3;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n    $stack6 = other.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack7 != $stack6 goto label3;\n    $stack9 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n    $stack8 = other.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack9 != $stack8 goto label3;\n    $stack10 = 1;\n\n    goto label4;\n\n  label3:\n    $stack10 = 0;\n\n  label4:\n    return $stack10;\n}\n,,[public ],[final ],<p>Compares two CharRange objects; returning true if they represent\nexactly the same range of characters defined in the same way.</p>\n\n@param obj the object to compare to\n@return true if equal\n,{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof CharRange == false) {\n        return false;\n    }\n    final CharRange other = (CharRange) obj;\n    return start == other.start && end == other.end && negated == other.negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_equals_java_lang_Object_Test {

    // Helper method to create a CharRange instance via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    // Helper method to set a private field via reflection
    private void setPrivateField(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    @Test
    public void testEquals_SameInstance() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(range.equals(range));
    }

    @Test
    public void testEquals_Null() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertFalse(range.equals(null));
    }

    @Test
    public void testEquals_DifferentClass() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        Object obj = ""not a CharRange"";
        assertFalse(range.equals(obj));
    }

    @Test
    public void testEquals_EqualRanges_Positive() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'z', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_EqualRanges_Negated() throws Exception {
        CharRange range1 = createCharRange('a', 'z', true);
        CharRange range2 = createCharRange('a', 'z', true);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentStart() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('b', 'z', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentEnd() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'y', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentNegated() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'z', true);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_StartGreaterThanEnd_ReversedInConstructor() throws Exception {
        CharRange range1 = createCharRange('z', 'a', false); // should be normalized to 'a'-'z'
        CharRange range2 = createCharRange('a', 'z', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_SingleCharRange() throws Exception {
        CharRange range1 = createCharRange('x', 'x', false);
        CharRange range2 = createCharRange('x', 'x', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_SingleCharRange_DifferentNegated() throws Exception {
        CharRange range1 = createCharRange('x', 'x', false);
        CharRange range2 = createCharRange('x', 'x', true);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_ReflexiveProperty() throws Exception {
        CharRange range = createCharRange('m', 'n', true);
        assertTrue(range.equals(range));
    }

    @Test
    public void testEquals_SymmetricProperty() throws Exception {
        CharRange range1 = createCharRange('c', 'd', false);
        CharRange range2 = createCharRange('c', 'd', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_TransitiveProperty() throws Exception {
        CharRange range1 = createCharRange('p', 'q', true);
        CharRange range2 = createCharRange('p', 'q', true);
        CharRange range3 = createCharRange('p', 'q', true);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range3));
        assertTrue(range1.equals(range3));
    }

    @Test
    public void testEquals_DifferentObjectTypeButSameFields() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        Object obj = new Object() {
            public char start = 'a';
            public char end = 'b';
            public boolean negated = false;
        };
        assertFalse(range.equals(obj));
    }

    @Test
    public void testEquals_DifferentCaseCharacters() throws Exception {
        CharRange range1 = createCharRange('A', 'Z', false);
        CharRange range2 = createCharRange('a', 'z', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_MinMaxCharValues() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range2 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertTrue(range1.equals(range2));
    }

    @Test
    public void testEquals_MinMaxCharValues_Negated() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        CharRange range2 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertTrue(range1.equals(range2));
    }

    @Test
    public void testEquals_DifferentMinMaxCharValues() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range2 = createCharRange(Character.MIN_VALUE, (char)(Character.MAX_VALUE - 1), false);
        assertFalse(range1.equals(range2));
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_equals_java_lang_Object_Test {

    // Helper method to create a CharRange instance via reflection
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    // Helper method to set a private field via reflection
    private void setPrivateField(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    @Test
    public void testEquals_SameInstance() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(range.equals(range));
    }

    @Test
    public void testEquals_Null() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertFalse(range.equals(null));
    }

    @Test
    public void testEquals_DifferentClass() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        Object obj = ""not a CharRange"";
        assertFalse(range.equals(obj));
    }

    @Test
    public void testEquals_EqualRanges_Positive() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'z', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_EqualRanges_Negated() throws Exception {
        CharRange range1 = createCharRange('a', 'z', true);
        CharRange range2 = createCharRange('a', 'z', true);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentStart() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('b', 'z', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentEnd() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'y', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_DifferentNegated() throws Exception {
        CharRange range1 = createCharRange('a', 'z', false);
        CharRange range2 = createCharRange('a', 'z', true);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_StartGreaterThanEnd_ReversedInConstructor() throws Exception {
        CharRange range1 = createCharRange('z', 'a', false); // should be normalized to 'a'-'z'
        CharRange range2 = createCharRange('a', 'z', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_SingleCharRange() throws Exception {
        CharRange range1 = createCharRange('x', 'x', false);
        CharRange range2 = createCharRange('x', 'x', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_SingleCharRange_DifferentNegated() throws Exception {
        CharRange range1 = createCharRange('x', 'x', false);
        CharRange range2 = createCharRange('x', 'x', true);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_ReflexiveProperty() throws Exception {
        CharRange range = createCharRange('m', 'n', true);
        assertTrue(range.equals(range));
    }

    @Test
    public void testEquals_SymmetricProperty() throws Exception {
        CharRange range1 = createCharRange('c', 'd', false);
        CharRange range2 = createCharRange('c', 'd', false);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range1));
    }

    @Test
    public void testEquals_TransitiveProperty() throws Exception {
        CharRange range1 = createCharRange('p', 'q', true);
        CharRange range2 = createCharRange('p', 'q', true);
        CharRange range3 = createCharRange('p', 'q', true);
        assertTrue(range1.equals(range2));
        assertTrue(range2.equals(range3));
        assertTrue(range1.equals(range3));
    }

    @Test
    public void testEquals_DifferentObjectTypeButSameFields() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        Object obj = new Object() {
            public char start = 'a';
            public char end = 'b';
            public boolean negated = false;
        };
        assertFalse(range.equals(obj));
    }

    @Test
    public void testEquals_DifferentCaseCharacters() throws Exception {
        CharRange range1 = createCharRange('A', 'Z', false);
        CharRange range2 = createCharRange('a', 'z', false);
        assertFalse(range1.equals(range2));
        assertFalse(range2.equals(range1));
    }

    @Test
    public void testEquals_MinMaxCharValues() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range2 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertTrue(range1.equals(range2));
    }

    @Test
    public void testEquals_MinMaxCharValues_Negated() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        CharRange range2 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertTrue(range1.equals(range2));
    }

    @Test
    public void testEquals_DifferentMinMaxCharValues() throws Exception {
        CharRange range1 = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        CharRange range2 = createCharRange(Character.MIN_VALUE, (char)(Character.MAX_VALUE - 1), false);
        assertFalse(range1.equals(range2));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_equals_java_lang_Object_Test.java
"org.apache.commons.lang3.CharRange.isIn(char, char)","org.apache.commons.lang3.CharRange isIn(char,char)",{\n    char end; start;\n    unknown $stack2;\n\n\n    start := @parameter0: char;\n    end := @parameter1: char;\n    $stack2 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 0);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isIn(char;char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack2.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(start; end; 0);,[public ; static ],[final ],<p>Constructs a {@code CharRange} over a set of characters.</p>\n\n@param start first character; inclusive; in this range\n@param end last character; inclusive; in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(start; end; false);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;

public class CharRange_isIn_char_char_Test {

    @Test
    public void testIsIn_NormalRange() throws Exception {
        char start = 'a';
        char end = 'z';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('z', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_SingleCharRange() throws Exception {
        char start = 'm';
        char end = 'm';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('m', getPrivateCharField(range, ""start""));
        assertEquals('m', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_ReversedRange() throws Exception {
        char start = 'z';
        char end = 'a';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        // The constructor should swap start and end if start > end
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('z', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_MinMaxChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals(Character.MIN_VALUE, getPrivateCharField(range, ""start""));
        assertEquals(Character.MAX_VALUE, getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_MaxMinChar_Reversed() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        // Should be swapped
        assertEquals(Character.MIN_VALUE, getPrivateCharField(range, ""start""));
        assertEquals(Character.MAX_VALUE, getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_AdjacentChars() throws Exception {
        char start = 'a';
        char end = 'b';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('b', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_AdjacentChars_Reversed() throws Exception {
        char start = 'b';
        char end = 'a';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('b', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_NonAlphaChars() throws Exception {
        char start = '0';
        char end = '9';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('0', getPrivateCharField(range, ""start""));
        assertEquals('9', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_SpecialChars() throws Exception {
        char start = '!';
        char end = '~';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('!', getPrivateCharField(range, ""start""));
        assertEquals('~', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    // Helper methods to access private fields
    private char getPrivateCharField(CharRange range, String fieldName) throws Exception {
        Field field = CharRange.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.getChar(range);
    }

    private boolean getPrivateBooleanField(CharRange range, String fieldName) throws Exception {
        Field field = CharRange.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.getBoolean(range);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;

public class CharRange_isIn_char_char_Test {

    @Test
    public void testIsIn_NormalRange() throws Exception {
        char start = 'a';
        char end = 'z';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('z', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_SingleCharRange() throws Exception {
        char start = 'm';
        char end = 'm';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('m', getPrivateCharField(range, ""start""));
        assertEquals('m', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_ReversedRange() throws Exception {
        char start = 'z';
        char end = 'a';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        // The constructor should swap start and end if start > end
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('z', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_MinMaxChar() throws Exception {
        char start = Character.MIN_VALUE;
        char end = Character.MAX_VALUE;
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals(Character.MIN_VALUE, getPrivateCharField(range, ""start""));
        assertEquals(Character.MAX_VALUE, getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_MaxMinChar_Reversed() throws Exception {
        char start = Character.MAX_VALUE;
        char end = Character.MIN_VALUE;
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        // Should be swapped
        assertEquals(Character.MIN_VALUE, getPrivateCharField(range, ""start""));
        assertEquals(Character.MAX_VALUE, getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_AdjacentChars() throws Exception {
        char start = 'a';
        char end = 'b';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('b', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_AdjacentChars_Reversed() throws Exception {
        char start = 'b';
        char end = 'a';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('a', getPrivateCharField(range, ""start""));
        assertEquals('b', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_NonAlphaChars() throws Exception {
        char start = '0';
        char end = '9';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('0', getPrivateCharField(range, ""start""));
        assertEquals('9', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    @Test
    public void testIsIn_SpecialChars() throws Exception {
        char start = '!';
        char end = '~';
        CharRange range = CharRange.isIn(start, end);

        assertNotNull(range);
        assertEquals('!', getPrivateCharField(range, ""start""));
        assertEquals('~', getPrivateCharField(range, ""end""));
        assertFalse(getPrivateBooleanField(range, ""negated""));
    }

    // Helper methods to access private fields
    private char getPrivateCharField(CharRange range, String fieldName) throws Exception {
        Field field = CharRange.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.getChar(range);
    }

    private boolean getPrivateBooleanField(CharRange range, String fieldName) throws Exception {
        Field field = CharRange.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.getBoolean(range);
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_isIn_char_char_Test.java
org.apache.commons.lang3.CharRange.getStart(),char getStart(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack1;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack1 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    return $stack1;\n}\n,,[public ],[final ],<p>Gets the start character for this character range.</p>\n\n@return the start char (inclusive)\n,{\n    return this.start;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_getStart__Test {

    /**
     * Helper method to create a CharRange instance using reflection,
     * since the constructor is private.
     */
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testGetStart_NormalRange() throws Exception {
        CharRange range = createCharRange('a', 'e', false);
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_SingleCharRange() throws Exception {
        CharRange range = createCharRange('z', 'z', false);
        assertEquals('z', range.getStart());
    }

    @Test
    public void testGetStart_ReversedRange() throws Exception {
        // According to constructor, if start > end, they are swapped.
        CharRange range = createCharRange('z', 'a', false);
        // The constructor swaps start and end, so start becomes 'a'
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_NegatedRange() throws Exception {
        CharRange range = createCharRange('b', 'y', true);
        assertEquals('b', range.getStart());
    }

    @Test
    public void testGetStart_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, 'c', false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_MaxChar() throws Exception {
        CharRange range = createCharRange('x', Character.MAX_VALUE, false);
        assertEquals('x', range.getStart());
    }

    @Test
    public void testGetStart_StartEqualsEnd_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_StartEqualsEnd_MaxChar() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        assertEquals(Character.MAX_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_ReversedMinMax() throws Exception {
        // start > end, so should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_NegatedReversed() throws Exception {
        // start > end, negated true, should swap to (a, z)
        CharRange range = createCharRange('z', 'a', true);
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_AccessPrivateFieldDirectly() throws Exception {
        // Directly set the private 'start' field to a value via reflection
        CharRange range = createCharRange('a', 'b', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        startField.setChar(range, 'q');
        assertEquals('q', range.getStart());
    }

    @Test
    public void testGetStart_AccessPrivateFieldWithSwappedConstructor() throws Exception {
        // Create with start > end, then set start field directly
        CharRange range = createCharRange('z', 'a', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        startField.setChar(range, 'm');
        assertEquals('m', range.getStart());
    }

    @Test
    public void testGetStart_NegatedTrueWithSwappedConstructor() throws Exception {
        CharRange range = createCharRange('y', 'b', true);
        assertEquals('b', range.getStart());
    }

    @Test
    public void testGetStart_UnicodeRange() throws Exception {
        CharRange range = createCharRange('\u0100', '\u0200', false);
        assertEquals('\u0100', range.getStart());
    }

    @Test
    public void testGetStart_UnicodeReversed() throws Exception {
        CharRange range = createCharRange('\u0200', '\u0100', false);
        assertEquals('\u0100', range.getStart());
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_getStart__Test {

    /**
     * Helper method to create a CharRange instance using reflection,
     * since the constructor is private.
     */
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> constructor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        constructor.setAccessible(true);
        return constructor.newInstance(start, end, negated);
    }

    @Test
    public void testGetStart_NormalRange() throws Exception {
        CharRange range = createCharRange('a', 'e', false);
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_SingleCharRange() throws Exception {
        CharRange range = createCharRange('z', 'z', false);
        assertEquals('z', range.getStart());
    }

    @Test
    public void testGetStart_ReversedRange() throws Exception {
        // According to constructor, if start > end, they are swapped.
        CharRange range = createCharRange('z', 'a', false);
        // The constructor swaps start and end, so start becomes 'a'
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_NegatedRange() throws Exception {
        CharRange range = createCharRange('b', 'y', true);
        assertEquals('b', range.getStart());
    }

    @Test
    public void testGetStart_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, 'c', false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_MaxChar() throws Exception {
        CharRange range = createCharRange('x', Character.MAX_VALUE, false);
        assertEquals('x', range.getStart());
    }

    @Test
    public void testGetStart_StartEqualsEnd_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_StartEqualsEnd_MaxChar() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        assertEquals(Character.MAX_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_ReversedMinMax() throws Exception {
        // start > end, so should swap to (MIN_VALUE, MAX_VALUE)
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, false);
        assertEquals(Character.MIN_VALUE, range.getStart());
    }

    @Test
    public void testGetStart_NegatedReversed() throws Exception {
        // start > end, negated true, should swap to (a, z)
        CharRange range = createCharRange('z', 'a', true);
        assertEquals('a', range.getStart());
    }

    @Test
    public void testGetStart_AccessPrivateFieldDirectly() throws Exception {
        // Directly set the private 'start' field to a value via reflection
        CharRange range = createCharRange('a', 'b', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        startField.setChar(range, 'q');
        assertEquals('q', range.getStart());
    }

    @Test
    public void testGetStart_AccessPrivateFieldWithSwappedConstructor() throws Exception {
        // Create with start > end, then set start field directly
        CharRange range = createCharRange('z', 'a', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        startField.setAccessible(true);
        startField.setChar(range, 'm');
        assertEquals('m', range.getStart());
    }

    @Test
    public void testGetStart_NegatedTrueWithSwappedConstructor() throws Exception {
        CharRange range = createCharRange('y', 'b', true);
        assertEquals('b', range.getStart());
    }

    @Test
    public void testGetStart_UnicodeRange() throws Exception {
        CharRange range = createCharRange('\u0100', '\u0200', false);
        assertEquals('\u0100', range.getStart());
    }

    @Test
    public void testGetStart_UnicodeReversed() throws Exception {
        CharRange range = createCharRange('\u0200', '\u0100', false);
        assertEquals('\u0100', range.getStart());
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_getStart__Test.java
org.apache.commons.lang3.CharRange.contains(char),boolean contains(char),{\n    char ch;\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack2; $stack3; $stack4; $stack5; $stack6;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    ch := @parameter0: char;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: char start>;\n\n    if ch < $stack2 goto label1;\n    $stack5 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if ch > $stack5 goto label1;\n    $stack6 = 1;\n\n    goto label2;\n\n  label1:\n    $stack6 = 0;\n\n  label2:\n    $stack3 = this.<org.apache.commons.lang3.CharRange: boolean negated>;\n\n    if $stack6 == $stack3 goto label3;\n    $stack4 = 1;\n\n    goto label4;\n\n  label3:\n    $stack4 = 0;\n\n  label4:\n    return $stack4;\n}\n,,[public ],[final ],<p>Is the character specified contained in this range.</p>\n\n@param ch the character to check\n@return {@code true} if this range contains the input character\n,{\n    return (ch >= start && ch <= end) != negated;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_contains_char_Test {

    // Helper to create CharRange via reflection (since constructor is private)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set private field iToString if needed
    private void setIToString(CharRange range, String value) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        f.set(range, value);
    }

    @Test
    public void testContains_WithinRange_NotNegated() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(range.contains('a'));
        assertTrue(range.contains('m'));
        assertTrue(range.contains('z'));
    }

    @Test
    public void testContains_BelowRange_NotNegated() throws Exception {
        CharRange range = createCharRange('d', 'h', false);
        assertFalse(range.contains('c'));
        assertFalse(range.contains('\u0000'));
    }

    @Test
    public void testContains_AboveRange_NotNegated() throws Exception {
        CharRange range = createCharRange('d', 'h', false);
        assertFalse(range.contains('i'));
        assertFalse(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_WithinRange_Negated() throws Exception {
        CharRange range = createCharRange('a', 'z', true);
        assertFalse(range.contains('a'));
        assertFalse(range.contains('m'));
        assertFalse(range.contains('z'));
    }

    @Test
    public void testContains_BelowRange_Negated() throws Exception {
        CharRange range = createCharRange('d', 'h', true);
        assertTrue(range.contains('c'));
        assertTrue(range.contains('\u0000'));
    }

    @Test
    public void testContains_AboveRange_Negated() throws Exception {
        CharRange range = createCharRange('d', 'h', true);
        assertTrue(range.contains('i'));
        assertTrue(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_SingleCharRange_NotNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        assertTrue(range.contains('x'));
        assertFalse(range.contains('w'));
        assertFalse(range.contains('y'));
    }

    @Test
    public void testContains_SingleCharRange_Negated() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        assertFalse(range.contains('x'));
        assertTrue(range.contains('w'));
        assertTrue(range.contains('y'));
    }

    @Test
    public void testContains_StartGreaterThanEnd_NotNegated() throws Exception {
        // Should normalize to ('a', 'z')
        CharRange range = createCharRange('z', 'a', false);
        assertTrue(range.contains('a'));
        assertTrue(range.contains('m'));
        assertTrue(range.contains('z'));
        assertFalse(range.contains('A'));
    }

    @Test
    public void testContains_StartGreaterThanEnd_Negated() throws Exception {
        // Should normalize to ('a', 'z')
        CharRange range = createCharRange('z', 'a', true);
        assertFalse(range.contains('a'));
        assertFalse(range.contains('z'));
        assertTrue(range.contains('A'));
        assertTrue(range.contains('0'));
    }

    @Test
    public void testContains_MinChar_NotNegated() throws Exception {
        CharRange range = createCharRange('\u0000', 'b', false);
        assertTrue(range.contains('\u0000'));
        assertTrue(range.contains('a'));
        assertFalse(range.contains('c'));
    }

    @Test
    public void testContains_MaxChar_NotNegated() throws Exception {
        CharRange range = createCharRange('y', '\uFFFF', false);
        assertTrue(range.contains('y'));
        assertTrue(range.contains('\uFFFF'));
        assertFalse(range.contains('x'));
    }

    @Test
    public void testContains_MinChar_Negated() throws Exception {
        CharRange range = createCharRange('\u0000', 'b', true);
        assertFalse(range.contains('\u0000'));
        assertFalse(range.contains('a'));
        assertTrue(range.contains('c'));
        assertTrue(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_MaxChar_Negated() throws Exception {
        CharRange range = createCharRange('y', '\uFFFF', true);
        assertFalse(range.contains('y'));
        assertFalse(range.contains('\uFFFF'));
        assertTrue(range.contains('x'));
        assertTrue(range.contains('\u0000'));
    }

    @Test
    public void testContains_EmptyRange_NotNegated() throws Exception {
        // Not possible with current constructor, but test degenerate case: start == end+1
        // Since constructor normalizes, this becomes a single char range
        CharRange range = createCharRange('a', 'a', false);
        assertTrue(range.contains('a'));
        assertFalse(range.contains('b'));
    }

    @Test
    public void testContains_EmptyRange_Negated() throws Exception {
        // Not possible with current constructor, but test degenerate case: start == end+1
        // Since constructor normalizes, this becomes a single char range
        CharRange range = createCharRange('a', 'a', true);
        assertFalse(range.contains('a'));
        assertTrue(range.contains('b'));
    }

    @Test
    public void testContains_SpecialCharacters() throws Exception {
        CharRange range = createCharRange('\n', '\r', false);
        assertTrue(range.contains('\n'));
        assertTrue(range.contains('\r'));
        assertTrue(range.contains('\f'));
        assertFalse(range.contains('\t'));
        assertFalse(range.contains('a'));
    }

    @Test
    public void testContains_SpecialCharacters_Negated() throws Exception {
        CharRange range = createCharRange('\n', '\r', true);
        assertFalse(range.contains('\n'));
        assertFalse(range.contains('\r'));
        assertFalse(range.contains('\f'));
        assertTrue(range.contains('\t'));
        assertTrue(range.contains('a'));
    }

    @Test
    public void testContains_BoundaryValues() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertTrue(range.contains(Character.MIN_VALUE));
        assertTrue(range.contains(Character.MAX_VALUE));
        assertTrue(range.contains('A'));
        assertTrue(range.contains('z'));
    }

    @Test
    public void testContains_BoundaryValues_Negated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertFalse(range.contains(Character.MIN_VALUE));
        assertFalse(range.contains(Character.MAX_VALUE));
        assertFalse(range.contains('A'));
        assertFalse(range.contains('z'));
    }

    @Test
    public void testContains_NonPrintableCharacters() throws Exception {
        CharRange range = createCharRange('\u0001', '\u0005', false);
        assertTrue(range.contains('\u0001'));
        assertTrue(range.contains('\u0003'));
        assertTrue(range.contains('\u0005'));
        assertFalse(range.contains('\u0000'));
        assertFalse(range.contains('\u0006'));
    }

    @Test
    public void testContains_NonPrintableCharacters_Negated() throws Exception {
        CharRange range = createCharRange('\u0001', '\u0005', true);
        assertFalse(range.contains('\u0001'));
        assertFalse(range.contains('\u0003'));
        assertFalse(range.contains('\u0005'));
        assertTrue(range.contains('\u0000'));
        assertTrue(range.contains('\u0006'));
    }

    @Test
    public void testContains_ReflectionAccessToFields() throws Exception {
        CharRange range = createCharRange('a', 'c', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals('a', startField.getChar(range));
        assertEquals('c', endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testContains_ReflectionAccessToFields_Negated() throws Exception {
        CharRange range = createCharRange('x', 'z', true);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals('x', startField.getChar(range));
        assertEquals('z', endField.getChar(range));
        assertTrue(negatedField.getBoolean(range));
    }

    @Test
    public void testContains_WithCachedToString() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        setIToString(range, ""dummy"");
        assertTrue(range.contains('a'));
        assertTrue(range.contains('b'));
        assertFalse(range.contains('c'));
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

public class CharRange_contains_char_Test {

    // Helper to create CharRange via reflection (since constructor is private)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set private field iToString if needed
    private void setIToString(CharRange range, String value) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        f.set(range, value);
    }

    @Test
    public void testContains_WithinRange_NotNegated() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        assertTrue(range.contains('a'));
        assertTrue(range.contains('m'));
        assertTrue(range.contains('z'));
    }

    @Test
    public void testContains_BelowRange_NotNegated() throws Exception {
        CharRange range = createCharRange('d', 'h', false);
        assertFalse(range.contains('c'));
        assertFalse(range.contains('\u0000'));
    }

    @Test
    public void testContains_AboveRange_NotNegated() throws Exception {
        CharRange range = createCharRange('d', 'h', false);
        assertFalse(range.contains('i'));
        assertFalse(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_WithinRange_Negated() throws Exception {
        CharRange range = createCharRange('a', 'z', true);
        assertFalse(range.contains('a'));
        assertFalse(range.contains('m'));
        assertFalse(range.contains('z'));
    }

    @Test
    public void testContains_BelowRange_Negated() throws Exception {
        CharRange range = createCharRange('d', 'h', true);
        assertTrue(range.contains('c'));
        assertTrue(range.contains('\u0000'));
    }

    @Test
    public void testContains_AboveRange_Negated() throws Exception {
        CharRange range = createCharRange('d', 'h', true);
        assertTrue(range.contains('i'));
        assertTrue(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_SingleCharRange_NotNegated() throws Exception {
        CharRange range = createCharRange('x', 'x', false);
        assertTrue(range.contains('x'));
        assertFalse(range.contains('w'));
        assertFalse(range.contains('y'));
    }

    @Test
    public void testContains_SingleCharRange_Negated() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        assertFalse(range.contains('x'));
        assertTrue(range.contains('w'));
        assertTrue(range.contains('y'));
    }

    @Test
    public void testContains_StartGreaterThanEnd_NotNegated() throws Exception {
        // Should normalize to ('a', 'z')
        CharRange range = createCharRange('z', 'a', false);
        assertTrue(range.contains('a'));
        assertTrue(range.contains('m'));
        assertTrue(range.contains('z'));
        assertFalse(range.contains('A'));
    }

    @Test
    public void testContains_StartGreaterThanEnd_Negated() throws Exception {
        // Should normalize to ('a', 'z')
        CharRange range = createCharRange('z', 'a', true);
        assertFalse(range.contains('a'));
        assertFalse(range.contains('z'));
        assertTrue(range.contains('A'));
        assertTrue(range.contains('0'));
    }

    @Test
    public void testContains_MinChar_NotNegated() throws Exception {
        CharRange range = createCharRange('\u0000', 'b', false);
        assertTrue(range.contains('\u0000'));
        assertTrue(range.contains('a'));
        assertFalse(range.contains('c'));
    }

    @Test
    public void testContains_MaxChar_NotNegated() throws Exception {
        CharRange range = createCharRange('y', '\uFFFF', false);
        assertTrue(range.contains('y'));
        assertTrue(range.contains('\uFFFF'));
        assertFalse(range.contains('x'));
    }

    @Test
    public void testContains_MinChar_Negated() throws Exception {
        CharRange range = createCharRange('\u0000', 'b', true);
        assertFalse(range.contains('\u0000'));
        assertFalse(range.contains('a'));
        assertTrue(range.contains('c'));
        assertTrue(range.contains('\uFFFF'));
    }

    @Test
    public void testContains_MaxChar_Negated() throws Exception {
        CharRange range = createCharRange('y', '\uFFFF', true);
        assertFalse(range.contains('y'));
        assertFalse(range.contains('\uFFFF'));
        assertTrue(range.contains('x'));
        assertTrue(range.contains('\u0000'));
    }

    @Test
    public void testContains_EmptyRange_NotNegated() throws Exception {
        // Not possible with current constructor, but test degenerate case: start == end+1
        // Since constructor normalizes, this becomes a single char range
        CharRange range = createCharRange('a', 'a', false);
        assertTrue(range.contains('a'));
        assertFalse(range.contains('b'));
    }

    @Test
    public void testContains_EmptyRange_Negated() throws Exception {
        // Not possible with current constructor, but test degenerate case: start == end+1
        // Since constructor normalizes, this becomes a single char range
        CharRange range = createCharRange('a', 'a', true);
        assertFalse(range.contains('a'));
        assertTrue(range.contains('b'));
    }

    @Test
    public void testContains_SpecialCharacters() throws Exception {
        CharRange range = createCharRange('\n', '\r', false);
        assertTrue(range.contains('\n'));
        assertTrue(range.contains('\r'));
        assertTrue(range.contains('\f'));
        assertFalse(range.contains('\t'));
        assertFalse(range.contains('a'));
    }

    @Test
    public void testContains_SpecialCharacters_Negated() throws Exception {
        CharRange range = createCharRange('\n', '\r', true);
        assertFalse(range.contains('\n'));
        assertFalse(range.contains('\r'));
        assertFalse(range.contains('\f'));
        assertTrue(range.contains('\t'));
        assertTrue(range.contains('a'));
    }

    @Test
    public void testContains_BoundaryValues() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        assertTrue(range.contains(Character.MIN_VALUE));
        assertTrue(range.contains(Character.MAX_VALUE));
        assertTrue(range.contains('A'));
        assertTrue(range.contains('z'));
    }

    @Test
    public void testContains_BoundaryValues_Negated() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, true);
        assertFalse(range.contains(Character.MIN_VALUE));
        assertFalse(range.contains(Character.MAX_VALUE));
        assertFalse(range.contains('A'));
        assertFalse(range.contains('z'));
    }

    @Test
    public void testContains_NonPrintableCharacters() throws Exception {
        CharRange range = createCharRange('\u0001', '\u0005', false);
        assertTrue(range.contains('\u0001'));
        assertTrue(range.contains('\u0003'));
        assertTrue(range.contains('\u0005'));
        assertFalse(range.contains('\u0000'));
        assertFalse(range.contains('\u0006'));
    }

    @Test
    public void testContains_NonPrintableCharacters_Negated() throws Exception {
        CharRange range = createCharRange('\u0001', '\u0005', true);
        assertFalse(range.contains('\u0001'));
        assertFalse(range.contains('\u0003'));
        assertFalse(range.contains('\u0005'));
        assertTrue(range.contains('\u0000'));
        assertTrue(range.contains('\u0006'));
    }

    @Test
    public void testContains_ReflectionAccessToFields() throws Exception {
        CharRange range = createCharRange('a', 'c', false);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals('a', startField.getChar(range));
        assertEquals('c', endField.getChar(range));
        assertFalse(negatedField.getBoolean(range));
    }

    @Test
    public void testContains_ReflectionAccessToFields_Negated() throws Exception {
        CharRange range = createCharRange('x', 'z', true);
        Field startField = CharRange.class.getDeclaredField(""start"");
        Field endField = CharRange.class.getDeclaredField(""end"");
        Field negatedField = CharRange.class.getDeclaredField(""negated"");
        startField.setAccessible(true);
        endField.setAccessible(true);
        negatedField.setAccessible(true);
        assertEquals('x', startField.getChar(range));
        assertEquals('z', endField.getChar(range));
        assertTrue(negatedField.getBoolean(range));
    }

    @Test
    public void testContains_WithCachedToString() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        setIToString(range, ""dummy"");
        assertTrue(range.contains('a'));
        assertTrue(range.contains('b'));
        assertFalse(range.contains('c'));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_contains_char_Test.java
org.apache.commons.lang3.CharRange.isNot(char),org.apache.commons.lang3.CharRange isNot(char),{\n    char ch;\n    unknown $stack1;\n\n\n    ch := @parameter0: char;\n    $stack1 = new org.apache.commons.lang3.CharRange;\n    specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 1);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.CharRange: org.apache.commons.lang3.CharRange isNot(char)> -> <org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)> via specialinvoke $stack1.<org.apache.commons.lang3.CharRange: void <init>(char;char;boolean)>(ch; ch; 1);,[public ; static ],[final ],<p>Constructs a negated {@code CharRange} over a single character.</p>\n\n@param ch only character in this range\n@return the new CharRange object\n@see CharRange#CharRange(char; char; boolean)\n@since 2.5\n,{\n    return new CharRange(ch; ch; true);\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;

public class CharRange_isNot_char_Test {

    @Test
    public void testIsNot_withLowercaseLetter() throws Exception {
        char ch = 'a';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withUppercaseLetter() throws Exception {
        char ch = 'Z';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withDigit() throws Exception {
        char ch = '5';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withSymbol() throws Exception {
        char ch = '#';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withMinChar() throws Exception {
        char ch = Character.MIN_VALUE;
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withMaxChar() throws Exception {
        char ch = Character.MAX_VALUE;
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withSurrogateChar() throws Exception {
        char ch = '\uD800'; // High surrogate
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withWhitespace() throws Exception {
        char ch = ' ';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withControlChar() throws Exception {
        char ch = '\n';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    // Helper methods to access private fields via reflection
    private char getStart(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""start"");
        f.setAccessible(true);
        return f.getChar(range);
    }

    private char getEnd(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""end"");
        f.setAccessible(true);
        return f.getChar(range);
    }

    private boolean getNegated(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""negated"");
        f.setAccessible(true);
        return f.getBoolean(range);
    }
}
```","package org.apache.commons.lang3;

import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Field;

public class CharRange_isNot_char_Test {

    @Test
    public void testIsNot_withLowercaseLetter() throws Exception {
        char ch = 'a';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withUppercaseLetter() throws Exception {
        char ch = 'Z';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withDigit() throws Exception {
        char ch = '5';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withSymbol() throws Exception {
        char ch = '#';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withMinChar() throws Exception {
        char ch = Character.MIN_VALUE;
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withMaxChar() throws Exception {
        char ch = Character.MAX_VALUE;
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withSurrogateChar() throws Exception {
        char ch = '\uD800'; // High surrogate
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withWhitespace() throws Exception {
        char ch = ' ';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    @Test
    public void testIsNot_withControlChar() throws Exception {
        char ch = '\n';
        CharRange range = CharRange.isNot(ch);

        assertNotNull(range);
        assertTrue(getNegated(range));
        assertEquals(ch, getStart(range));
        assertEquals(ch, getEnd(range));
    }

    // Helper methods to access private fields via reflection
    private char getStart(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""start"");
        f.setAccessible(true);
        return f.getChar(range);
    }

    private char getEnd(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""end"");
        f.setAccessible(true);
        return f.getChar(range);
    }

    private boolean getNegated(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""negated"");
        f.setAccessible(true);
        return f.getBoolean(range);
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_isNot_char_Test.java
org.apache.commons.lang3.CharRange.toString(),java.lang.String toString(),{\n    org.apache.commons.lang3.CharRange this;\n    unknown $stack10; $stack2; $stack3; $stack4; $stack5; $stack6; $stack7; $stack8; $stack9; buf;\n\n\n    this := @this: org.apache.commons.lang3.CharRange;\n    $stack2 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;\n\n    if $stack2 != null goto label3;\n    $stack4 = new java.lang.StringBuilder;\n    specialinvoke $stack4.<java.lang.StringBuilder: void <init>(int)>(4);\n    buf = $stack4;\n    $stack5 = virtualinvoke this.<org.apache.commons.lang3.CharRange: boolean isNegated()>();\n\n    if $stack5 == 0 goto label1;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(94);\n\n  label1:\n    $stack6 = this.<org.apache.commons.lang3.CharRange: char start>;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack6);\n    $stack8 = this.<org.apache.commons.lang3.CharRange: char start>;\n    $stack7 = this.<org.apache.commons.lang3.CharRange: char end>;\n\n    if $stack8 == $stack7 goto label2;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(45);\n    $stack10 = this.<org.apache.commons.lang3.CharRange: char end>;\n    virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack10);\n\n  label2:\n    $stack9 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.String toString()>();\n    this.<org.apache.commons.lang3.CharRange: java.lang.String iToString> = $stack9;\n\n  label3:\n    $stack3 = this.<org.apache.commons.lang3.CharRange: java.lang.String iToString>;\n\n    return $stack3;\n}\n,Call:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack4.<java.lang.StringBuilder: void <init>(int)>(4);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(94);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack6);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>(45);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.StringBuilder append(char)> via virtualinvoke buf.<java.lang.StringBuilder: java.lang.StringBuilder append(char)>($stack10);\nCall:<org.apache.commons.lang3.CharRange: java.lang.String toString()> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack9 = virtualinvoke buf.<java.lang.StringBuilder: java.lang.String toString()>();,[public ],[final ],<p>Gets a string representation of the character range.</p>\n\n@return string representation of this range\n,{\n    if (iToString == null) {\n        final StringBuilder buf = new StringBuilder(4);\n        if (isNegated()) {\n            buf.append('^');\n        }\n        buf.append(start);\n        if (start != end) {\n            buf.append('-');\n            buf.append(end);\n        }\n        iToString = buf.toString();\n    }\n    return iToString;\n},[import java.io.Serializable;\n; import java.util.Iterator;\n; import java.util.NoSuchElementException;\n],<p>A contiguous range of characters; optionally negated.</p>\n\n<p>Instances are immutable.</p>\n\n<p>#ThreadSafe#</p>\n\n@since 1.0\n@version $Id$\n,/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 8270183163158333422L;\n/**\n * The first character; inclusive; in the range.\n */\nprivate final char start;\n/**\n * The last character; inclusive; in the range.\n */\nprivate final char end;\n/**\n * True if the range is everything except the characters specified.\n */\nprivate final boolean negated;\n/**\n * Cached toString.\n */\nprivate transient String iToString;\n\n/**\n * <p>Constructs a {@code CharRange} over a set of characters;\n * optionally negating the range.</p>\n *\n * <p>A negated range includes everything except that defined by the\n * start and end characters.</p>\n *\n * <p>If start and end are in the wrong order; they are reversed.\n * Thus {@code a-e} is the same as {@code e-a}.</p>\n *\n * @param start  first character; inclusive; in this range\n * @param end  last character; inclusive; in this range\n * @param negated  true to express everything except the range\n */\nprivate CharRange(char start; char end; final boolean negated) {\n    super();\n    if (start > end) {\n        final char temp = start;\n        start = end;\n        end = temp;\n    }\n    this.start = start;\n    this.end = end;\n    this.negated = negated;\n}\n,"```java
package org.apache.commons.lang3;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_toString__Test {

    // Helper to create CharRange via reflection (private constructor)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set iToString field via reflection
    private void setIToString(CharRange range, String value) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        f.set(range, value);
    }

    // Helper to get iToString field via reflection
    private String getIToString(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        return (String) f.get(range);
    }

    // Helper to invoke toString via reflection
    private String invokeToString(CharRange range) throws Exception {
        Method m = CharRange.class.getDeclaredMethod(""toString"");
        m.setAccessible(true);
        return (String) m.invoke(range);
    }

    @Test
    public void testToString_NonNegated_SingleChar() throws Exception {
        CharRange range = createCharRange('a', 'a', false);
        String result = invokeToString(range);
        assertEquals(""a"", result);
        // iToString should be cached
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_NonNegated_Range() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        String result = invokeToString(range);
        assertEquals(""a-z"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_SingleChar() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        String result = invokeToString(range);
        assertEquals(""^x"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_Range() throws Exception {
        CharRange range = createCharRange('0', '9', true);
        String result = invokeToString(range);
        assertEquals(""^0-9"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_StartGreaterThanEnd() throws Exception {
        // Should normalize to ('a', 'e')
        CharRange range = createCharRange('e', 'a', false);
        String result = invokeToString(range);
        assertEquals(""a-e"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_StartGreaterThanEnd() throws Exception {
        // Should normalize to ('b', 'd')
        CharRange range = createCharRange('d', 'b', true);
        String result = invokeToString(range);
        assertEquals(""^b-d"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_CachedValue() throws Exception {
        CharRange range = createCharRange('m', 'n', false);
        setIToString(range, ""cached-value"");
        String result = invokeToString(range);
        assertEquals(""cached-value"", result);
        // Should not recompute, iToString remains ""cached-value""
        assertEquals(""cached-value"", getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        String result = invokeToString(range);
        assertEquals(String.valueOf(Character.MIN_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MaxChar() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        String result = invokeToString(range);
        assertEquals(String.valueOf(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MinToMax() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        String result = invokeToString(range);
        assertEquals(Character.toString(Character.MIN_VALUE) + ""-"" + Character.toString(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_BoundaryValues_MinToMax() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true); // Should normalize
        String result = invokeToString(range);
        assertEquals(""^"" + Character.toString(Character.MIN_VALUE) + ""-"" + Character.toString(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_MultipleCalls_CachesResult() throws Exception {
        CharRange range = createCharRange('p', 'q', false);
        String first = invokeToString(range);
        String second = invokeToString(range);
        assertSame(first, second);
        assertEquals(""p-q"", first);
    }

    @Test
    public void testToString_Negated_MultipleCalls_CachesResult() throws Exception {
        CharRange range = createCharRange('x', 'z', true);
        String first = invokeToString(range);
        String second = invokeToString(range);
        assertSame(first, second);
        assertEquals(""^x-z"", first);
    }

    @Test
    public void testToString_EmptyRange() throws Exception {
        // Not possible via constructor: start and end are always at least one char, but test with same char
        CharRange range = createCharRange('c', 'c', false);
        String result = invokeToString(range);
        assertEquals(""c"", result);
    }

    @Test
    public void testToString_Negated_EmptyRange() throws Exception {
        CharRange range = createCharRange('c', 'c', true);
        String result = invokeToString(range);
        assertEquals(""^c"", result);
    }

    @Test
    public void testToString_SpecialChars() throws Exception {
        CharRange range = createCharRange('-', '-', false);
        String result = invokeToString(range);
        assertEquals(""-"", result);

        CharRange range2 = createCharRange('^', '^', false);
        String result2 = invokeToString(range2);
        assertEquals(""^"", result2);

        CharRange range3 = createCharRange('^', '-', false);
        String result3 = invokeToString(range3);
        assertEquals(""-^"", result3);
    }

    @Test
    public void testToString_Negated_SpecialChars() throws Exception {
        CharRange range = createCharRange('-', '-', true);
        String result = invokeToString(range);
        assertEquals(""^-"", result);

        CharRange range2 = createCharRange('^', '^', true);
        String result2 = invokeToString(range2);
        assertEquals(""^^"", result2);

        CharRange range3 = createCharRange('^', '-', true);
        String result3 = invokeToString(range3);
        assertEquals(""^-^"", result3);
    }

    @Test
    public void testToString_NullCachedValue() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        setIToString(range, null);
        String result = invokeToString(range);
        assertEquals(""a-b"", result);
        assertEquals(result, getIToString(range));
    }
}
```","package org.apache.commons.lang3;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import org.junit.Test;
import static org.junit.Assert.*;

public class CharRange_toString__Test {

    // Helper to create CharRange via reflection (private constructor)
    private CharRange createCharRange(char start, char end, boolean negated) throws Exception {
        Constructor<CharRange> ctor = CharRange.class.getDeclaredConstructor(char.class, char.class, boolean.class);
        ctor.setAccessible(true);
        return ctor.newInstance(start, end, negated);
    }

    // Helper to set iToString field via reflection
    private void setIToString(CharRange range, String value) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        f.set(range, value);
    }

    // Helper to get iToString field via reflection
    private String getIToString(CharRange range) throws Exception {
        Field f = CharRange.class.getDeclaredField(""iToString"");
        f.setAccessible(true);
        return (String) f.get(range);
    }

    // Helper to invoke toString via reflection
    private String invokeToString(CharRange range) throws Exception {
        Method m = CharRange.class.getDeclaredMethod(""toString"");
        m.setAccessible(true);
        return (String) m.invoke(range);
    }

    @Test
    public void testToString_NonNegated_SingleChar() throws Exception {
        CharRange range = createCharRange('a', 'a', false);
        String result = invokeToString(range);
        assertEquals(""a"", result);
        // iToString should be cached
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_NonNegated_Range() throws Exception {
        CharRange range = createCharRange('a', 'z', false);
        String result = invokeToString(range);
        assertEquals(""a-z"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_SingleChar() throws Exception {
        CharRange range = createCharRange('x', 'x', true);
        String result = invokeToString(range);
        assertEquals(""^x"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_Range() throws Exception {
        CharRange range = createCharRange('0', '9', true);
        String result = invokeToString(range);
        assertEquals(""^0-9"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_StartGreaterThanEnd() throws Exception {
        // Should normalize to ('a', 'e')
        CharRange range = createCharRange('e', 'a', false);
        String result = invokeToString(range);
        assertEquals(""a-e"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_StartGreaterThanEnd() throws Exception {
        // Should normalize to ('b', 'd')
        CharRange range = createCharRange('d', 'b', true);
        String result = invokeToString(range);
        assertEquals(""^b-d"", result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_CachedValue() throws Exception {
        CharRange range = createCharRange('m', 'n', false);
        setIToString(range, ""cached-value"");
        String result = invokeToString(range);
        assertEquals(""cached-value"", result);
        // Should not recompute, iToString remains ""cached-value""
        assertEquals(""cached-value"", getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MinChar() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MIN_VALUE, false);
        String result = invokeToString(range);
        assertEquals(String.valueOf(Character.MIN_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MaxChar() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MAX_VALUE, false);
        String result = invokeToString(range);
        assertEquals(String.valueOf(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_BoundaryValues_MinToMax() throws Exception {
        CharRange range = createCharRange(Character.MIN_VALUE, Character.MAX_VALUE, false);
        String result = invokeToString(range);
        assertEquals(Character.toString(Character.MIN_VALUE) + ""-"" + Character.toString(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_Negated_BoundaryValues_MinToMax() throws Exception {
        CharRange range = createCharRange(Character.MAX_VALUE, Character.MIN_VALUE, true); // Should normalize
        String result = invokeToString(range);
        assertEquals(""^"" + Character.toString(Character.MIN_VALUE) + ""-"" + Character.toString(Character.MAX_VALUE), result);
        assertEquals(result, getIToString(range));
    }

    @Test
    public void testToString_MultipleCalls_CachesResult() throws Exception {
        CharRange range = createCharRange('p', 'q', false);
        String first = invokeToString(range);
        String second = invokeToString(range);
        assertSame(first, second);
        assertEquals(""p-q"", first);
    }

    @Test
    public void testToString_Negated_MultipleCalls_CachesResult() throws Exception {
        CharRange range = createCharRange('x', 'z', true);
        String first = invokeToString(range);
        String second = invokeToString(range);
        assertSame(first, second);
        assertEquals(""^x-z"", first);
    }

    @Test
    public void testToString_EmptyRange() throws Exception {
        // Not possible via constructor: start and end are always at least one char, but test with same char
        CharRange range = createCharRange('c', 'c', false);
        String result = invokeToString(range);
        assertEquals(""c"", result);
    }

    @Test
    public void testToString_Negated_EmptyRange() throws Exception {
        CharRange range = createCharRange('c', 'c', true);
        String result = invokeToString(range);
        assertEquals(""^c"", result);
    }

    @Test
    public void testToString_SpecialChars() throws Exception {
        CharRange range = createCharRange('-', '-', false);
        String result = invokeToString(range);
        assertEquals(""-"", result);

        CharRange range2 = createCharRange('^', '^', false);
        String result2 = invokeToString(range2);
        assertEquals(""^"", result2);

        CharRange range3 = createCharRange('^', '-', false);
        String result3 = invokeToString(range3);
        assertEquals(""-^"", result3);
    }

    @Test
    public void testToString_Negated_SpecialChars() throws Exception {
        CharRange range = createCharRange('-', '-', true);
        String result = invokeToString(range);
        assertEquals(""^-"", result);

        CharRange range2 = createCharRange('^', '^', true);
        String result2 = invokeToString(range2);
        assertEquals(""^^"", result2);

        CharRange range3 = createCharRange('^', '-', true);
        String result3 = invokeToString(range3);
        assertEquals(""^-^"", result3);
    }

    @Test
    public void testToString_NullCachedValue() throws Exception {
        CharRange range = createCharRange('a', 'b', false);
        setIToString(range, null);
        String result = invokeToString(range);
        assertEquals(""a-b"", result);
        assertEquals(result, getIToString(range));
    }
}
",src/test/java/org/apache/commons/lang3/CharRange_toString__Test.java
org.apache.commons.lang3.concurrent.AtomicInitializer.initialize(),java.lang.Object initialize(),,,[protected ; abstract ],[public ; abstract ],Creates and initializes the object managed by this {@code\nAtomicInitializer}. This method is called by {@link #get()} when the\nmanaged object is not available yet. An implementation can focus on the\ncreation of the object. No synchronization is needed; as this is already\nhandled by {@code get()}. As stated by the class comment; it is possible\nthat this method is called multiple times.\n\n@return the managed data object\n@throws ConcurrentException if an error occurs during object creation\n,,[import java.util.concurrent.atomic.AtomicReference;\n],<p>\nA specialized implementation of the {@code ConcurrentInitializer} interface\nbased on an {@link AtomicReference} variable.\n</p>\n<p>\nThis class maintains a member field of type {@code AtomicReference}. It\nimplements the following algorithm to create and initialize an object in its\n{@link #get()} method:\n<ul>\n<li>First it is checked whether the {@code AtomicReference} variable contains\nalready a value. If this is the case; the value is directly returned.</li>\n<li>Otherwise the {@link #initialize()} method is called. This method must be\ndefined in concrete subclasses to actually create the managed object.</li>\n<li>After the object was created by {@link #initialize()} it is checked\nwhether the {@code AtomicReference} variable is still undefined. This has to\nbe done because in the meantime another thread may have initialized the\nobject. If the reference is still empty; the newly created object is stored\nin it and returned by this method.</li>\n<li>Otherwise the value stored in the {@code AtomicReference} is returned.</li>\n</ul>\n</p>\n<p>\nBecause atomic variables are used this class does not need any\nsynchronization. So there is no danger of deadlock; and access to the managed\nobject is efficient. However; if multiple threads access the {@code\nAtomicInitializer} object before it has been initialized almost at the same\ntime; it can happen that {@link #initialize()} is called multiple times. The\nalgorithm outlined above guarantees that {@link #get()} always returns the\nsame object though.\n</p>\n<p>\nCompared with the {@link LazyInitializer} class; this class can be more\nefficient because it does not need synchronization. The drawback is that the\n{@link #initialize()} method can be called multiple times which may be\nproblematic if the creation of the managed object is expensive. As a rule of\nthumb this initializer implementation is preferable if there are not too many\nthreads involved and the probability that multiple threads access an\nuninitialized object is small. If there is high parallelism;\n{@link LazyInitializer} is more appropriate.\n</p>\n\n@since 3.0\n@version $Id$\n@param <T> the type of the object managed by this initializer class\n,/**\n * Holds the reference to the managed object.\n */\nprivate final AtomicReference<T> reference = new AtomicReference<T>();\n\n,"```java
package org.apache.commons.lang3.concurrent;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.concurrent.atomic.AtomicReference;

public class AtomicInitializer_initialize__Test {

    private static class TestAtomicInitializer extends AtomicInitializer<String> {
        private boolean throwException = false;
        private int callCount = 0;
        private String valueToReturn = ""default"";

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }

        public void setValueToReturn(String value) {
            this.valueToReturn = value;
        }

        public int getCallCount() {
            return callCount;
        }

        @Override
        protected String initialize() throws ConcurrentException {
            callCount++;
            if (throwException) {
                throw new ConcurrentException(""Initialization failed"");
            }
            return valueToReturn;
        }
    }

    @Test
    public void testInitializeReturnsValue() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(""testValue"");
        String result = initializer.initialize();
        assertEquals(""testValue"", result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeReturnsNull() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(null);
        String result = initializer.initialize();
        assertNull(result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeThrowsConcurrentException() {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setThrowException(true);
        try {
            initializer.initialize();
            fail(""Expected ConcurrentException to be thrown"");
        } catch (ConcurrentException ex) {
            assertEquals(""Initialization failed"", ex.getMessage());
        }
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testMultipleInitializeCalls() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(""multi"");
        String first = initializer.initialize();
        String second = initializer.initialize();
        assertEquals(""multi"", first);
        assertEquals(""multi"", second);
        assertEquals(2, initializer.getCallCount());
    }

    @Test
    public void testInitializeWithEmptyString() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn("""");
        String result = initializer.initialize();
        assertEquals("""", result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeWithLargeString() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append('x');
        }
        String largeString = sb.toString();
        initializer.setValueToReturn(largeString);
        String result = initializer.initialize();
        assertEquals(largeString, result);
        assertEquals(1, initializer.getCallCount());
    }
}
```","package org.apache.commons.lang3.concurrent;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.concurrent.atomic.AtomicReference;

public class AtomicInitializer_initialize__Test {

    private static class TestAtomicInitializer extends AtomicInitializer<String> {
        private boolean throwException = false;
        private int callCount = 0;
        private String valueToReturn = ""default"";

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }

        public void setValueToReturn(String value) {
            this.valueToReturn = value;
        }

        public int getCallCount() {
            return callCount;
        }

        @Override
        protected String initialize() throws ConcurrentException {
            callCount++;
            if (throwException) {
                throw new ConcurrentException(""Initialization failed"");
            }
            return valueToReturn;
        }
    }

    @Test
    public void testInitializeReturnsValue() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(""testValue"");
        String result = initializer.initialize();
        assertEquals(""testValue"", result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeReturnsNull() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(null);
        String result = initializer.initialize();
        assertNull(result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeThrowsConcurrentException() {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setThrowException(true);
        try {
            initializer.initialize();
            fail(""Expected ConcurrentException to be thrown"");
        } catch (ConcurrentException ex) {
            assertEquals(""Initialization failed"", ex.getMessage());
        }
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testMultipleInitializeCalls() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn(""multi"");
        String first = initializer.initialize();
        String second = initializer.initialize();
        assertEquals(""multi"", first);
        assertEquals(""multi"", second);
        assertEquals(2, initializer.getCallCount());
    }

    @Test
    public void testInitializeWithEmptyString() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        initializer.setValueToReturn("""");
        String result = initializer.initialize();
        assertEquals("""", result);
        assertEquals(1, initializer.getCallCount());
    }

    @Test
    public void testInitializeWithLargeString() throws Exception {
        TestAtomicInitializer initializer = new TestAtomicInitializer();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append('x');
        }
        String largeString = sb.toString();
        initializer.setValueToReturn(largeString);
        String result = initializer.initialize();
        assertEquals(largeString, result);
        assertEquals(1, initializer.getCallCount());
    }
}
",src/test/java/org/apache/commons/lang3/concurrent/AtomicInitializer_initialize__Test.java
org.apache.commons.lang3.concurrent.AtomicInitializer.get(),java.lang.Object get(),{\n    org.apache.commons.lang3.concurrent.AtomicInitializer this;\n    unknown $stack2; $stack3; $stack4; $stack5; result;\n\n\n    this := @this: org.apache.commons.lang3.concurrent.AtomicInitializer;\n    $stack2 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    result = virtualinvoke $stack2.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\n\n    if result != null goto label1;\n    result = virtualinvoke this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object initialize()>();\n    $stack3 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    $stack4 = virtualinvoke $stack3.<java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)>(null; result);\n\n    if $stack4 != 0 goto label1;\n    $stack5 = this.<org.apache.commons.lang3.concurrent.AtomicInitializer: java.util.concurrent.atomic.AtomicReference reference>;\n    result = virtualinvoke $stack5.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\n\n  label1:\n    return result;\n}\n,Call:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: java.lang.Object get()> via result = virtualinvoke $stack2.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();\nCall:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)> via $stack4 = virtualinvoke $stack3.<java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(java.lang.Object;java.lang.Object)>(null; result);\nCall:<org.apache.commons.lang3.concurrent.AtomicInitializer: java.lang.Object get()> -> <java.util.concurrent.atomic.AtomicReference: java.lang.Object get()> via result = virtualinvoke $stack5.<java.util.concurrent.atomic.AtomicReference: java.lang.Object get()>();,[public ],[public ; abstract ],Returns the object managed by this initializer. The object is created if\nit is not available yet and stored internally. This method always returns\nthe same object.\n\n@return the object created by this {@code AtomicInitializer}\n@throws ConcurrentException if an error occurred during initialization of\nthe object\n,{\n    T result = reference.get();\n    if (result == null) {\n        result = initialize();\n        if (!reference.compareAndSet(null; result)) {\n            // another thread has initialized the reference\n            result = reference.get();\n        }\n    }\n    return result;\n},[import java.util.concurrent.atomic.AtomicReference;\n],<p>\nA specialized implementation of the {@code ConcurrentInitializer} interface\nbased on an {@link AtomicReference} variable.\n</p>\n<p>\nThis class maintains a member field of type {@code AtomicReference}. It\nimplements the following algorithm to create and initialize an object in its\n{@link #get()} method:\n<ul>\n<li>First it is checked whether the {@code AtomicReference} variable contains\nalready a value. If this is the case; the value is directly returned.</li>\n<li>Otherwise the {@link #initialize()} method is called. This method must be\ndefined in concrete subclasses to actually create the managed object.</li>\n<li>After the object was created by {@link #initialize()} it is checked\nwhether the {@code AtomicReference} variable is still undefined. This has to\nbe done because in the meantime another thread may have initialized the\nobject. If the reference is still empty; the newly created object is stored\nin it and returned by this method.</li>\n<li>Otherwise the value stored in the {@code AtomicReference} is returned.</li>\n</ul>\n</p>\n<p>\nBecause atomic variables are used this class does not need any\nsynchronization. So there is no danger of deadlock; and access to the managed\nobject is efficient. However; if multiple threads access the {@code\nAtomicInitializer} object before it has been initialized almost at the same\ntime; it can happen that {@link #initialize()} is called multiple times. The\nalgorithm outlined above guarantees that {@link #get()} always returns the\nsame object though.\n</p>\n<p>\nCompared with the {@link LazyInitializer} class; this class can be more\nefficient because it does not need synchronization. The drawback is that the\n{@link #initialize()} method can be called multiple times which may be\nproblematic if the creation of the managed object is expensive. As a rule of\nthumb this initializer implementation is preferable if there are not too many\nthreads involved and the probability that multiple threads access an\nuninitialized object is small. If there is high parallelism;\n{@link LazyInitializer} is more appropriate.\n</p>\n\n@since 3.0\n@version $Id$\n@param <T> the type of the object managed by this initializer class\n,/**\n * Holds the reference to the managed object.\n */\nprivate final AtomicReference<T> reference = new AtomicReference<T>();\n\n,"```java
package org.apache.commons.lang3.concurrent;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.concurrent.atomic.AtomicReference;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicInitializer_get__Test {

    // Concrete subclass for testing, with controllable initialize() behavior
    private static class TestAtomicInitializer<T> extends AtomicInitializer<T> {
        private final T valueToReturn;
        private boolean throwException;
        private int initializeCallCount = 0;

        public TestAtomicInitializer(T valueToReturn) {
            this.valueToReturn = valueToReturn;
        }

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }

        public int getInitializeCallCount() {
            return initializeCallCount;
        }

        @Override
        protected T initialize() throws ConcurrentException {
            initializeCallCount++;
            if (throwException) {
                throw new ConcurrentException(""Initialization failed"");
            }
            return valueToReturn;
        }
    }

    // Helper to set the private reference field via reflection
    private static <T> void setReference(AtomicInitializer<T> initializer, AtomicReference<T> ref) throws Exception {
        Field f = AtomicInitializer.class.getDeclaredField(""reference"");
        f.setAccessible(true);
        f.set(initializer, ref);
    }

    // Helper to get the private reference field via reflection
    private static <T> AtomicReference<T> getReference(AtomicInitializer<T> initializer) throws Exception {
        Field f = AtomicInitializer.class.getDeclaredField(""reference"");
        f.setAccessible(true);
        @SuppressWarnings(""unchecked"")
        AtomicReference<T> ref = (AtomicReference<T>) f.get(initializer);
        return ref;
    }

    @Test
    public void testGet_ReturnsExistingReference() throws Exception {
        // reference.get() != null path
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""shouldNotBeUsed"");
        AtomicReference<String> ref = new AtomicReference<>(""existingValue"");
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""existingValue"", result);
        assertEquals(0, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializesAndSetsReference() throws Exception {
        // reference.get() == null, compareAndSet succeeds
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""newValue"");
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""newValue"", result);
        assertEquals(""newValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializesButCompareAndSetFails() throws Exception {
        // reference.get() == null, compareAndSet fails (simulating race)
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""firstValue"");
        AtomicReference<String> ref = new AtomicReference<>(null) {
            private boolean first = true;
            @Override
            public boolean compareAndSet(Object expect, Object update) {
                // Simulate another thread already set the value
                if (first) {
                    first = false;
                    super.set(""otherThreadValue"");
                    return false;
                }
                return super.compareAndSet(expect, update);
            }
        };
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""otherThreadValue"", result);
        assertEquals(""otherThreadValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializeThrowsException() throws Exception {
        // initialize() throws ConcurrentException
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        initializer.setThrowException(true);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        try {
            initializer.get();
            fail(""Expected ConcurrentException"");
        } catch (ConcurrentException ex) {
            assertEquals(""Initialization failed"", ex.getMessage());
        }
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_MultipleCallsReturnSameInstance() throws Exception {
        // get() always returns the same object after initialization
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""singleton"");
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String first = (String) initializer.get();
        String second = (String) initializer.get();
        assertSame(first, second);
        assertEquals(""singleton"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_NullValueAllowed() throws Exception {
        // initialize() returns null, reference should store null
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertNull(result);
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_ConcurrentInitialization() throws Exception {
        // Simulate concurrent get() calls, initialize() may be called multiple times but only one value is stored
        final int threadCount = 10;
        final AtomicInteger initCount = new AtomicInteger(0);
        final String value = ""concurrentValue"";
        final TestAtomicInitializer<String> initializer = new TestAtomicInitializer<String>(value) {
            @Override
            protected String initialize() throws ConcurrentException {
                try {
                    Thread.sleep(10); // Encourage race
                } catch (InterruptedException ignored) {}
                initCount.incrementAndGet();
                return value;
            }
        };
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        final String[] results = new String[threadCount];
        final Exception[] exceptions = new Exception[threadCount];
        final CountDownLatch startLatch = new CountDownLatch(1);
        Thread[] threads = new Thread[threadCount];
        for (int i = 0; i < threadCount; ++i) {
            final int idx = i;
            threads[i] = new Thread(() -> {
                try {
                    startLatch.await();
                    results[idx] = (String) initializer.get();
                } catch (Exception e) {
                    exceptions[idx] = e;
                }
            });
            threads[i].start();
        }
        startLatch.countDown();
        for (Thread t : threads) {
            t.join();
        }
        for (Exception e : exceptions) {
            if (e != null) throw e;
        }
        for (String r : results) {
            assertEquals(value, r);
        }
        assertEquals(value, ref.get());
        assertTrue(""initialize() should be called at least once"", initCount.get() >= 1);
        assertTrue(""initialize() should not be called more than threadCount times"", initCount.get() <= threadCount);
    }

    @Test
    public void testGet_ReferenceAlreadySetToNull() throws Exception {
        // reference.get() returns null, initialize() returns null, compareAndSet(null, null) should succeed
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertNull(result);
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_ReferenceAlreadySetToNonNullAfterInitializeReturnsNull() throws Exception {
        // reference.get() returns null, initialize() returns null, but compareAndSet fails because another thread set a value
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null) {
            private boolean first = true;
            @Override
            public boolean compareAndSet(Object expect, Object update) {
                if (first) {
                    first = false;
                    super.set(""otherValue"");
                    return false;
                }
                return super.compareAndSet(expect, update);
            }
        };
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""otherValue"", result);
        assertEquals(""otherValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }
}
```","package org.apache.commons.lang3.concurrent;

import org.junit.Test;
import static org.junit.Assert.*;
import java.util.concurrent.atomic.AtomicReference;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicInitializer_get__Test {

    // Concrete subclass for testing, with controllable initialize() behavior
    private static class TestAtomicInitializer<T> extends AtomicInitializer<T> {
        private final T valueToReturn;
        private boolean throwException;
        private int initializeCallCount = 0;

        public TestAtomicInitializer(T valueToReturn) {
            this.valueToReturn = valueToReturn;
        }

        public void setThrowException(boolean throwException) {
            this.throwException = throwException;
        }

        public int getInitializeCallCount() {
            return initializeCallCount;
        }

        @Override
        protected T initialize() throws ConcurrentException {
            initializeCallCount++;
            if (throwException) {
                throw new ConcurrentException(""Initialization failed"");
            }
            return valueToReturn;
        }
    }

    // Helper to set the private reference field via reflection
    private static <T> void setReference(AtomicInitializer<T> initializer, AtomicReference<T> ref) throws Exception {
        Field f = AtomicInitializer.class.getDeclaredField(""reference"");
        f.setAccessible(true);
        f.set(initializer, ref);
    }

    // Helper to get the private reference field via reflection
    private static <T> AtomicReference<T> getReference(AtomicInitializer<T> initializer) throws Exception {
        Field f = AtomicInitializer.class.getDeclaredField(""reference"");
        f.setAccessible(true);
        @SuppressWarnings(""unchecked"")
        AtomicReference<T> ref = (AtomicReference<T>) f.get(initializer);
        return ref;
    }

    @Test
    public void testGet_ReturnsExistingReference() throws Exception {
        // reference.get() != null path
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""shouldNotBeUsed"");
        AtomicReference<String> ref = new AtomicReference<>(""existingValue"");
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""existingValue"", result);
        assertEquals(0, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializesAndSetsReference() throws Exception {
        // reference.get() == null, compareAndSet succeeds
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""newValue"");
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""newValue"", result);
        assertEquals(""newValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializesButCompareAndSetFails() throws Exception {
        // reference.get() == null, compareAndSet fails (simulating race)
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""firstValue"");
        AtomicReference<String> ref = new AtomicReference<>(null) {
            private boolean first = true;
            @Override
            public boolean compareAndSet(Object expect, Object update) {
                // Simulate another thread already set the value
                if (first) {
                    first = false;
                    super.set(""otherThreadValue"");
                    return false;
                }
                return super.compareAndSet(expect, update);
            }
        };
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""otherThreadValue"", result);
        assertEquals(""otherThreadValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_InitializeThrowsException() throws Exception {
        // initialize() throws ConcurrentException
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        initializer.setThrowException(true);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        try {
            initializer.get();
            fail(""Expected ConcurrentException"");
        } catch (ConcurrentException ex) {
            assertEquals(""Initialization failed"", ex.getMessage());
        }
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_MultipleCallsReturnSameInstance() throws Exception {
        // get() always returns the same object after initialization
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(""singleton"");
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String first = (String) initializer.get();
        String second = (String) initializer.get();
        assertSame(first, second);
        assertEquals(""singleton"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_NullValueAllowed() throws Exception {
        // initialize() returns null, reference should store null
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertNull(result);
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_ConcurrentInitialization() throws Exception {
        // Simulate concurrent get() calls, initialize() may be called multiple times but only one value is stored
        final int threadCount = 10;
        final AtomicInteger initCount = new AtomicInteger(0);
        final String value = ""concurrentValue"";
        final TestAtomicInitializer<String> initializer = new TestAtomicInitializer<String>(value) {
            @Override
            protected String initialize() throws ConcurrentException {
                try {
                    Thread.sleep(10); // Encourage race
                } catch (InterruptedException ignored) {}
                initCount.incrementAndGet();
                return value;
            }
        };
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        final String[] results = new String[threadCount];
        final Exception[] exceptions = new Exception[threadCount];
        final CountDownLatch startLatch = new CountDownLatch(1);
        Thread[] threads = new Thread[threadCount];
        for (int i = 0; i < threadCount; ++i) {
            final int idx = i;
            threads[i] = new Thread(() -> {
                try {
                    startLatch.await();
                    results[idx] = (String) initializer.get();
                } catch (Exception e) {
                    exceptions[idx] = e;
                }
            });
            threads[i].start();
        }
        startLatch.countDown();
        for (Thread t : threads) {
            t.join();
        }
        for (Exception e : exceptions) {
            if (e != null) throw e;
        }
        for (String r : results) {
            assertEquals(value, r);
        }
        assertEquals(value, ref.get());
        assertTrue(""initialize() should be called at least once"", initCount.get() >= 1);
        assertTrue(""initialize() should not be called more than threadCount times"", initCount.get() <= threadCount);
    }

    @Test
    public void testGet_ReferenceAlreadySetToNull() throws Exception {
        // reference.get() returns null, initialize() returns null, compareAndSet(null, null) should succeed
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null);
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertNull(result);
        assertNull(ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }

    @Test
    public void testGet_ReferenceAlreadySetToNonNullAfterInitializeReturnsNull() throws Exception {
        // reference.get() returns null, initialize() returns null, but compareAndSet fails because another thread set a value
        TestAtomicInitializer<String> initializer = new TestAtomicInitializer<>(null);
        AtomicReference<String> ref = new AtomicReference<>(null) {
            private boolean first = true;
            @Override
            public boolean compareAndSet(Object expect, Object update) {
                if (first) {
                    first = false;
                    super.set(""otherValue"");
                    return false;
                }
                return super.compareAndSet(expect, update);
            }
        };
        setReference(initializer, ref);

        String result = (String) initializer.get();
        assertEquals(""otherValue"", result);
        assertEquals(""otherValue"", ref.get());
        assertEquals(1, initializer.getInitializeCallCount());
    }
}
",src/test/java/org/apache/commons/lang3/concurrent/AtomicInitializer_get__Test.java
"org.apache.commons.lang3.text.translate.CodePointTranslator.translate(java.lang.CharSequence, int, java.io.Writer)","int translate(java.lang.CharSequence,int,java.io.Writer)",{\n    int index;\n    java.io.Writer out;\n    java.lang.CharSequence input;\n    org.apache.commons.lang3.text.translate.CodePointTranslator this;\n    unknown codepoint; consumed;\n\n\n    this := @this: org.apache.commons.lang3.text.translate.CodePointTranslator;\n    input := @parameter0: java.lang.CharSequence;\n    index := @parameter1: int;\n    out := @parameter2: java.io.Writer;\n    codepoint = staticinvoke <java.lang.Character: int codePointAt(java.lang.CharSequence;int)>(input; index);\n    consumed = virtualinvoke this.<org.apache.commons.lang3.text.translate.CodePointTranslator: boolean translate(int;java.io.Writer)>(codepoint; out);\n\n    if consumed == 0 goto label1;\n\n    return 1;\n\n  label1:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.text.translate.CodePointTranslator: int translate(java.lang.CharSequence;int;java.io.Writer)> -> <java.lang.Character: int codePointAt(java.lang.CharSequence;int)> via codepoint = staticinvoke <java.lang.Character: int codePointAt(java.lang.CharSequence;int)>(input; index);,[public ; final ],[public ; abstract ],Implementation of translate that maps onto the abstract translate(int; Writer) method. \n{@inheritDoc}\n,{\n    final int codepoint = Character.codePointAt(input; index);\n    final boolean consumed = translate(codepoint; out);\n    if (consumed) {\n        return 1;\n    } else {\n        return 0;\n    }\n},[import java.io.IOException;\n; import java.io.Writer;\n],Helper subclass to CharSequenceTranslator to allow for translations that \nwill replace up to one character at a time.\n\n@since 3.0\n@version $Id$\n,,"```java
package org.apache.commons.lang3.text.translate;

import java.io.IOException;
import java.io.Writer;
import org.junit.Test;
import static org.junit.Assert.*;

public class CodePointTranslator_translate_CharSequence_int_Writer_Test {

    private static class TestCodePointTranslator extends CodePointTranslator {
        private boolean translateReturnValue;
        private int lastCodePoint;
        private Writer lastWriter;

        public TestCodePointTranslator(boolean translateReturnValue) {
            this.translateReturnValue = translateReturnValue;
        }

        @Override
        public boolean translate(int codePoint, Writer out) throws IOException {
            this.lastCodePoint = codePoint;
            this.lastWriter = out;
            return translateReturnValue;
        }
    }

    @Test
    public void testTranslate_ConsumedTrue_SimpleAscii() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = 1;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'b', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedFalse_SimpleAscii() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = ""abc"";
        int index = 2;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(0, result);
        assertEquals((int) 'c', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedTrue_UnicodeSupplementary() throws IOException {
        // U+1F600 GRINNING FACE (requires surrogate pair)
        String smiley = new String(Character.toChars(0x1F600));
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""a"" + smiley + ""b"";
        int index = 1; // index of the supplementary character
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals(0x1F600, translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedFalse_UnicodeSupplementary() throws IOException {
        // U+1F601 GRINNING FACE WITH SMILING EYES
        String smiley = new String(Character.toChars(0x1F601));
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = smiley + ""x"";
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(0, result);
        assertEquals(0x1F601, translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_EmptyInput() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = """";
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_IndexAtEnd() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = ""abc"";
        int index = 3; // out of bounds
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_NullInput() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = null;
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected NullPointerException"");
        } catch (NullPointerException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_NullWriter() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = 0;
        Writer writer = null;

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'a', translator.lastCodePoint);
        assertNull(translator.lastWriter);
    }

    @Test
    public void testTranslate_NegativeIndex() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = -1;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_LargeInput_LongString() throws IOException {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append('x');
        }
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = sb.toString();
        int index = 9999;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'x', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    // Helper Writer implementation for capturing output
    private static class StringBuilderWriter extends Writer {
        private final StringBuilder sb = new StringBuilder();

        @Override
        public void write(char[] cbuf, int off, int len) {
            sb.append(cbuf, off, len);
        }

        @Override
        public void write(int c) {
            sb.append((char) c);
        }

        @Override
        public void write(String str) {
            sb.append(str);
        }

        @Override
        public void write(String str, int off, int len) {
            sb.append(str, off, off + len);
        }

        @Override
        public void flush() {}

        @Override
        public void close() {}

        @Override
        public String toString() {
            return sb.toString();
        }
    }
}
```","package org.apache.commons.lang3.text.translate;

import java.io.IOException;
import java.io.Writer;
import org.junit.Test;
import static org.junit.Assert.*;

public class CodePointTranslator_translate_CharSequence_int_Writer_Test {

    private static class TestCodePointTranslator extends CodePointTranslator {
        private boolean translateReturnValue;
        private int lastCodePoint;
        private Writer lastWriter;

        public TestCodePointTranslator(boolean translateReturnValue) {
            this.translateReturnValue = translateReturnValue;
        }

        @Override
        public boolean translate(int codePoint, Writer out) throws IOException {
            this.lastCodePoint = codePoint;
            this.lastWriter = out;
            return translateReturnValue;
        }
    }

    @Test
    public void testTranslate_ConsumedTrue_SimpleAscii() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = 1;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'b', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedFalse_SimpleAscii() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = ""abc"";
        int index = 2;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(0, result);
        assertEquals((int) 'c', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedTrue_UnicodeSupplementary() throws IOException {
        // U+1F600 GRINNING FACE (requires surrogate pair)
        String smiley = new String(Character.toChars(0x1F600));
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""a"" + smiley + ""b"";
        int index = 1; // index of the supplementary character
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals(0x1F600, translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_ConsumedFalse_UnicodeSupplementary() throws IOException {
        // U+1F601 GRINNING FACE WITH SMILING EYES
        String smiley = new String(Character.toChars(0x1F601));
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = smiley + ""x"";
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(0, result);
        assertEquals(0x1F601, translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    @Test
    public void testTranslate_EmptyInput() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = """";
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_IndexAtEnd() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = ""abc"";
        int index = 3; // out of bounds
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_NullInput() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(false);
        CharSequence input = null;
        int index = 0;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected NullPointerException"");
        } catch (NullPointerException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_NullWriter() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = 0;
        Writer writer = null;

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'a', translator.lastCodePoint);
        assertNull(translator.lastWriter);
    }

    @Test
    public void testTranslate_NegativeIndex() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = ""abc"";
        int index = -1;
        StringBuilderWriter writer = new StringBuilderWriter();

        try {
            translator.translate(input, index, writer);
            fail(""Expected IndexOutOfBoundsException"");
        } catch (IndexOutOfBoundsException ex) {
            // expected
        }
    }

    @Test
    public void testTranslate_LargeInput_LongString() throws IOException {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append('x');
        }
        TestCodePointTranslator translator = new TestCodePointTranslator(true);
        CharSequence input = sb.toString();
        int index = 9999;
        StringBuilderWriter writer = new StringBuilderWriter();

        int result = translator.translate(input, index, writer);

        assertEquals(1, result);
        assertEquals((int) 'x', translator.lastCodePoint);
        assertSame(writer, translator.lastWriter);
    }

    // Helper Writer implementation for capturing output
    private static class StringBuilderWriter extends Writer {
        private final StringBuilder sb = new StringBuilder();

        @Override
        public void write(char[] cbuf, int off, int len) {
            sb.append(cbuf, off, len);
        }

        @Override
        public void write(int c) {
            sb.append((char) c);
        }

        @Override
        public void write(String str) {
            sb.append(str);
        }

        @Override
        public void write(String str, int off, int len) {
            sb.append(str, off, off + len);
        }

        @Override
        public void flush() {}

        @Override
        public void close() {}

        @Override
        public String toString() {
            return sb.toString();
        }
    }
}
",src/test/java/org/apache/commons/lang3/text/translate/CodePointTranslator_translate_CharSequence_int_Writer_Test.java
"org.apache.commons.lang3.text.translate.CodePointTranslator.translate(int, java.io.Writer)","boolean translate(int,java.io.Writer)",,,[public ; abstract ],[public ; abstract ],Translate the specified codepoint into another.\n\n@param codepoint int character input to translate\n@param out Writer to optionally push the translated output to\n@return boolean as to whether translation occurred or not\n@throws IOException if and only if the Writer produces an IOException\n,,[import java.io.IOException;\n; import java.io.Writer;\n],Helper subclass to CharSequenceTranslator to allow for translations that \nwill replace up to one character at a time.\n\n@since 3.0\n@version $Id$\n,,"```java
package org.apache.commons.lang3.text.translate;

import java.io.IOException;
import java.io.Writer;
import org.junit.Test;
import static org.junit.Assert.*;

public class CodePointTranslator_translate_int_Writer_Test {

    /**
     * Concrete implementation of CodePointTranslator for testing.
     * Translates codepoints: if codepoint is 'A' (65), writes 'B' (66) and returns true.
     * Otherwise, returns false.
     * Throws IOException if codepoint is -1.
     */
    private static class TestCodePointTranslator extends CodePointTranslator {
        @Override
        public boolean translate(int codepoint, Writer out) throws IOException {
            if (codepoint == -1) {
                throw new IOException(""Invalid codepoint"");
            }
            if (codepoint == 65) { // 'A'
                out.write(66); // 'B'
                return true;
            }
            return false;
        }
    }

    /**
     * Simple Writer implementation that captures written characters.
     */
    private static class StringBuilderWriter extends Writer {
        private final StringBuilder sb = new StringBuilder();
        private boolean closed = false;

        @Override
        public void write(int c) throws IOException {
            if (closed) throw new IOException(""Writer closed"");
            sb.append((char) c);
        }

        @Override
        public void write(char[] cbuf, int off, int len) throws IOException {
            if (closed) throw new IOException(""Writer closed"");
            sb.append(cbuf, off, len);
        }

        @Override
        public void flush() throws IOException {
            if (closed) throw new IOException(""Writer closed"");
        }

        @Override
        public void close() throws IOException {
            closed = true;
        }

        @Override
        public String toString() {
            return sb.toString();
        }
    }

    @Test
    public void testTranslate_TranslatesAtoB_ReturnsTrueAndWritesB() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        boolean result = translator.translate(65, writer); // 'A'
        assertTrue(result);
        assertEquals(""B"", writer.toString());
    }

    @Test
    public void testTranslate_DoesNotTranslateOtherCodepoint_ReturnsFalseAndWritesNothing() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        boolean result = translator.translate(67, writer); // 'C'
        assertFalse(result);
        assertEquals("""", writer.toString());
    }

    @Test
    public void testTranslate_NegativeCodepoint_ThrowsIOException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        try {
            translator.translate(-1, writer);
            fail(""Expected IOException for codepoint -1"");
        } catch (IOException e) {
            assertEquals(""Invalid codepoint"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_NullWriter_ThrowsNullPointerException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        try {
            translator.translate(65, null);
            fail(""Expected NullPointerException for null Writer"");
        } catch (NullPointerException e) {
            // expected
        } catch (IOException e) {
            fail(""Did not expect IOException here"");
        }
    }

    @Test
    public void testTranslate_WriterThrowsIOException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        Writer writer = new Writer() {
            @Override
            public void write(int c) throws IOException {
                throw new IOException(""Writer error"");
            }
            @Override
            public void write(char[] cbuf, int off, int len) throws IOException {
                throw new IOException(""Writer error"");
            }
            @Override
            public void flush() throws IOException {}
            @Override
            public void close() throws IOException {}
        };
        try {
            translator.translate(65, writer);
            fail(""Expected IOException from Writer"");
        } catch (IOException e) {
            assertEquals(""Writer error"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_WriterClosed_ThrowsIOException() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        writer.close();
        try {
            translator.translate(65, writer);
            fail(""Expected IOException for closed Writer"");
        } catch (IOException e) {
            assertEquals(""Writer closed"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_BoundaryCodepoints() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        // Minimum valid Unicode codepoint
        boolean resultMin = translator.translate(0, writer);
        assertFalse(resultMin);
        // Maximum valid Unicode codepoint
        boolean resultMax = translator.translate(0x10FFFF, writer);
        assertFalse(resultMax);
        assertEquals("""", writer.toString());
    }

    @Test
    public void testTranslate_SupplementaryCodepoint() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        // Supplementary character (e.g., 0x1F600, 😀)
        boolean result = translator.translate(0x1F600, writer);
        assertFalse(result);
        assertEquals("""", writer.toString());
    }
}
```","package org.apache.commons.lang3.text.translate;

import java.io.IOException;
import java.io.Writer;
import org.junit.Test;
import static org.junit.Assert.*;

public class CodePointTranslator_translate_int_Writer_Test {

    /**
     * Concrete implementation of CodePointTranslator for testing.
     * Translates codepoints: if codepoint is 'A' (65), writes 'B' (66) and returns true.
     * Otherwise, returns false.
     * Throws IOException if codepoint is -1.
     */
    private static class TestCodePointTranslator extends CodePointTranslator {
        @Override
        public boolean translate(int codepoint, Writer out) throws IOException {
            if (codepoint == -1) {
                throw new IOException(""Invalid codepoint"");
            }
            if (codepoint == 65) { // 'A'
                out.write(66); // 'B'
                return true;
            }
            return false;
        }
    }

    /**
     * Simple Writer implementation that captures written characters.
     */
    private static class StringBuilderWriter extends Writer {
        private final StringBuilder sb = new StringBuilder();
        private boolean closed = false;

        @Override
        public void write(int c) throws IOException {
            if (closed) throw new IOException(""Writer closed"");
            sb.append((char) c);
        }

        @Override
        public void write(char[] cbuf, int off, int len) throws IOException {
            if (closed) throw new IOException(""Writer closed"");
            sb.append(cbuf, off, len);
        }

        @Override
        public void flush() throws IOException {
            if (closed) throw new IOException(""Writer closed"");
        }

        @Override
        public void close() throws IOException {
            closed = true;
        }

        @Override
        public String toString() {
            return sb.toString();
        }
    }

    @Test
    public void testTranslate_TranslatesAtoB_ReturnsTrueAndWritesB() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        boolean result = translator.translate(65, writer); // 'A'
        assertTrue(result);
        assertEquals(""B"", writer.toString());
    }

    @Test
    public void testTranslate_DoesNotTranslateOtherCodepoint_ReturnsFalseAndWritesNothing() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        boolean result = translator.translate(67, writer); // 'C'
        assertFalse(result);
        assertEquals("""", writer.toString());
    }

    @Test
    public void testTranslate_NegativeCodepoint_ThrowsIOException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        try {
            translator.translate(-1, writer);
            fail(""Expected IOException for codepoint -1"");
        } catch (IOException e) {
            assertEquals(""Invalid codepoint"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_NullWriter_ThrowsNullPointerException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        try {
            translator.translate(65, null);
            fail(""Expected NullPointerException for null Writer"");
        } catch (NullPointerException e) {
            // expected
        } catch (IOException e) {
            fail(""Did not expect IOException here"");
        }
    }

    @Test
    public void testTranslate_WriterThrowsIOException() {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        Writer writer = new Writer() {
            @Override
            public void write(int c) throws IOException {
                throw new IOException(""Writer error"");
            }
            @Override
            public void write(char[] cbuf, int off, int len) throws IOException {
                throw new IOException(""Writer error"");
            }
            @Override
            public void flush() throws IOException {}
            @Override
            public void close() throws IOException {}
        };
        try {
            translator.translate(65, writer);
            fail(""Expected IOException from Writer"");
        } catch (IOException e) {
            assertEquals(""Writer error"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_WriterClosed_ThrowsIOException() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        writer.close();
        try {
            translator.translate(65, writer);
            fail(""Expected IOException for closed Writer"");
        } catch (IOException e) {
            assertEquals(""Writer closed"", e.getMessage());
        }
    }

    @Test
    public void testTranslate_BoundaryCodepoints() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        // Minimum valid Unicode codepoint
        boolean resultMin = translator.translate(0, writer);
        assertFalse(resultMin);
        // Maximum valid Unicode codepoint
        boolean resultMax = translator.translate(0x10FFFF, writer);
        assertFalse(resultMax);
        assertEquals("""", writer.toString());
    }

    @Test
    public void testTranslate_SupplementaryCodepoint() throws IOException {
        TestCodePointTranslator translator = new TestCodePointTranslator();
        StringBuilderWriter writer = new StringBuilderWriter();
        // Supplementary character (e.g., 0x1F600, 😀)
        boolean result = translator.translate(0x1F600, writer);
        assertFalse(result);
        assertEquals("""", writer.toString());
    }
}
",src/test/java/org/apache/commons/lang3/text/translate/CodePointTranslator_translate_int_Writer_Test.java
"org.apache.commons.lang3.text.WordUtils.isDelimiter(char, char[])","boolean isDelimiter(char,char[])",{\n    char ch;\n    char[] delimiters;\n    unknown $stack6; delimiter; l2; l3; l4;\n\n\n    ch := @parameter0: char;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    $stack6 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\n\n    return $stack6;\n\n  label1:\n    l2 = delimiters;\n    l3 = lengthof l2;\n    l4 = 0;\n\n  label2:\n    if l4 >= l3 goto label4;\n    delimiter = l2[l4];\n\n    if ch != delimiter goto label3;\n\n    return 1;\n\n  label3:\n    l4 = l4 + 1;\n\n    goto label2;\n\n  label4:\n    return 0;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> -> <java.lang.Character: boolean isWhitespace(char)> via $stack6 = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);,[private ; static ],[public ],Is the character a delimiter.\n\n@param ch the character to check\n@param delimiters the delimiters\n@return true if it is a delimiter\n,{\n    if (delimiters == null) {\n        return Character.isWhitespace(ch);\n    }\n    for (final char delimiter : delimiters) {\n        if (ch == delimiter) {\n            return true;\n        }\n    }\n    return false;\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;

public class WordUtils_isDelimiter_char_charArray_Test {

    /**
     * Helper to invoke the private static isDelimiter method via reflection.
     */
    private boolean invokeIsDelimiter(char ch, char[] delimiters) throws Exception {
        Method m = WordUtils.class.getDeclaredMethod(""isDelimiter"", char.class, char[].class);
        m.setAccessible(true);
        return (Boolean) m.invoke(null, ch, delimiters);
    }

    @Test
    public void testIsDelimiter_NullDelimiters_WhitespaceChar() throws Exception {
        // delimiters == null, ch is whitespace
        char ch = ' ';
        char[] delimiters = null;
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_NullDelimiters_NonWhitespaceChar() throws Exception {
        // delimiters == null, ch is not whitespace
        char ch = 'a';
        char[] delimiters = null;
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_EmptyDelimiters() throws Exception {
        // delimiters is empty array
        char ch = 'a';
        char[] delimiters = new char[0];
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_SingleDelimiter_Match() throws Exception {
        // delimiters contains ch
        char ch = ',';
        char[] delimiters = {','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_SingleDelimiter_NoMatch() throws Exception {
        // delimiters does not contain ch
        char ch = '.';
        char[] delimiters = {','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchFirst() throws Exception {
        // delimiters contains ch as first element
        char ch = ';';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchMiddle() throws Exception {
        // delimiters contains ch as middle element
        char ch = ',';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchLast() throws Exception {
        // delimiters contains ch as last element
        char ch = '.';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_NoMatch() throws Exception {
        // delimiters does not contain ch
        char ch = 'x';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithWhitespace_MatchWhitespace() throws Exception {
        // delimiters contains whitespace character
        char ch = ' ';
        char[] delimiters = {';', ' ', ','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithUnicode_Match() throws Exception {
        // delimiters contains a unicode character
        char ch = '\u2603'; // Unicode snowman
        char[] delimiters = {'a', '\u2603', 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithUnicode_NoMatch() throws Exception {
        // delimiters does not contain ch, ch is unicode
        char ch = '\u2603'; // Unicode snowman
        char[] delimiters = {'a', 'b', 'c'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithNullChar() throws Exception {
        // delimiters contains null char
        char ch = '\0';
        char[] delimiters = {'\0', 'a', 'b'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithMaxChar() throws Exception {
        // delimiters contains Character.MAX_VALUE
        char ch = Character.MAX_VALUE;
        char[] delimiters = {'a', Character.MAX_VALUE, 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithMinChar() throws Exception {
        // delimiters contains Character.MIN_VALUE
        char ch = Character.MIN_VALUE;
        char[] delimiters = {Character.MIN_VALUE, 'b', 'c'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithLargeArray_NoMatch() throws Exception {
        // delimiters is a large array, ch not present
        char ch = 'x';
        char[] delimiters = new char[1000];
        for (int i = 0; i < delimiters.length; i++) {
            delimiters[i] = (char) (i % 128);
        }
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithLargeArray_Match() throws Exception {
        // delimiters is a large array, ch present at end
        char ch = 'x';
        char[] delimiters = new char[1000];
        for (int i = 0; i < delimiters.length - 1; i++) {
            delimiters[i] = (char) (i % 128);
        }
        delimiters[999] = 'x';
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithNegativeCharValue() throws Exception {
        // char is unsigned, but test with casted negative value
        char ch = (char) -1;
        char[] delimiters = {(char) -1, 'a', 'b'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithSurrogatePair() throws Exception {
        // test with a surrogate pair character
        char ch = '\uD800'; // High surrogate
        char[] delimiters = {'a', '\uD800', 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;
import java.lang.reflect.Method;

public class WordUtils_isDelimiter_char_charArray_Test {

    /**
     * Helper to invoke the private static isDelimiter method via reflection.
     */
    private boolean invokeIsDelimiter(char ch, char[] delimiters) throws Exception {
        Method m = WordUtils.class.getDeclaredMethod(""isDelimiter"", char.class, char[].class);
        m.setAccessible(true);
        return (Boolean) m.invoke(null, ch, delimiters);
    }

    @Test
    public void testIsDelimiter_NullDelimiters_WhitespaceChar() throws Exception {
        // delimiters == null, ch is whitespace
        char ch = ' ';
        char[] delimiters = null;
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_NullDelimiters_NonWhitespaceChar() throws Exception {
        // delimiters == null, ch is not whitespace
        char ch = 'a';
        char[] delimiters = null;
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_EmptyDelimiters() throws Exception {
        // delimiters is empty array
        char ch = 'a';
        char[] delimiters = new char[0];
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_SingleDelimiter_Match() throws Exception {
        // delimiters contains ch
        char ch = ',';
        char[] delimiters = {','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_SingleDelimiter_NoMatch() throws Exception {
        // delimiters does not contain ch
        char ch = '.';
        char[] delimiters = {','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchFirst() throws Exception {
        // delimiters contains ch as first element
        char ch = ';';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchMiddle() throws Exception {
        // delimiters contains ch as middle element
        char ch = ',';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_MatchLast() throws Exception {
        // delimiters contains ch as last element
        char ch = '.';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_MultipleDelimiters_NoMatch() throws Exception {
        // delimiters does not contain ch
        char ch = 'x';
        char[] delimiters = {';', ',', '.'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithWhitespace_MatchWhitespace() throws Exception {
        // delimiters contains whitespace character
        char ch = ' ';
        char[] delimiters = {';', ' ', ','};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithUnicode_Match() throws Exception {
        // delimiters contains a unicode character
        char ch = '\u2603'; // Unicode snowman
        char[] delimiters = {'a', '\u2603', 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithUnicode_NoMatch() throws Exception {
        // delimiters does not contain ch, ch is unicode
        char ch = '\u2603'; // Unicode snowman
        char[] delimiters = {'a', 'b', 'c'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithNullChar() throws Exception {
        // delimiters contains null char
        char ch = '\0';
        char[] delimiters = {'\0', 'a', 'b'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithMaxChar() throws Exception {
        // delimiters contains Character.MAX_VALUE
        char ch = Character.MAX_VALUE;
        char[] delimiters = {'a', Character.MAX_VALUE, 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithMinChar() throws Exception {
        // delimiters contains Character.MIN_VALUE
        char ch = Character.MIN_VALUE;
        char[] delimiters = {Character.MIN_VALUE, 'b', 'c'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithLargeArray_NoMatch() throws Exception {
        // delimiters is a large array, ch not present
        char ch = 'x';
        char[] delimiters = new char[1000];
        for (int i = 0; i < delimiters.length; i++) {
            delimiters[i] = (char) (i % 128);
        }
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertFalse(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithLargeArray_Match() throws Exception {
        // delimiters is a large array, ch present at end
        char ch = 'x';
        char[] delimiters = new char[1000];
        for (int i = 0; i < delimiters.length - 1; i++) {
            delimiters[i] = (char) (i % 128);
        }
        delimiters[999] = 'x';
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithNegativeCharValue() throws Exception {
        // char is unsigned, but test with casted negative value
        char ch = (char) -1;
        char[] delimiters = {(char) -1, 'a', 'b'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }

    @Test
    public void testIsDelimiter_DelimitersWithSurrogatePair() throws Exception {
        // test with a surrogate pair character
        char ch = '\uD800'; // High surrogate
        char[] delimiters = {'a', '\uD800', 'z'};
        boolean result = invokeIsDelimiter(ch, delimiters);
        assertTrue(result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_isDelimiter_char_charArray_Test.java
org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String),java.lang.String capitalizeFully(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Converts all the whitespace separated words in a String into capitalized words; \nthat is each word is made up of a titlecase character and then a series of \nlowercase characters.  </p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalizeFully(null)        = null\nWordUtils.capitalizeFully("")          = ""\nWordUtils.capitalizeFully(i am FINE"") = ""I Am Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@return capitalized String; <code>null</code> if null String input\n""",{\n    return capitalizeFully(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_capitalizeFully_java_lang_String_Test {

    @Test
    public void testCapitalizeFully_NullInput() {
        assertNull(WordUtils.capitalizeFully((String) null));
    }

    @Test
    public void testCapitalizeFully_EmptyString() {
        assertEquals("""", WordUtils.capitalizeFully(""""));
    }

    @Test
    public void testCapitalizeFully_SingleLowercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""hello""));
    }

    @Test
    public void testCapitalizeFully_SingleUppercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""HELLO""));
    }

    @Test
    public void testCapitalizeFully_SingleMixedCaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""hELLo""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_Lowercase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""hello world""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_Uppercase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""HELLO WORLD""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_MixedCase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""hELLo wORld""));
    }

    @Test
    public void testCapitalizeFully_MultipleSpacesBetweenWords() {
        assertEquals(""Hello   World"", WordUtils.capitalizeFully(""hello   world""));
    }

    @Test
    public void testCapitalizeFully_LeadingAndTrailingSpaces() {
        assertEquals(""  Hello World  "", WordUtils.capitalizeFully(""  hello world  ""));
    }

    @Test
    public void testCapitalizeFully_TabsAndNewlines() {
        assertEquals(""Hello\tWorld\nTest"", WordUtils.capitalizeFully(""hello\tworld\ntest""));
    }

    @Test
    public void testCapitalizeFully_OnlyWhitespace() {
        assertEquals(""   "", WordUtils.capitalizeFully(""   ""));
    }

    @Test
    public void testCapitalizeFully_NonAlphaWords() {
        assertEquals(""123 456"", WordUtils.capitalizeFully(""123 456""));
    }

    @Test
    public void testCapitalizeFully_AlphaNumericWords() {
        assertEquals(""Hello123 World456"", WordUtils.capitalizeFully(""hello123 world456""));
    }

    @Test
    public void testCapitalizeFully_SingleCharacterWords() {
        assertEquals(""A B C"", WordUtils.capitalizeFully(""a b c""));
    }

    @Test
    public void testCapitalizeFully_Punctuation() {
        assertEquals(""Hello, World!"", WordUtils.capitalizeFully(""hello, world!""));
    }

    @Test
    public void testCapitalizeFully_MixedWhitespace() {
        assertEquals(""Hello\tWorld  Foo\nBar"", WordUtils.capitalizeFully(""hello\tworld  foo\nbar""));
    }

    @Test
    public void testCapitalizeFully_UnicodeCharacters() {
        assertEquals(""Éclair Über Café"", WordUtils.capitalizeFully(""éclair ÜBER CAFÉ""));
    }

    @Test
    public void testCapitalizeFully_SingleQuoteWords() {
        assertEquals(""O'connor D'arcy"", WordUtils.capitalizeFully(""o'connor d'arcy""));
    }

    @Test
    public void testCapitalizeFully_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String expected = input.replaceAll(""\\b(\\w)"", m -> m.group(1).toUpperCase());
        String result = WordUtils.capitalizeFully(input);
        assertNotNull(result);
        assertTrue(result.startsWith(""Word Word Word""));
        assertEquals(input.length(), result.length());
    }

    @Test
    public void testCapitalizeFully_AlreadyCapitalized() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""Hello World""));
    }

    @Test
    public void testCapitalizeFully_SingleNonWhitespace() {
        assertEquals(""!"", WordUtils.capitalizeFully(""!""));
    }

    @Test
    public void testCapitalizeFully_MixedWithNumbersAndSymbols() {
        assertEquals(""Hello123! World456?"", WordUtils.capitalizeFully(""hello123! world456?""));
    }

    @Test
    public void testCapitalizeFully_WhitespaceOnlyTabsNewlines() {
        assertEquals(""\t\n"", WordUtils.capitalizeFully(""\t\n""));
    }

    @Test
    public void testCapitalizeFully_ComplexSentence() {
        String input = ""the quick brown fox jumps over the lazy dog."";
        String expected = ""The Quick Brown Fox Jumps Over The Lazy Dog."";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_capitalizeFully_java_lang_String_Test {

    @Test
    public void testCapitalizeFully_NullInput() {
        assertNull(WordUtils.capitalizeFully((String) null));
    }

    @Test
    public void testCapitalizeFully_EmptyString() {
        assertEquals("""", WordUtils.capitalizeFully(""""));
    }

    @Test
    public void testCapitalizeFully_SingleLowercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""hello""));
    }

    @Test
    public void testCapitalizeFully_SingleUppercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""HELLO""));
    }

    @Test
    public void testCapitalizeFully_SingleMixedCaseWord() {
        assertEquals(""Hello"", WordUtils.capitalizeFully(""hELLo""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_Lowercase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""hello world""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_Uppercase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""HELLO WORLD""));
    }

    @Test
    public void testCapitalizeFully_MultipleWords_MixedCase() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""hELLo wORld""));
    }

    @Test
    public void testCapitalizeFully_MultipleSpacesBetweenWords() {
        assertEquals(""Hello   World"", WordUtils.capitalizeFully(""hello   world""));
    }

    @Test
    public void testCapitalizeFully_LeadingAndTrailingSpaces() {
        assertEquals(""  Hello World  "", WordUtils.capitalizeFully(""  hello world  ""));
    }

    @Test
    public void testCapitalizeFully_TabsAndNewlines() {
        assertEquals(""Hello\tWorld\nTest"", WordUtils.capitalizeFully(""hello\tworld\ntest""));
    }

    @Test
    public void testCapitalizeFully_OnlyWhitespace() {
        assertEquals(""   "", WordUtils.capitalizeFully(""   ""));
    }

    @Test
    public void testCapitalizeFully_NonAlphaWords() {
        assertEquals(""123 456"", WordUtils.capitalizeFully(""123 456""));
    }

    @Test
    public void testCapitalizeFully_AlphaNumericWords() {
        assertEquals(""Hello123 World456"", WordUtils.capitalizeFully(""hello123 world456""));
    }

    @Test
    public void testCapitalizeFully_SingleCharacterWords() {
        assertEquals(""A B C"", WordUtils.capitalizeFully(""a b c""));
    }

    @Test
    public void testCapitalizeFully_Punctuation() {
        assertEquals(""Hello, World!"", WordUtils.capitalizeFully(""hello, world!""));
    }

    @Test
    public void testCapitalizeFully_MixedWhitespace() {
        assertEquals(""Hello\tWorld  Foo\nBar"", WordUtils.capitalizeFully(""hello\tworld  foo\nbar""));
    }

    @Test
    public void testCapitalizeFully_UnicodeCharacters() {
        assertEquals(""Éclair Über Café"", WordUtils.capitalizeFully(""éclair ÜBER CAFÉ""));
    }

    @Test
    public void testCapitalizeFully_SingleQuoteWords() {
        assertEquals(""O'connor D'arcy"", WordUtils.capitalizeFully(""o'connor d'arcy""));
    }

    @Test
    public void testCapitalizeFully_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String expected = input.replaceAll(""\\b(\\w)"", m -> m.group(1).toUpperCase());
        String result = WordUtils.capitalizeFully(input);
        assertNotNull(result);
        assertTrue(result.startsWith(""Word Word Word""));
        assertEquals(input.length(), result.length());
    }

    @Test
    public void testCapitalizeFully_AlreadyCapitalized() {
        assertEquals(""Hello World"", WordUtils.capitalizeFully(""Hello World""));
    }

    @Test
    public void testCapitalizeFully_SingleNonWhitespace() {
        assertEquals(""!"", WordUtils.capitalizeFully(""!""));
    }

    @Test
    public void testCapitalizeFully_MixedWithNumbersAndSymbols() {
        assertEquals(""Hello123! World456?"", WordUtils.capitalizeFully(""hello123! world456?""));
    }

    @Test
    public void testCapitalizeFully_WhitespaceOnlyTabsNewlines() {
        assertEquals(""\t\n"", WordUtils.capitalizeFully(""\t\n""));
    }

    @Test
    public void testCapitalizeFully_ComplexSentence() {
        String input = ""the quick brown fox jumps over the lazy dog."";
        String expected = ""The Quick Brown Fox Jumps Over The Lazy Dog."";
        assertEquals(expected, WordUtils.capitalizeFully(input));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_capitalizeFully_java_lang_String_Test.java
"org.apache.commons.lang3.text.WordUtils.capitalizeFully(java.lang.String, char[])","java.lang.String capitalizeFully(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack3; $stack4; delimLen;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack3 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    str = virtualinvoke str.<java.lang.String: java.lang.String toLowerCase()>();\n    $stack4 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; delimiters);\n\n    return $stack4;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <java.lang.String: java.lang.String toLowerCase()> via str = virtualinvoke str.<java.lang.String: java.lang.String toLowerCase()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> via $stack4 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalizeFully(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack3 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Converts all the delimiter separated words in a String into capitalized words; \nthat is each word is made up of a titlecase character and then a series of \nlowercase characters. </p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be capitalized. </p>\n\n<p>A <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalizeFully(null; *)            = null\nWordUtils.capitalizeFully(""; *)              = ""\nWordUtils.capitalizeFully(*; null)            = *\nWordUtils.capitalizeFully(*; new char[0])     = *\nWordUtils.capitalizeFully(i aM.fine""; {'.'}) = ""I am.Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@param delimiters set of characters to determine capitalization; null means whitespace\n@return capitalized String; <code>null</code> if null String input\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str; delimiters);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalizeFully_java_lang_String_charArr_Test {

    @Test
    public void testNullStringReturnsNull() {
        String result = WordUtils.capitalizeFully(null, new char[] {' '});
        assertNull(result);
    }

    @Test
    public void testEmptyStringReturnsEmpty() {
        String result = WordUtils.capitalizeFully("""", new char[] {' '});
        assertEquals("""", result);
    }

    @Test
    public void testNullDelimitersWhitespaceDefault() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, null);
        assertEquals(""I Am.fine"", result);
    }

    @Test
    public void testEmptyDelimitersReturnsInput() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, new char[0]);
        assertEquals(input, result);
    }

    @Test
    public void testSingleDelimiterPeriod() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""I am.Fine"", result);
    }

    @Test
    public void testMultipleDelimiters() {
        String input = ""hello-world_test"";
        String result = WordUtils.capitalizeFully(input, new char[] {'-', '_'});
        assertEquals(""Hello-World_Test"", result);
    }

    @Test
    public void testStringWithNoDelimitersPresent() {
        String input = ""hello"";
        String result = WordUtils.capitalizeFully(input, new char[] {'-'});
        assertEquals(""Hello"", result);
    }

    @Test
    public void testStringWithAllUpperCase() {
        String input = ""THIS IS A TEST"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""This Is A Test"", result);
    }

    @Test
    public void testStringWithAllLowerCase() {
        String input = ""this is a test"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""This Is A Test"", result);
    }

    @Test
    public void testStringWithMixedCaseAndDelimiters() {
        String input = ""tHis.iS.aN-ExAMPle"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.', '-'});
        assertEquals(""This.Is.An-Example"", result);
    }

    @Test
    public void testStringWithConsecutiveDelimiters() {
        String input = ""hello..world"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""Hello..World"", result);
    }

    @Test
    public void testStringWithLeadingAndTrailingDelimiters() {
        String input = "".hello.world."";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals("".Hello.World."", result);
    }

    @Test
    public void testStringWithWhitespaceDelimiters() {
        String input = ""hello   world"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""Hello   World"", result);
    }

    @Test
    public void testStringWithTabDelimiter() {
        String input = ""hello\tworld"";
        String result = WordUtils.capitalizeFully(input, new char[] {'\t'});
        assertEquals(""Hello\tWorld"", result);
    }

    @Test
    public void testStringWithUnicodeCharacters() {
        String input = ""élan vital"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""Élan Vital"", result);
    }

    @Test
    public void testStringWithNonLetterCharacters() {
        String input = ""123abc 456def"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""123abc 456def"", result);
    }

    @Test
    public void testStringWithNullDelimitersAndNullString() {
        String result = WordUtils.capitalizeFully(null, null);
        assertNull(result);
    }

    @Test
    public void testStringWithNullDelimitersAndEmptyString() {
        String result = WordUtils.capitalizeFully("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithEmptyStringAndEmptyDelimiters() {
        String result = WordUtils.capitalizeFully("""", new char[0]);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithLargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(word.length() > 0);
            assertEquals(Character.toUpperCase('w'), word.charAt(0));
        }
    }

    @Test
    public void testStringWithOnlyDelimiters() {
        String input = ""...."";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""...."", result);
    }

    @Test
    public void testStringWithNoAlphabeticCharacters() {
        String input = ""1234 5678"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""1234 5678"", result);
    }

    @Test
    public void testStringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00 smile"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""\uD83D\uDE00 Smile"", result);
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalizeFully_java_lang_String_charArr_Test {

    @Test
    public void testNullStringReturnsNull() {
        String result = WordUtils.capitalizeFully(null, new char[] {' '});
        assertNull(result);
    }

    @Test
    public void testEmptyStringReturnsEmpty() {
        String result = WordUtils.capitalizeFully("""", new char[] {' '});
        assertEquals("""", result);
    }

    @Test
    public void testNullDelimitersWhitespaceDefault() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, null);
        assertEquals(""I Am.fine"", result);
    }

    @Test
    public void testEmptyDelimitersReturnsInput() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, new char[0]);
        assertEquals(input, result);
    }

    @Test
    public void testSingleDelimiterPeriod() {
        String input = ""i aM.fine"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""I am.Fine"", result);
    }

    @Test
    public void testMultipleDelimiters() {
        String input = ""hello-world_test"";
        String result = WordUtils.capitalizeFully(input, new char[] {'-', '_'});
        assertEquals(""Hello-World_Test"", result);
    }

    @Test
    public void testStringWithNoDelimitersPresent() {
        String input = ""hello"";
        String result = WordUtils.capitalizeFully(input, new char[] {'-'});
        assertEquals(""Hello"", result);
    }

    @Test
    public void testStringWithAllUpperCase() {
        String input = ""THIS IS A TEST"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""This Is A Test"", result);
    }

    @Test
    public void testStringWithAllLowerCase() {
        String input = ""this is a test"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""This Is A Test"", result);
    }

    @Test
    public void testStringWithMixedCaseAndDelimiters() {
        String input = ""tHis.iS.aN-ExAMPle"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.', '-'});
        assertEquals(""This.Is.An-Example"", result);
    }

    @Test
    public void testStringWithConsecutiveDelimiters() {
        String input = ""hello..world"";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""Hello..World"", result);
    }

    @Test
    public void testStringWithLeadingAndTrailingDelimiters() {
        String input = "".hello.world."";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals("".Hello.World."", result);
    }

    @Test
    public void testStringWithWhitespaceDelimiters() {
        String input = ""hello   world"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""Hello   World"", result);
    }

    @Test
    public void testStringWithTabDelimiter() {
        String input = ""hello\tworld"";
        String result = WordUtils.capitalizeFully(input, new char[] {'\t'});
        assertEquals(""Hello\tWorld"", result);
    }

    @Test
    public void testStringWithUnicodeCharacters() {
        String input = ""élan vital"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""Élan Vital"", result);
    }

    @Test
    public void testStringWithNonLetterCharacters() {
        String input = ""123abc 456def"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""123abc 456def"", result);
    }

    @Test
    public void testStringWithNullDelimitersAndNullString() {
        String result = WordUtils.capitalizeFully(null, null);
        assertNull(result);
    }

    @Test
    public void testStringWithNullDelimitersAndEmptyString() {
        String result = WordUtils.capitalizeFully("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithEmptyStringAndEmptyDelimiters() {
        String result = WordUtils.capitalizeFully("""", new char[0]);
        assertEquals("""", result);
    }

    @Test
    public void testStringWithLargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(word.length() > 0);
            assertEquals(Character.toUpperCase('w'), word.charAt(0));
        }
    }

    @Test
    public void testStringWithOnlyDelimiters() {
        String input = ""...."";
        String result = WordUtils.capitalizeFully(input, new char[] {'.'});
        assertEquals(""...."", result);
    }

    @Test
    public void testStringWithNoAlphabeticCharacters() {
        String input = ""1234 5678"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""1234 5678"", result);
    }

    @Test
    public void testStringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00 smile"";
        String result = WordUtils.capitalizeFully(input, new char[] {' '});
        assertEquals(""\uD83D\uDE00 Smile"", result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_capitalizeFully_java_lang_String_charArr_Test.java
"org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String, char[])","java.lang.String uncapitalize(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack7; $stack8; $stack9; buffer; ch; delimLen; i; uncapitalizeNext;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    uncapitalizeNext = 1;\n    i = 0;\n\n  label5:\n    $stack8 = lengthof buffer;\n\n    if i >= $stack8 goto label8;\n    ch = buffer[i];\n    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack10 == 0 goto label6;\n    uncapitalizeNext = 1;\n\n    goto label7;\n\n  label6:\n    if uncapitalizeNext == 0 goto label7;\n    $stack11 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack11;\n    uncapitalizeNext = 0;\n\n  label7:\n    i = i + 1;\n\n    goto label5;\n\n  label8:\n    $stack9 = new java.lang.String;\n    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack9;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.Character: char toLowerCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Uncapitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed.</p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be uncapitalized. </p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.uncapitalize(null; *)            = null\nWordUtils.uncapitalize(""; *)              = ""\nWordUtils.uncapitalize(*; null)            = *\nWordUtils.uncapitalize(*; new char[0])     = *\nWordUtils.uncapitalize(I AM.FINE""; {'.'}) = ""i AM.fINE""\n</pre>\n\n@param str the String to uncapitalize; may be null\n@param delimiters set of characters to determine uncapitalization; null means whitespace\n@return uncapitalized String; <code>null</code> if null String input\n@see #capitalize(String)\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch; delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_uncapitalize_String_charArray_Test {

    // Helper: Provide a minimal isDelimiter implementation if needed for testing via reflection
    private static boolean callIsDelimiter(char ch, char[] delimiters) throws Exception {
        java.lang.reflect.Method m = WordUtils.class.getDeclaredMethod(""isDelimiter"", char.class, char[].class);
        m.setAccessible(true);
        return (Boolean) m.invoke(null, ch, delimiters);
    }

    @Test
    public void testNullStringReturnsNull() {
        assertNull(WordUtils.uncapitalize(null, new char[] {' '}));
    }

    @Test
    public void testEmptyStringReturnsEmpty() {
        assertEquals("""", WordUtils.uncapitalize("""", new char[] {' '}));
    }

    @Test
    public void testNullDelimitersWhitespaceDefault() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
        assertEquals(""i am.fine"", WordUtils.uncapitalize(""I Am.Fine"", null));
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
    }

    @Test
    public void testEmptyDelimitersReturnsOriginal() {
        assertEquals(""I AM.FINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[0]));
        assertEquals(""Hello World"", WordUtils.uncapitalize(""Hello World"", new char[0]));
        assertEquals("""", WordUtils.uncapitalize("""", new char[0]));
        assertNull(WordUtils.uncapitalize(null, new char[0]));
    }

    @Test
    public void testSingleDelimiterPeriod() {
        assertEquals(""i AM.fINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[] {'.'}));
        assertEquals(""hello world.test"", WordUtils.uncapitalize(""Hello World.Test"", new char[] {'.'}));
        assertEquals(""a.b.c"", WordUtils.uncapitalize(""A.B.C"", new char[] {'.'}));
    }

    @Test
    public void testMultipleDelimiters() {
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {'-', '.'}));
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {' ', '-', '.'}));
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {' ', '-', '.'}));
    }

    @Test
    public void testWhitespaceDelimiter() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' '}));
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' ', '\t', '\n'}));
    }

    @Test
    public void testNoDelimitersInString() {
        assertEquals(""iAMFINE"", WordUtils.uncapitalize(""IAMFINE"", new char[] {' '}));
        assertEquals(""iAMFINE"", WordUtils.uncapitalize(""IAMFINE"", null));
    }

    @Test
    public void testStringWithOnlyDelimiters() {
        assertEquals(""...."", WordUtils.uncapitalize(""...."", new char[] {'.'}));
        assertEquals(""    "", WordUtils.uncapitalize(""    "", new char[] {' '}));
    }

    @Test
    public void testStringWithLeadingAndTrailingDelimiters() {
        assertEquals("".i am.fine."", WordUtils.uncapitalize("".I Am.Fine."", new char[] {'.', ' '}));
        assertEquals(""  i am fine  "", WordUtils.uncapitalize(""  I Am Fine  "", new char[] {' '}));
    }

    @Test
    public void testStringWithConsecutiveDelimiters() {
        assertEquals(""i  am  fine"", WordUtils.uncapitalize(""I  Am  Fine"", new char[] {' '}));
        assertEquals(""i--am--fine"", WordUtils.uncapitalize(""I--Am--Fine"", new char[] {'-'}));
    }

    @Test
    public void testStringWithMixedCase() {
        assertEquals(""i aM fINE"", WordUtils.uncapitalize(""I AM FINE"", new char[] {' '}));
        assertEquals(""i aM.fINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[] {'.', ' '}));
    }

    @Test
    public void testStringWithNonLetterCharacters() {
        assertEquals(""1abc 2def"", WordUtils.uncapitalize(""1Abc 2Def"", new char[] {' '}));
        assertEquals(""!hello !world"", WordUtils.uncapitalize(""!Hello !World"", new char[] {' '}));
    }

    @Test
    public void testStringWithUnicodeCharacters() {
        assertEquals(""éclair gâteau"", WordUtils.uncapitalize(""Éclair Gâteau"", new char[] {' '}));
        assertEquals(""über-cool"", WordUtils.uncapitalize(""Über-Cool"", new char[] {'-'}));
    }

    @Test
    public void testStringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00Smile \uD83D\uDE01Laugh"";
        String expected = ""\uD83D\uDE00smile \uD83D\uDE01laugh"";
        assertEquals(expected, WordUtils.uncapitalize(input, new char[] {' '}));
    }

    @Test
    public void testStringWithNullDelimiterAndNullString() {
        assertNull(WordUtils.uncapitalize(null, null));
    }

    @Test
    public void testStringWithNullDelimiterAndEmptyString() {
        assertEquals("""", WordUtils.uncapitalize("""", null));
    }

    @Test
    public void testStringWithNullDelimiterAndWhitespaceString() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", null));
    }

    @Test
    public void testStringWithDelimiterNotPresent() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {','}));
    }

    @Test
    public void testStringWithAllUpperCase() {
        assertEquals(""i a m f i n e"", WordUtils.uncapitalize(""I A M F I N E"", new char[] {' '}));
    }

    @Test
    public void testStringWithAllLowerCase() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""i am fine"", new char[] {' '}));
    }

    @Test
    public void testStringWithMixedDelimiters() {
        assertEquals(""i-am.fine"", WordUtils.uncapitalize(""I-Am.Fine"", new char[] {'-', '.'}));
    }

    @Test
    public void testStringWithTabAndNewlineDelimiters() {
        assertEquals(""i\tam\nfine"", WordUtils.uncapitalize(""I\tAm\nFine"", new char[] {'\t', '\n'}));
    }

    @Test
    public void testStringWithLargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""A "");
        }
        String input = sb.toString().trim();
        String expected = input.toLowerCase();
        assertEquals(expected, WordUtils.uncapitalize(input, new char[] {' '}));
    }

    @Test
    public void testStringWithNullsInDelimiters() {
        char[] delimiters = new char[] {' ', 0, '\u0000'};
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", delimiters));
    }

    @Test
    public void testStringWithDelimiterAtEnd() {
        assertEquals(""hello."", WordUtils.uncapitalize(""Hello."", new char[] {'.'}));
    }

    @Test
    public void testStringWithDelimiterAtStart() {
        assertEquals("".hello"", WordUtils.uncapitalize("".Hello"", new char[] {'.'}));
    }

    @Test
    public void testStringWithMultipleWordsAndDelimiters() {
        assertEquals(""a-b c.d e"", WordUtils.uncapitalize(""A-B C.D E"", new char[] {'-', '.', ' '}));
    }

    @Test
    public void testStringWithSingleCharacter() {
        assertEquals(""a"", WordUtils.uncapitalize(""A"", new char[] {' '}));
        assertEquals(""a"", WordUtils.uncapitalize(""a"", new char[] {' '}));
    }

    @Test
    public void testStringWithOnlyDelimitersAndNullDelimiters() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", null));
    }

    @Test
    public void testStringWithOnlyDelimitersAndEmptyDelimiters() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", new char[0]));
    }

    @Test
    public void testStringWithNullDelimiterAndSpecialCharacters() {
        assertEquals(""!hello !world"", WordUtils.uncapitalize(""!Hello !World"", null));
    }

    @Test
    public void testStringWithAllDelimiters() {
        assertEquals(""... ..."", WordUtils.uncapitalize(""... ..."", new char[] {'.', ' '}));
    }

    @Test
    public void testStringWithNoAlphaCharacters() {
        assertEquals(""123 456"", WordUtils.uncapitalize(""123 456"", new char[] {' '}));
    }

    @Test
    public void testStringWithDelimiterArrayContainingDuplicates() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' ', ' ', ' '}));
    }

    @Test
    public void testStringWithNullDelimiterArray() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
    }

    @Test
    public void testStringWithNullDelimiterArrayAndNullString() {
        assertNull(WordUtils.uncapitalize(null, null));
    }

    @Test
    public void testStringWithNullDelimiterArrayAndEmptyString() {
        assertEquals("""", WordUtils.uncapitalize("""", null));
    }

    @Test
    public void testStringWithWhitespaceAndPunctuation() {
        assertEquals(""hello, world!"", WordUtils.uncapitalize(""Hello, World!"", new char[] {' ', ','}));
    }

    @Test
    public void testStringWithEmoji() {
        assertEquals(""\uD83D\uDE00smile"", WordUtils.uncapitalize(""\uD83D\uDE00Smile"", new char[] {' '}));
    }

    @Test
    public void testStringWithNullsEverywhere() {
        assertNull(WordUtils.uncapitalize(null, null));
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_uncapitalize_String_charArray_Test {

    // Helper: Provide a minimal isDelimiter implementation if needed for testing via reflection
    private static boolean callIsDelimiter(char ch, char[] delimiters) throws Exception {
        java.lang.reflect.Method m = WordUtils.class.getDeclaredMethod(""isDelimiter"", char.class, char[].class);
        m.setAccessible(true);
        return (Boolean) m.invoke(null, ch, delimiters);
    }

    @Test
    public void testNullStringReturnsNull() {
        assertNull(WordUtils.uncapitalize(null, new char[] {' '}));
    }

    @Test
    public void testEmptyStringReturnsEmpty() {
        assertEquals("""", WordUtils.uncapitalize("""", new char[] {' '}));
    }

    @Test
    public void testNullDelimitersWhitespaceDefault() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
        assertEquals(""i am.fine"", WordUtils.uncapitalize(""I Am.Fine"", null));
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
    }

    @Test
    public void testEmptyDelimitersReturnsOriginal() {
        assertEquals(""I AM.FINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[0]));
        assertEquals(""Hello World"", WordUtils.uncapitalize(""Hello World"", new char[0]));
        assertEquals("""", WordUtils.uncapitalize("""", new char[0]));
        assertNull(WordUtils.uncapitalize(null, new char[0]));
    }

    @Test
    public void testSingleDelimiterPeriod() {
        assertEquals(""i AM.fINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[] {'.'}));
        assertEquals(""hello world.test"", WordUtils.uncapitalize(""Hello World.Test"", new char[] {'.'}));
        assertEquals(""a.b.c"", WordUtils.uncapitalize(""A.B.C"", new char[] {'.'}));
    }

    @Test
    public void testMultipleDelimiters() {
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {'-', '.'}));
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {' ', '-', '.'}));
        assertEquals(""i a-m.fine"", WordUtils.uncapitalize(""I A-M.Fine"", new char[] {' ', '-', '.'}));
    }

    @Test
    public void testWhitespaceDelimiter() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' '}));
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' ', '\t', '\n'}));
    }

    @Test
    public void testNoDelimitersInString() {
        assertEquals(""iAMFINE"", WordUtils.uncapitalize(""IAMFINE"", new char[] {' '}));
        assertEquals(""iAMFINE"", WordUtils.uncapitalize(""IAMFINE"", null));
    }

    @Test
    public void testStringWithOnlyDelimiters() {
        assertEquals(""...."", WordUtils.uncapitalize(""...."", new char[] {'.'}));
        assertEquals(""    "", WordUtils.uncapitalize(""    "", new char[] {' '}));
    }

    @Test
    public void testStringWithLeadingAndTrailingDelimiters() {
        assertEquals("".i am.fine."", WordUtils.uncapitalize("".I Am.Fine."", new char[] {'.', ' '}));
        assertEquals(""  i am fine  "", WordUtils.uncapitalize(""  I Am Fine  "", new char[] {' '}));
    }

    @Test
    public void testStringWithConsecutiveDelimiters() {
        assertEquals(""i  am  fine"", WordUtils.uncapitalize(""I  Am  Fine"", new char[] {' '}));
        assertEquals(""i--am--fine"", WordUtils.uncapitalize(""I--Am--Fine"", new char[] {'-'}));
    }

    @Test
    public void testStringWithMixedCase() {
        assertEquals(""i aM fINE"", WordUtils.uncapitalize(""I AM FINE"", new char[] {' '}));
        assertEquals(""i aM.fINE"", WordUtils.uncapitalize(""I AM.FINE"", new char[] {'.', ' '}));
    }

    @Test
    public void testStringWithNonLetterCharacters() {
        assertEquals(""1abc 2def"", WordUtils.uncapitalize(""1Abc 2Def"", new char[] {' '}));
        assertEquals(""!hello !world"", WordUtils.uncapitalize(""!Hello !World"", new char[] {' '}));
    }

    @Test
    public void testStringWithUnicodeCharacters() {
        assertEquals(""éclair gâteau"", WordUtils.uncapitalize(""Éclair Gâteau"", new char[] {' '}));
        assertEquals(""über-cool"", WordUtils.uncapitalize(""Über-Cool"", new char[] {'-'}));
    }

    @Test
    public void testStringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00Smile \uD83D\uDE01Laugh"";
        String expected = ""\uD83D\uDE00smile \uD83D\uDE01laugh"";
        assertEquals(expected, WordUtils.uncapitalize(input, new char[] {' '}));
    }

    @Test
    public void testStringWithNullDelimiterAndNullString() {
        assertNull(WordUtils.uncapitalize(null, null));
    }

    @Test
    public void testStringWithNullDelimiterAndEmptyString() {
        assertEquals("""", WordUtils.uncapitalize("""", null));
    }

    @Test
    public void testStringWithNullDelimiterAndWhitespaceString() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", null));
    }

    @Test
    public void testStringWithDelimiterNotPresent() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {','}));
    }

    @Test
    public void testStringWithAllUpperCase() {
        assertEquals(""i a m f i n e"", WordUtils.uncapitalize(""I A M F I N E"", new char[] {' '}));
    }

    @Test
    public void testStringWithAllLowerCase() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""i am fine"", new char[] {' '}));
    }

    @Test
    public void testStringWithMixedDelimiters() {
        assertEquals(""i-am.fine"", WordUtils.uncapitalize(""I-Am.Fine"", new char[] {'-', '.'}));
    }

    @Test
    public void testStringWithTabAndNewlineDelimiters() {
        assertEquals(""i\tam\nfine"", WordUtils.uncapitalize(""I\tAm\nFine"", new char[] {'\t', '\n'}));
    }

    @Test
    public void testStringWithLargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 10000; i++) {
            sb.append(""A "");
        }
        String input = sb.toString().trim();
        String expected = input.toLowerCase();
        assertEquals(expected, WordUtils.uncapitalize(input, new char[] {' '}));
    }

    @Test
    public void testStringWithNullsInDelimiters() {
        char[] delimiters = new char[] {' ', 0, '\u0000'};
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", delimiters));
    }

    @Test
    public void testStringWithDelimiterAtEnd() {
        assertEquals(""hello."", WordUtils.uncapitalize(""Hello."", new char[] {'.'}));
    }

    @Test
    public void testStringWithDelimiterAtStart() {
        assertEquals("".hello"", WordUtils.uncapitalize("".Hello"", new char[] {'.'}));
    }

    @Test
    public void testStringWithMultipleWordsAndDelimiters() {
        assertEquals(""a-b c.d e"", WordUtils.uncapitalize(""A-B C.D E"", new char[] {'-', '.', ' '}));
    }

    @Test
    public void testStringWithSingleCharacter() {
        assertEquals(""a"", WordUtils.uncapitalize(""A"", new char[] {' '}));
        assertEquals(""a"", WordUtils.uncapitalize(""a"", new char[] {' '}));
    }

    @Test
    public void testStringWithOnlyDelimitersAndNullDelimiters() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", null));
    }

    @Test
    public void testStringWithOnlyDelimitersAndEmptyDelimiters() {
        assertEquals(""   "", WordUtils.uncapitalize(""   "", new char[0]));
    }

    @Test
    public void testStringWithNullDelimiterAndSpecialCharacters() {
        assertEquals(""!hello !world"", WordUtils.uncapitalize(""!Hello !World"", null));
    }

    @Test
    public void testStringWithAllDelimiters() {
        assertEquals(""... ..."", WordUtils.uncapitalize(""... ..."", new char[] {'.', ' '}));
    }

    @Test
    public void testStringWithNoAlphaCharacters() {
        assertEquals(""123 456"", WordUtils.uncapitalize(""123 456"", new char[] {' '}));
    }

    @Test
    public void testStringWithDelimiterArrayContainingDuplicates() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", new char[] {' ', ' ', ' '}));
    }

    @Test
    public void testStringWithNullDelimiterArray() {
        assertEquals(""i am fine"", WordUtils.uncapitalize(""I Am Fine"", null));
    }

    @Test
    public void testStringWithNullDelimiterArrayAndNullString() {
        assertNull(WordUtils.uncapitalize(null, null));
    }

    @Test
    public void testStringWithNullDelimiterArrayAndEmptyString() {
        assertEquals("""", WordUtils.uncapitalize("""", null));
    }

    @Test
    public void testStringWithWhitespaceAndPunctuation() {
        assertEquals(""hello, world!"", WordUtils.uncapitalize(""Hello, World!"", new char[] {' ', ','}));
    }

    @Test
    public void testStringWithEmoji() {
        assertEquals(""\uD83D\uDE00smile"", WordUtils.uncapitalize(""\uD83D\uDE00Smile"", new char[] {' '}));
    }

    @Test
    public void testStringWithNullsEverywhere() {
        assertNull(WordUtils.uncapitalize(null, null));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_uncapitalize_String_charArray_Test.java
org.apache.commons.lang3.text.WordUtils.swapCase(java.lang.String),java.lang.String swapCase(java.lang.String),{\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack5; $stack6; $stack7; $stack8; $stack9; buffer; ch; i; whitespace;\n\n\n    str := @parameter0: java.lang.String;\n    $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack5 == 0 goto label1;\n\n    return str;\n\n  label1:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    whitespace = 1;\n    i = 0;\n\n  label2:\n    $stack6 = lengthof buffer;\n\n    if i >= $stack6 goto label8;\n    ch = buffer[i];\n    $stack8 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(ch);\n\n    if $stack8 == 0 goto label3;\n    $stack14 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack14;\n    whitespace = 0;\n\n    goto label7;\n\n  label3:\n    $stack9 = staticinvoke <java.lang.Character: boolean isTitleCase(char)>(ch);\n\n    if $stack9 == 0 goto label4;\n    $stack13 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\n    buffer[i] = $stack13;\n    whitespace = 0;\n\n    goto label7;\n\n  label4:\n    $stack10 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(ch);\n\n    if $stack10 == 0 goto label6;\n\n    if whitespace == 0 goto label5;\n    $stack12 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\n    buffer[i] = $stack12;\n    whitespace = 0;\n\n    goto label7;\n\n  label5:\n    $stack11 = staticinvoke <java.lang.Character: char toUpperCase(char)>(ch);\n    buffer[i] = $stack11;\n\n    goto label7;\n\n  label6:\n    whitespace = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\n\n  label7:\n    i = i + 1;\n\n    goto label2;\n\n  label8:\n    $stack7 = new java.lang.String;\n    specialinvoke $stack7.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack7;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isUpperCase(char)> via $stack8 = staticinvoke <java.lang.Character: boolean isUpperCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toLowerCase(char)> via $stack14 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isTitleCase(char)> via $stack9 = staticinvoke <java.lang.Character: boolean isTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toLowerCase(char)> via $stack13 = staticinvoke <java.lang.Character: char toLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isLowerCase(char)> via $stack10 = staticinvoke <java.lang.Character: boolean isLowerCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toTitleCase(char)> via $stack12 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: char toUpperCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toUpperCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.Character: boolean isWhitespace(char)> via whitespace = staticinvoke <java.lang.Character: boolean isWhitespace(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack7.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String swapCase(java.lang.String)> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack5 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Swaps the case of a String using a word based algorithm.</p>\n\n<ul>\n <li>Upper case character converts to Lower case</li>\n <li>Title case character converts to Lower case</li>\n <li>Lower case character after Whitespace or at start converts to Title case</li>\n <li>Other Lower case character converts to Upper case</li>\n</ul>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nStringUtils.swapCase(null)                 = null\nStringUtils.swapCase("")                   = ""\nStringUtils.swapCase(The dog has a BONE"") = ""tHE DOG HAS A bone""\n</pre>\n\n@param str the String to swap case; may be null\n@return the changed String; <code>null</code> if null String input\n""",{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean whitespace = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (Character.isUpperCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            whitespace = false;\n        } else if (Character.isTitleCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            whitespace = false;\n        } else if (Character.isLowerCase(ch)) {\n            if (whitespace) {\n                buffer[i] = Character.toTitleCase(ch);\n                whitespace = false;\n            } else {\n                buffer[i] = Character.toUpperCase(ch);\n            }\n        } else {\n            whitespace = Character.isWhitespace(ch);\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_swapCase_java_lang_String_Test {

    // Helper: Reference to the static method under test
    private static String swapCase(String str) {
        return WordUtils.swapCase(str);
    }

    @Test
    public void testSwapCase_NullInput() {
        assertNull(""Null input should return null"", swapCase(null));
    }

    @Test
    public void testSwapCase_EmptyString() {
        assertEquals(""Empty string should return empty string"", """", swapCase(""""));
    }

    @Test
    public void testSwapCase_WhitespaceOnly() {
        assertEquals(""Whitespace only should return unchanged"", ""   \t\n"", swapCase(""   \t\n""));
    }

    @Test
    public void testSwapCase_SingleUpperCase() {
        assertEquals(""Single uppercase should become lowercase"", ""a"", swapCase(""A""));
    }

    @Test
    public void testSwapCase_SingleLowerCase() {
        assertEquals(""Single lowercase at start should become titlecase"", ""\u01C5"", swapCase(""ǅ"")); // ǅ is already titlecase, but let's test with 'a'
        assertEquals(""Single lowercase at start should become titlecase"", ""A"", swapCase(""a""));
    }

    @Test
    public void testSwapCase_SingleTitleCase() {
        // Titlecase char: ǅ (U+01C5)
        assertEquals(""Single titlecase should become lowercase"", ""\u01C6"", swapCase(""\u01C5""));
    }

    @Test
    public void testSwapCase_SingleNonLetter() {
        assertEquals(""Non-letter should remain unchanged"", ""1"", swapCase(""1""));
        assertEquals(""Symbol should remain unchanged"", ""@"", swapCase(""@""));
    }

    @Test
    public void testSwapCase_MixedCaseWord() {
        assertEquals(""Mixed case word"", ""hELLO"", swapCase(""Hello""));
        assertEquals(""Mixed case word"", ""wORLD"", swapCase(""World""));
    }

    @Test
    public void testSwapCase_MultipleWords() {
        assertEquals(""Multiple words"", ""tHE DOG HAS A bone"", swapCase(""The dog has a BONE""));
    }

    @Test
    public void testSwapCase_LeadingWhitespace() {
        assertEquals(""Leading whitespace"", "" tEST"", swapCase("" Test""));
    }

    @Test
    public void testSwapCase_TrailingWhitespace() {
        assertEquals(""Trailing whitespace"", ""tEST "", swapCase(""Test ""));
    }

    @Test
    public void testSwapCase_WhitespaceBetweenWords() {
        assertEquals(""Whitespace between words"", ""tEST cASE"", swapCase(""Test Case""));
    }

    @Test
    public void testSwapCase_AllUpperCase() {
        assertEquals(""All uppercase"", ""hello world"", swapCase(""HELLO WORLD""));
    }

    @Test
    public void testSwapCase_AllLowerCase() {
        assertEquals(""All lowercase"", ""H E L L O"", swapCase(""h e l l o""));
    }

    @Test
    public void testSwapCase_AllTitleCase() {
        // Titlecase string: ǅǈǋ (U+01C5, U+01C8, U+01CB)
        assertEquals(""All titlecase"", ""\u01C6\u01C9\u01CC"", swapCase(""\u01C5\u01C8\u01CB""));
    }

    @Test
    public void testSwapCase_AlternatingCase() {
        assertEquals(""Alternating case"", ""hElLo WoRlD"", swapCase(""HeLlO wOrLd""));
    }

    @Test
    public void testSwapCase_NonLetterAndWhitespace() {
        assertEquals(""Non-letter and whitespace"", ""1 2 3"", swapCase(""1 2 3""));
        assertEquals(""Symbols and whitespace"", ""! @ #"", swapCase(""! @ #""));
    }

    @Test
    public void testSwapCase_UnicodeLetters() {
        // Greek: ΑΒΓ (upper) -> αβγ (lower)
        assertEquals(""Greek uppercase"", ""\u03B1\u03B2\u03B3"", swapCase(""\u0391\u0392\u0393""));
        // Cyrillic: аБв (lower, upper, lower)
        assertEquals(""Cyrillic mixed"", ""АбВ"", swapCase(""\u0430\u0411\u0432""));
    }

    @Test
    public void testSwapCase_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""AbC "");
        }
        String input = sb.toString().trim();
        String expected = """";
        for (int i = 0; i < 1000; i++) {
            expected += ""aBc "";
        }
        expected = expected.trim();
        assertEquals(""Long repeated pattern"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_WhitespaceAffectsTitleCase() {
        // Lowercase after whitespace should become titlecase
        assertEquals(""Whitespace affects titlecase"", ""A B C"", swapCase(""a b c""));
        // Lowercase not after whitespace should become uppercase
        assertEquals(""No whitespace, all uppercase"", ""ABC"", swapCase(""abc""));
    }

    @Test
    public void testSwapCase_TabAndNewlineWhitespace() {
        assertEquals(""Tabs and newlines"", ""A\tB\nC"", swapCase(""a\tb\nc""));
    }

    @Test
    public void testSwapCase_OnlyWhitespace() {
        assertEquals(""Only whitespace"", "" \t\n"", swapCase("" \t\n""));
    }

    @Test
    public void testSwapCase_EmojiAndSupplementaryChars() {
        // Emoji and supplementary chars should remain unchanged
        assertEquals(""Emoji"", ""\uD83D\uDE00"", swapCase(""\uD83D\uDE00""));
        assertEquals(""Emoji with text"", ""A\uD83D\uDE00B"", swapCase(""a\uD83D\uDE00b""));
    }

    @Test
    public void testSwapCase_StringWithSurrogatePairs() {
        // Musical symbol G clef (U+1D11E)
        String input = ""a\uD834\uDD1Eb"";
        String expected = ""A\uD834\uDD1EB"";
        assertEquals(""Surrogate pairs"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithNullChar() {
        String input = ""a\0b"";
        String expected = ""A\0B"";
        assertEquals(""Null char in string"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithMixedWhitespace() {
        String input = ""a\tb c\nd"";
        String expected = ""A\tB C\nD"";
        assertEquals(""Mixed whitespace"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithPunctuation() {
        String input = ""hello, world!"";
        String expected = ""H, W!"";
        expected = swapCase(""h, w!""); // To get the correct expected value
        assertEquals(""With punctuation"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithNumbersAndLetters() {
        String input = ""abc123XYZ"";
        String expected = ""AbC123xyz"";
        assertEquals(""Numbers and letters"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_ComplexSentence() {
        String input = ""The quick brown FOX jumps over the lazy DOG."";
        String expected = ""tHE QUICK BROWN fox JUMPS OVER THE LAZY dog."";
        assertEquals(""Complex sentence"", expected, swapCase(input));
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_swapCase_java_lang_String_Test {

    // Helper: Reference to the static method under test
    private static String swapCase(String str) {
        return WordUtils.swapCase(str);
    }

    @Test
    public void testSwapCase_NullInput() {
        assertNull(""Null input should return null"", swapCase(null));
    }

    @Test
    public void testSwapCase_EmptyString() {
        assertEquals(""Empty string should return empty string"", """", swapCase(""""));
    }

    @Test
    public void testSwapCase_WhitespaceOnly() {
        assertEquals(""Whitespace only should return unchanged"", ""   \t\n"", swapCase(""   \t\n""));
    }

    @Test
    public void testSwapCase_SingleUpperCase() {
        assertEquals(""Single uppercase should become lowercase"", ""a"", swapCase(""A""));
    }

    @Test
    public void testSwapCase_SingleLowerCase() {
        assertEquals(""Single lowercase at start should become titlecase"", ""\u01C5"", swapCase(""ǅ"")); // ǅ is already titlecase, but let's test with 'a'
        assertEquals(""Single lowercase at start should become titlecase"", ""A"", swapCase(""a""));
    }

    @Test
    public void testSwapCase_SingleTitleCase() {
        // Titlecase char: ǅ (U+01C5)
        assertEquals(""Single titlecase should become lowercase"", ""\u01C6"", swapCase(""\u01C5""));
    }

    @Test
    public void testSwapCase_SingleNonLetter() {
        assertEquals(""Non-letter should remain unchanged"", ""1"", swapCase(""1""));
        assertEquals(""Symbol should remain unchanged"", ""@"", swapCase(""@""));
    }

    @Test
    public void testSwapCase_MixedCaseWord() {
        assertEquals(""Mixed case word"", ""hELLO"", swapCase(""Hello""));
        assertEquals(""Mixed case word"", ""wORLD"", swapCase(""World""));
    }

    @Test
    public void testSwapCase_MultipleWords() {
        assertEquals(""Multiple words"", ""tHE DOG HAS A bone"", swapCase(""The dog has a BONE""));
    }

    @Test
    public void testSwapCase_LeadingWhitespace() {
        assertEquals(""Leading whitespace"", "" tEST"", swapCase("" Test""));
    }

    @Test
    public void testSwapCase_TrailingWhitespace() {
        assertEquals(""Trailing whitespace"", ""tEST "", swapCase(""Test ""));
    }

    @Test
    public void testSwapCase_WhitespaceBetweenWords() {
        assertEquals(""Whitespace between words"", ""tEST cASE"", swapCase(""Test Case""));
    }

    @Test
    public void testSwapCase_AllUpperCase() {
        assertEquals(""All uppercase"", ""hello world"", swapCase(""HELLO WORLD""));
    }

    @Test
    public void testSwapCase_AllLowerCase() {
        assertEquals(""All lowercase"", ""H E L L O"", swapCase(""h e l l o""));
    }

    @Test
    public void testSwapCase_AllTitleCase() {
        // Titlecase string: ǅǈǋ (U+01C5, U+01C8, U+01CB)
        assertEquals(""All titlecase"", ""\u01C6\u01C9\u01CC"", swapCase(""\u01C5\u01C8\u01CB""));
    }

    @Test
    public void testSwapCase_AlternatingCase() {
        assertEquals(""Alternating case"", ""hElLo WoRlD"", swapCase(""HeLlO wOrLd""));
    }

    @Test
    public void testSwapCase_NonLetterAndWhitespace() {
        assertEquals(""Non-letter and whitespace"", ""1 2 3"", swapCase(""1 2 3""));
        assertEquals(""Symbols and whitespace"", ""! @ #"", swapCase(""! @ #""));
    }

    @Test
    public void testSwapCase_UnicodeLetters() {
        // Greek: ΑΒΓ (upper) -> αβγ (lower)
        assertEquals(""Greek uppercase"", ""\u03B1\u03B2\u03B3"", swapCase(""\u0391\u0392\u0393""));
        // Cyrillic: аБв (lower, upper, lower)
        assertEquals(""Cyrillic mixed"", ""АбВ"", swapCase(""\u0430\u0411\u0432""));
    }

    @Test
    public void testSwapCase_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""AbC "");
        }
        String input = sb.toString().trim();
        String expected = """";
        for (int i = 0; i < 1000; i++) {
            expected += ""aBc "";
        }
        expected = expected.trim();
        assertEquals(""Long repeated pattern"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_WhitespaceAffectsTitleCase() {
        // Lowercase after whitespace should become titlecase
        assertEquals(""Whitespace affects titlecase"", ""A B C"", swapCase(""a b c""));
        // Lowercase not after whitespace should become uppercase
        assertEquals(""No whitespace, all uppercase"", ""ABC"", swapCase(""abc""));
    }

    @Test
    public void testSwapCase_TabAndNewlineWhitespace() {
        assertEquals(""Tabs and newlines"", ""A\tB\nC"", swapCase(""a\tb\nc""));
    }

    @Test
    public void testSwapCase_OnlyWhitespace() {
        assertEquals(""Only whitespace"", "" \t\n"", swapCase("" \t\n""));
    }

    @Test
    public void testSwapCase_EmojiAndSupplementaryChars() {
        // Emoji and supplementary chars should remain unchanged
        assertEquals(""Emoji"", ""\uD83D\uDE00"", swapCase(""\uD83D\uDE00""));
        assertEquals(""Emoji with text"", ""A\uD83D\uDE00B"", swapCase(""a\uD83D\uDE00b""));
    }

    @Test
    public void testSwapCase_StringWithSurrogatePairs() {
        // Musical symbol G clef (U+1D11E)
        String input = ""a\uD834\uDD1Eb"";
        String expected = ""A\uD834\uDD1EB"";
        assertEquals(""Surrogate pairs"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithNullChar() {
        String input = ""a\0b"";
        String expected = ""A\0B"";
        assertEquals(""Null char in string"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithMixedWhitespace() {
        String input = ""a\tb c\nd"";
        String expected = ""A\tB C\nD"";
        assertEquals(""Mixed whitespace"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithPunctuation() {
        String input = ""hello, world!"";
        String expected = ""H, W!"";
        expected = swapCase(""h, w!""); // To get the correct expected value
        assertEquals(""With punctuation"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_StringWithNumbersAndLetters() {
        String input = ""abc123XYZ"";
        String expected = ""AbC123xyz"";
        assertEquals(""Numbers and letters"", expected, swapCase(input));
    }

    @Test
    public void testSwapCase_ComplexSentence() {
        String input = ""The quick brown FOX jumps over the lazy DOG."";
        String expected = ""tHE QUICK BROWN fox JUMPS OVER THE LAZY dog."";
        assertEquals(""Complex sentence"", expected, swapCase(input));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_swapCase_java_lang_String_Test.java
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int)","java.lang.String wrap(java.lang.String,int)",{\n    int wrapLength;\n    java.lang.String str;\n    unknown $stack2;\n\n\n    str := @parameter0: java.lang.String;\n    wrapLength := @parameter1: int;\n    $stack2 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)>(str; wrapLength; null; 0);\n\n    return $stack2;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> via $stack2 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)>(str; wrapLength; null; 0);,[public ; static ],[public ],"<p>Wraps a single line of text; identifying words by <code>' '</code>.</p>\n\n<p>New lines will be separated by the system property line separator.\nVery long words; such as URLs will <i>not</i> be wrapped.</p>\n\n<p>Leading spaces on a new line are stripped.\nTrailing spaces are not stripped.</p>\n\n<pre>\nWordUtils.wrap(null; *) = null\nWordUtils.wrap(""; *) = ""\n</pre>\n\n@param str the String to be word wrapped; may be null\n@param wrapLength the column to wrap the words at; less than 1 is treated as 1\n@return a line with newlines inserted; <code>null</code> if null input\n",{\n    return wrap(str; wrapLength; null; false);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_wrap_java_lang_String_int_Test {

    @Test
    public void testWrap_NullInput() {
        String result = WordUtils.wrap(null, 10);
        assertNull(""Expected null when input string is null"", result);
    }

    @Test
    public void testWrap_EmptyString() {
        String result = WordUtils.wrap("""", 10);
        assertEquals(""Expected empty string when input is empty"", """", result);
    }

    @Test
    public void testWrap_WrapLengthLessThanOne() {
        String input = ""The quick brown fox"";
        String result = WordUtils.wrap(input, 0);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthOne() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, 1);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_ShortStringNoWrapNeeded() {
        String input = ""Hello"";
        String result = WordUtils.wrap(input, 10);
        assertEquals(""Short string should not be wrapped"", ""Hello"", result);
    }

    @Test
    public void testWrap_StringExactlyAtWrapLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6);
        assertEquals(""String at wrap length should not be wrapped"", ""abcdef"", result);
    }

    @Test
    public void testWrap_LongStringWithSpaces() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String result = WordUtils.wrap(input, 10);
        assertNotNull(result);
        String[] lines = result.split(System.getProperty(""line.separator""));
        for (String line : lines) {
            assertTrue(""Each line should be at most 10 characters"", line.length() <= 10);
        }
    }

    @Test
    public void testWrap_LongWordNoSpaces() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 5);
        // According to javadoc, very long words will not be wrapped
        assertEquals(""Long word without spaces should not be wrapped"", input, result);
    }

    @Test
    public void testWrap_MultipleSpaces() {
        String input = ""a  b   c"";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_LeadingAndTrailingSpaces() {
        String input = ""   Hello world   "";
        String result = WordUtils.wrap(input, 5);
        assertNotNull(result);
        String[] lines = result.split(System.getProperty(""line.separator""));
        // Leading spaces on new lines are stripped, trailing spaces are not
        for (int i = 1; i < lines.length; i++) {
            assertFalse(""Leading spaces on new lines should be stripped"", lines[i].startsWith("" ""));
        }
    }

    @Test
    public void testWrap_StringWithLineSeparators() {
        String input = ""Hello\nWorld"";
        String result = WordUtils.wrap(input, 3);
        assertNotNull(result);
        assertTrue(""Result should contain system line separator"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthGreaterThanStringLength() {
        String input = ""short"";
        String result = WordUtils.wrap(input, 100);
        assertEquals(""String shorter than wrap length should not be wrapped"", ""short"", result);
    }

    @Test
    public void testWrap_StringWithTabs() {
        String input = ""Hello\tWorld"";
        String result = WordUtils.wrap(input, 5);
        assertNotNull(result);
        // Tabs are treated as characters, so wrapping may occur
        assertTrue(result.length() >= input.length());
    }

    @Test
    public void testWrap_StringWithMultipleLongWords() {
        String input = ""antidisestablishmentarianism pseudopseudohypoparathyroidism"";
        String result = WordUtils.wrap(input, 5);
        // According to javadoc, very long words will not be wrapped
        assertEquals(""Long words should not be wrapped"", input, result);
    }

    @Test
    public void testWrap_StringWithOnlySpaces() {
        String input = ""     "";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        // Should not throw, should return spaces (possibly with line breaks)
        assertTrue(result.trim().isEmpty());
    }

    @Test
    public void testWrap_WrapLengthIsNegative() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, -5);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthIsIntegerMaxValue() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, Integer.MAX_VALUE);
        assertEquals(""Wrap length is very large, should not wrap"", input, result);
    }

    @Test
    public void testWrap_WrapLengthIsIntegerMinValue() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, Integer.MIN_VALUE);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithUnicodeCharacters() {
        String input = ""你好 世界 こんにちは"";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        assertTrue(result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithNewLinesAndSpaces() {
        String input = ""Hello \n World"";
        String result = WordUtils.wrap(input, 3);
        assertNotNull(result);
        assertTrue(result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithSingleCharacter() {
        String input = ""a"";
        String result = WordUtils.wrap(input, 1);
        assertEquals(""Single character should not be wrapped"", ""a"", result);
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_wrap_java_lang_String_int_Test {

    @Test
    public void testWrap_NullInput() {
        String result = WordUtils.wrap(null, 10);
        assertNull(""Expected null when input string is null"", result);
    }

    @Test
    public void testWrap_EmptyString() {
        String result = WordUtils.wrap("""", 10);
        assertEquals(""Expected empty string when input is empty"", """", result);
    }

    @Test
    public void testWrap_WrapLengthLessThanOne() {
        String input = ""The quick brown fox"";
        String result = WordUtils.wrap(input, 0);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthOne() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, 1);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_ShortStringNoWrapNeeded() {
        String input = ""Hello"";
        String result = WordUtils.wrap(input, 10);
        assertEquals(""Short string should not be wrapped"", ""Hello"", result);
    }

    @Test
    public void testWrap_StringExactlyAtWrapLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6);
        assertEquals(""String at wrap length should not be wrapped"", ""abcdef"", result);
    }

    @Test
    public void testWrap_LongStringWithSpaces() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String result = WordUtils.wrap(input, 10);
        assertNotNull(result);
        String[] lines = result.split(System.getProperty(""line.separator""));
        for (String line : lines) {
            assertTrue(""Each line should be at most 10 characters"", line.length() <= 10);
        }
    }

    @Test
    public void testWrap_LongWordNoSpaces() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 5);
        // According to javadoc, very long words will not be wrapped
        assertEquals(""Long word without spaces should not be wrapped"", input, result);
    }

    @Test
    public void testWrap_MultipleSpaces() {
        String input = ""a  b   c"";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_LeadingAndTrailingSpaces() {
        String input = ""   Hello world   "";
        String result = WordUtils.wrap(input, 5);
        assertNotNull(result);
        String[] lines = result.split(System.getProperty(""line.separator""));
        // Leading spaces on new lines are stripped, trailing spaces are not
        for (int i = 1; i < lines.length; i++) {
            assertFalse(""Leading spaces on new lines should be stripped"", lines[i].startsWith("" ""));
        }
    }

    @Test
    public void testWrap_StringWithLineSeparators() {
        String input = ""Hello\nWorld"";
        String result = WordUtils.wrap(input, 3);
        assertNotNull(result);
        assertTrue(""Result should contain system line separator"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthGreaterThanStringLength() {
        String input = ""short"";
        String result = WordUtils.wrap(input, 100);
        assertEquals(""String shorter than wrap length should not be wrapped"", ""short"", result);
    }

    @Test
    public void testWrap_StringWithTabs() {
        String input = ""Hello\tWorld"";
        String result = WordUtils.wrap(input, 5);
        assertNotNull(result);
        // Tabs are treated as characters, so wrapping may occur
        assertTrue(result.length() >= input.length());
    }

    @Test
    public void testWrap_StringWithMultipleLongWords() {
        String input = ""antidisestablishmentarianism pseudopseudohypoparathyroidism"";
        String result = WordUtils.wrap(input, 5);
        // According to javadoc, very long words will not be wrapped
        assertEquals(""Long words should not be wrapped"", input, result);
    }

    @Test
    public void testWrap_StringWithOnlySpaces() {
        String input = ""     "";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        // Should not throw, should return spaces (possibly with line breaks)
        assertTrue(result.trim().isEmpty());
    }

    @Test
    public void testWrap_WrapLengthIsNegative() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, -5);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_WrapLengthIsIntegerMaxValue() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, Integer.MAX_VALUE);
        assertEquals(""Wrap length is very large, should not wrap"", input, result);
    }

    @Test
    public void testWrap_WrapLengthIsIntegerMinValue() {
        String input = ""abc def"";
        String result = WordUtils.wrap(input, Integer.MIN_VALUE);
        assertNotNull(result);
        assertTrue(""Result should contain line breaks"", result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithUnicodeCharacters() {
        String input = ""你好 世界 こんにちは"";
        String result = WordUtils.wrap(input, 2);
        assertNotNull(result);
        assertTrue(result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithNewLinesAndSpaces() {
        String input = ""Hello \n World"";
        String result = WordUtils.wrap(input, 3);
        assertNotNull(result);
        assertTrue(result.contains(System.getProperty(""line.separator"")));
    }

    @Test
    public void testWrap_StringWithSingleCharacter() {
        String input = ""a"";
        String result = WordUtils.wrap(input, 1);
        assertEquals(""Single character should not be wrapped"", ""a"", result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_wrap_java_lang_String_int_Test.java
"org.apache.commons.lang3.text.WordUtils.wrap(java.lang.String, int, java.lang.String, boolean)","java.lang.String wrap(java.lang.String,int,java.lang.String,boolean)",{\n    boolean wrapLongWords;\n    int wrapLength;\n    java.lang.String newLineStr; str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack15; $stack16; $stack17; $stack18; $stack19; $stack20; $stack8; $stack9; inputLineLength; offset; spaceToWrapAt; wrappedLine;\n\n\n    str := @parameter0: java.lang.String;\n    wrapLength := @parameter1: int;\n    newLineStr := @parameter2: java.lang.String;\n    wrapLongWords := @parameter3: boolean;\n\n    if str != null goto label01;\n\n    return null;\n\n  label01:\n    if newLineStr != null goto label02;\n    newLineStr = <org.apache.commons.lang3.SystemUtils: java.lang.String LINE_SEPARATOR>;\n\n  label02:\n    if wrapLength >= 1 goto label03;\n    wrapLength = 1;\n\n  label03:\n    inputLineLength = virtualinvoke str.<java.lang.String: int length()>();\n    offset = 0;\n    $stack9 = new java.lang.StringBuilder;\n    $stack8 = inputLineLength + 32;\n    specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\n    wrappedLine = $stack9;\n\n  label04:\n    $stack10 = inputLineLength - offset;\n\n    if $stack10 <= wrapLength goto label10;\n    $stack13 = virtualinvoke str.<java.lang.String: char charAt(int)>(offset);\n\n    if $stack13 != 32 goto label05;\n    offset = offset + 1;\n\n    goto label04;\n\n  label05:\n    $stack14 = wrapLength + offset;\n    spaceToWrapAt = virtualinvoke str.<java.lang.String: int lastIndexOf(int;int)>(32; $stack14);\n\n    if spaceToWrapAt < offset goto label06;\n    $stack20 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack20);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = spaceToWrapAt + 1;\n\n    goto label09;\n\n  label06:\n    if wrapLongWords == 0 goto label07;\n    $stack18 = wrapLength + offset;\n    $stack19 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; $stack18);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack19);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = offset + wrapLength;\n\n    goto label09;\n\n  label07:\n    $stack15 = wrapLength + offset;\n    spaceToWrapAt = virtualinvoke str.<java.lang.String: int indexOf(int;int)>(32; $stack15);\n\n    if spaceToWrapAt < 0 goto label08;\n    $stack17 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack17);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\n    offset = spaceToWrapAt + 1;\n\n    goto label09;\n\n  label08:\n    $stack16 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack16);\n    offset = inputLineLength;\n\n  label09:\n    goto label04;\n\n  label10:\n    $stack11 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\n    virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack11);\n    $stack12 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.String toString()>();\n\n    return $stack12;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int length()> via inputLineLength = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: void <init>(int)> via specialinvoke $stack9.<java.lang.StringBuilder: void <init>(int)>($stack8);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: char charAt(int)> via $stack13 = virtualinvoke str.<java.lang.String: char charAt(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int lastIndexOf(int;int)> via spaceToWrapAt = virtualinvoke str.<java.lang.String: int lastIndexOf(int;int)>(32; $stack14);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack20 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack20);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack19 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; $stack18);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack19);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: int indexOf(int;int)> via spaceToWrapAt = virtualinvoke str.<java.lang.String: int indexOf(int;int)>(32; $stack15);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int;int)> via $stack17 = virtualinvoke str.<java.lang.String: java.lang.String substring(int;int)>(offset; spaceToWrapAt);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack17);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(newLineStr);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int)> via $stack16 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack16);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.String: java.lang.String substring(int)> via $stack11 = virtualinvoke str.<java.lang.String: java.lang.String substring(int)>(offset);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)> via virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>($stack11);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <java.lang.StringBuilder: java.lang.String toString()> via $stack12 = virtualinvoke wrappedLine.<java.lang.StringBuilder: java.lang.String toString()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String wrap(java.lang.String;int;java.lang.String;boolean)> -> <org.apache.commons.lang3.SystemUtils: void <clinit>()> via newLineStr = <org.apache.commons.lang3.SystemUtils: java.lang.String LINE_SEPARATOR>;,[public ; static ],[public ],"<p>Wraps a single line of text; identifying words by <code>' '</code>.</p>\n\n<p>Leading spaces on a new line are stripped.\nTrailing spaces are not stripped.</p>\n\n<pre>\nWordUtils.wrap(null; *; *; *) = null\nWordUtils.wrap(""; *; *; *) = ""\n</pre>\n\n@param str the String to be word wrapped; may be null\n@param wrapLength the column to wrap the words at; less than 1 is treated as 1\n@param newLineStr the string to insert for a new line; \n <code>null</code> uses the system property line separator\n@param wrapLongWords true if long words (such as URLs) should be wrapped\n@return a line with newlines inserted; <code>null</code> if null input\n",{\n    if (str == null) {\n        return null;\n    }\n    if (newLineStr == null) {\n        newLineStr = SystemUtils.LINE_SEPARATOR;\n    }\n    if (wrapLength < 1) {\n        wrapLength = 1;\n    }\n    final int inputLineLength = str.length();\n    int offset = 0;\n    final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);\n    while (inputLineLength - offset > wrapLength) {\n        if (str.charAt(offset) == ' ') {\n            offset++;\n            continue;\n        }\n        int spaceToWrapAt = str.lastIndexOf(' '; wrapLength + offset);\n        if (spaceToWrapAt >= offset) {\n            // normal case\n            wrappedLine.append(str.substring(offset; spaceToWrapAt));\n            wrappedLine.append(newLineStr);\n            offset = spaceToWrapAt + 1;\n        } else {\n            // really long word or URL\n            if (wrapLongWords) {\n                // wrap really long word one line at a time\n                wrappedLine.append(str.substring(offset; wrapLength + offset));\n                wrappedLine.append(newLineStr);\n                offset += wrapLength;\n            } else {\n                // do not wrap really long word; just extend beyond limit\n                spaceToWrapAt = str.indexOf(' '; wrapLength + offset);\n                if (spaceToWrapAt >= 0) {\n                    wrappedLine.append(str.substring(offset; spaceToWrapAt));\n                    wrappedLine.append(newLineStr);\n                    offset = spaceToWrapAt + 1;\n                } else {\n                    wrappedLine.append(str.substring(offset));\n                    offset = inputLineLength;\n                }\n            }\n        }\n    }\n    // Whatever is left in line is short enough to just pass through\n    wrappedLine.append(str.substring(offset));\n    return wrappedLine.toString();\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_wrap_java_lang_String_int_java_lang_String_boolean_Test {

    // Test null input string returns null
    @Test
    public void testWrap_NullInput_ReturnsNull() {
        String result = WordUtils.wrap(null, 10, ""\n"", true);
        assertNull(result);
    }

    // Test empty string input returns empty string
    @Test
    public void testWrap_EmptyString_ReturnsEmptyString() {
        String result = WordUtils.wrap("""", 10, ""\n"", true);
        assertEquals("""", result);
    }

    // Test wrapLength less than 1 is treated as 1
    @Test
    public void testWrap_WrapLengthLessThanOne_TreatedAsOne() {
        String input = ""a b c"";
        String result = WordUtils.wrap(input, 0, ""\n"", true);
        // Each character should be on its own line except spaces
        assertEquals(""a\nb\nc"", result.replace("" "", """"));
    }

    // Test newLineStr is null, should use SystemUtils.LINE_SEPARATOR
    @Test
    public void testWrap_NewLineStrNull_UsesSystemLineSeparator() {
        String input = ""hello world"";
        String expected = ""hello"" + SystemUtils.LINE_SEPARATOR + ""world"";
        String result = WordUtils.wrap(input, 5, null, true);
        assertEquals(expected, result);
    }

    // Test wrapLongWords true, long word is split
    @Test
    public void testWrap_WrapLongWordsTrue_LongWordSplit() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        String[] lines = result.split(""\n"");
        for (String line : lines) {
            assertTrue(line.length() <= 10);
        }
        assertEquals(""supercalif\nragilistic\nexpialidoc\nious"", result);
    }

    // Test wrapLongWords false, long word is not split, extends beyond wrapLength
    @Test
    public void testWrap_WrapLongWordsFalse_LongWordNotSplit() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(""supercalifragilisticexpialidocious"", result);
    }

    // Test normal wrapping with spaces, wrapLongWords true
    @Test
    public void testWrap_NormalCase_WrapLongWordsTrue() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String expected = ""The quick\nbrown fox\njumps over\nthe lazy\ndog"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test normal wrapping with spaces, wrapLongWords false
    @Test
    public void testWrap_NormalCase_WrapLongWordsFalse() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String expected = ""The quick\nbrown fox\njumps over\nthe lazy\ndog"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with leading spaces, leading spaces on new line are stripped
    @Test
    public void testWrap_LeadingSpacesOnNewLineAreStripped() {
        String input = ""  The quick brown fox"";
        String expected = ""  The\nquick\nbrown fox"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with trailing spaces, trailing spaces are not stripped
    @Test
    public void testWrap_TrailingSpacesNotStripped() {
        String input = ""The quick "";
        String expected = ""The\nquick "";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with multiple consecutive spaces
    @Test
    public void testWrap_MultipleConsecutiveSpaces() {
        String input = ""The  quick   brown    fox"";
        String expected = ""The\nquick\nbrown\nfox"";
        String result = WordUtils.wrap(input, 5, ""\n"", true).replaceAll("" +"", """");
        assertEquals(expected.replaceAll("" +"", """"), result);
    }

    // Test input where a word is exactly the wrap length
    @Test
    public void testWrap_WordExactlyWrapLength() {
        String input = ""hello world"";
        String expected = ""hello\nworld"";
        String result = WordUtils.wrap(input, 5, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input where wrapLength is greater than input length
    @Test
    public void testWrap_WrapLengthGreaterThanInput() {
        String input = ""short"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(""short"", result);
    }

    // Test input with no spaces and wrapLongWords false (should not wrap)
    @Test
    public void testWrap_NoSpaces_WrapLongWordsFalse() {
        String input = ""abcdefghij"";
        String result = WordUtils.wrap(input, 3, ""\n"", false);
        assertEquals(""abcdefghij"", result);
    }

    // Test input with no spaces and wrapLongWords true (should wrap)
    @Test
    public void testWrap_NoSpaces_WrapLongWordsTrue() {
        String input = ""abcdefghij"";
        String expected = ""abc\ndef\nghi\nj"";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with only spaces
    @Test
    public void testWrap_OnlySpaces() {
        String input = ""     "";
        String result = WordUtils.wrap(input, 2, ""\n"", true);
        // Should return the same number of spaces
        assertEquals(""     "", result);
    }

    // Test input with wrapLength == 1
    @Test
    public void testWrap_WrapLengthOne() {
        String input = ""abc def"";
        String expected = ""a\nb\nc\nd\ne\nf"";
        String result = WordUtils.wrap(input, 1, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with wrapLength == input length
    @Test
    public void testWrap_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLength == 0 (should be treated as 1)
    @Test
    public void testWrap_WrapLengthZero() {
        String input = ""abc"";
        String expected = ""a\nb\nc"";
        String result = WordUtils.wrap(input, 0, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with wrapLength negative (should be treated as 1)
    @Test
    public void testWrap_WrapLengthNegative() {
        String input = ""abc"";
        String expected = ""a\nb\nc"";
        String result = WordUtils.wrap(input, -5, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with newLineStr as empty string
    @Test
    public void testWrap_NewLineStrEmptyString() {
        String input = ""hello world"";
        String expected = ""helloworld"";
        String result = WordUtils.wrap(input, 100, """", true);
        assertEquals(expected, result);
    }

    // Test input with Unicode and special characters
    @Test
    public void testWrap_UnicodeAndSpecialCharacters() {
        String input = ""héllo wørld 你好 世界"";
        String expected = ""héllo\nwørld\n你好\n世界"";
        String result = WordUtils.wrap(input, 5, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with a very long string
    @Test
    public void testWrap_VeryLongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertTrue(result.length() > 0);
        assertTrue(result.contains(""\n""));
    }

    // Test input with wrapLongWords true and word longer than wrapLength at the end
    @Test
    public void testWrap_WrapLongWordsTrue_LongWordAtEnd() {
        String input = ""short supercalifragilisticexpialidocious"";
        String expected = ""short\nsupercalif\nragilistic\nexpialidoc\nious"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and word longer than wrapLength at the end
    @Test
    public void testWrap_WrapLongWordsFalse_LongWordAtEnd() {
        String input = ""short supercalifragilisticexpialidocious"";
        String expected = ""short\nsupercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 5, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and wrapLength == 1
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthOne() {
        String input = ""abcdef"";
        String expected = ""a\nb\nc\nd\ne\nf"";
        String result = WordUtils.wrap(input, 1, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and wrapLength == 1
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthOne() {
        String input = ""abcdef"";
        String expected = ""abcdef"";
        String result = WordUtils.wrap(input, 1, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and wrapLength == input length
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords false and wrapLength == input length
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", false);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords true and wrapLength greater than input length
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthGreaterThanInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords false and wrapLength greater than input length
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthGreaterThanInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords true and wrapLength == 2
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthTwo() {
        String input = ""abcdef"";
        String expected = ""ab\ncd\nef"";
        String result = WordUtils.wrap(input, 2, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and wrapLength == 2
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthTwo() {
        String input = ""abcdef"";
        String expected = ""abcdef"";
        String result = WordUtils.wrap(input, 2, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and input contains tabs and newlines
    @Test
    public void testWrap_InputWithTabsAndNewlines() {
        String input = ""abc\tdef\nghi"";
        String expected = ""abc\tdef\nghi"";
        String result = WordUtils.wrap(input, 50, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and input contains only one word longer than wrapLength
    @Test
    public void testWrap_OneLongWordOnly_WrapLongWordsTrue() {
        String input = ""abcdefghij"";
        String expected = ""abc\ndef\nghi\nj"";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and input contains only one word longer than wrapLength
    @Test
    public void testWrap_OneLongWordOnly_WrapLongWordsFalse() {
        String input = ""abcdefghij"";
        String expected = ""abcdefghij"";
        String result = WordUtils.wrap(input, 3, ""\n"", false);
        assertEquals(expected, result);
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_wrap_java_lang_String_int_java_lang_String_boolean_Test {

    // Test null input string returns null
    @Test
    public void testWrap_NullInput_ReturnsNull() {
        String result = WordUtils.wrap(null, 10, ""\n"", true);
        assertNull(result);
    }

    // Test empty string input returns empty string
    @Test
    public void testWrap_EmptyString_ReturnsEmptyString() {
        String result = WordUtils.wrap("""", 10, ""\n"", true);
        assertEquals("""", result);
    }

    // Test wrapLength less than 1 is treated as 1
    @Test
    public void testWrap_WrapLengthLessThanOne_TreatedAsOne() {
        String input = ""a b c"";
        String result = WordUtils.wrap(input, 0, ""\n"", true);
        // Each character should be on its own line except spaces
        assertEquals(""a\nb\nc"", result.replace("" "", """"));
    }

    // Test newLineStr is null, should use SystemUtils.LINE_SEPARATOR
    @Test
    public void testWrap_NewLineStrNull_UsesSystemLineSeparator() {
        String input = ""hello world"";
        String expected = ""hello"" + SystemUtils.LINE_SEPARATOR + ""world"";
        String result = WordUtils.wrap(input, 5, null, true);
        assertEquals(expected, result);
    }

    // Test wrapLongWords true, long word is split
    @Test
    public void testWrap_WrapLongWordsTrue_LongWordSplit() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        String[] lines = result.split(""\n"");
        for (String line : lines) {
            assertTrue(line.length() <= 10);
        }
        assertEquals(""supercalif\nragilistic\nexpialidoc\nious"", result);
    }

    // Test wrapLongWords false, long word is not split, extends beyond wrapLength
    @Test
    public void testWrap_WrapLongWordsFalse_LongWordNotSplit() {
        String input = ""supercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(""supercalifragilisticexpialidocious"", result);
    }

    // Test normal wrapping with spaces, wrapLongWords true
    @Test
    public void testWrap_NormalCase_WrapLongWordsTrue() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String expected = ""The quick\nbrown fox\njumps over\nthe lazy\ndog"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test normal wrapping with spaces, wrapLongWords false
    @Test
    public void testWrap_NormalCase_WrapLongWordsFalse() {
        String input = ""The quick brown fox jumps over the lazy dog"";
        String expected = ""The quick\nbrown fox\njumps over\nthe lazy\ndog"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with leading spaces, leading spaces on new line are stripped
    @Test
    public void testWrap_LeadingSpacesOnNewLineAreStripped() {
        String input = ""  The quick brown fox"";
        String expected = ""  The\nquick\nbrown fox"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with trailing spaces, trailing spaces are not stripped
    @Test
    public void testWrap_TrailingSpacesNotStripped() {
        String input = ""The quick "";
        String expected = ""The\nquick "";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with multiple consecutive spaces
    @Test
    public void testWrap_MultipleConsecutiveSpaces() {
        String input = ""The  quick   brown    fox"";
        String expected = ""The\nquick\nbrown\nfox"";
        String result = WordUtils.wrap(input, 5, ""\n"", true).replaceAll("" +"", """");
        assertEquals(expected.replaceAll("" +"", """"), result);
    }

    // Test input where a word is exactly the wrap length
    @Test
    public void testWrap_WordExactlyWrapLength() {
        String input = ""hello world"";
        String expected = ""hello\nworld"";
        String result = WordUtils.wrap(input, 5, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input where wrapLength is greater than input length
    @Test
    public void testWrap_WrapLengthGreaterThanInput() {
        String input = ""short"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(""short"", result);
    }

    // Test input with no spaces and wrapLongWords false (should not wrap)
    @Test
    public void testWrap_NoSpaces_WrapLongWordsFalse() {
        String input = ""abcdefghij"";
        String result = WordUtils.wrap(input, 3, ""\n"", false);
        assertEquals(""abcdefghij"", result);
    }

    // Test input with no spaces and wrapLongWords true (should wrap)
    @Test
    public void testWrap_NoSpaces_WrapLongWordsTrue() {
        String input = ""abcdefghij"";
        String expected = ""abc\ndef\nghi\nj"";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with only spaces
    @Test
    public void testWrap_OnlySpaces() {
        String input = ""     "";
        String result = WordUtils.wrap(input, 2, ""\n"", true);
        // Should return the same number of spaces
        assertEquals(""     "", result);
    }

    // Test input with wrapLength == 1
    @Test
    public void testWrap_WrapLengthOne() {
        String input = ""abc def"";
        String expected = ""a\nb\nc\nd\ne\nf"";
        String result = WordUtils.wrap(input, 1, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with wrapLength == input length
    @Test
    public void testWrap_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLength == 0 (should be treated as 1)
    @Test
    public void testWrap_WrapLengthZero() {
        String input = ""abc"";
        String expected = ""a\nb\nc"";
        String result = WordUtils.wrap(input, 0, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with wrapLength negative (should be treated as 1)
    @Test
    public void testWrap_WrapLengthNegative() {
        String input = ""abc"";
        String expected = ""a\nb\nc"";
        String result = WordUtils.wrap(input, -5, ""\n"", true).replace("" "", """");
        assertEquals(expected.replace("" "", """"), result);
    }

    // Test input with newLineStr as empty string
    @Test
    public void testWrap_NewLineStrEmptyString() {
        String input = ""hello world"";
        String expected = ""helloworld"";
        String result = WordUtils.wrap(input, 100, """", true);
        assertEquals(expected, result);
    }

    // Test input with Unicode and special characters
    @Test
    public void testWrap_UnicodeAndSpecialCharacters() {
        String input = ""héllo wørld 你好 世界"";
        String expected = ""héllo\nwørld\n你好\n世界"";
        String result = WordUtils.wrap(input, 5, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with a very long string
    @Test
    public void testWrap_VeryLongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertTrue(result.length() > 0);
        assertTrue(result.contains(""\n""));
    }

    // Test input with wrapLongWords true and word longer than wrapLength at the end
    @Test
    public void testWrap_WrapLongWordsTrue_LongWordAtEnd() {
        String input = ""short supercalifragilisticexpialidocious"";
        String expected = ""short\nsupercalif\nragilistic\nexpialidoc\nious"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and word longer than wrapLength at the end
    @Test
    public void testWrap_WrapLongWordsFalse_LongWordAtEnd() {
        String input = ""short supercalifragilisticexpialidocious"";
        String expected = ""short\nsupercalifragilisticexpialidocious"";
        String result = WordUtils.wrap(input, 5, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and wrapLength == 1
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthOne() {
        String input = ""abcdef"";
        String expected = ""a\nb\nc\nd\ne\nf"";
        String result = WordUtils.wrap(input, 1, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and wrapLength == 1
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthOne() {
        String input = ""abcdef"";
        String expected = ""abcdef"";
        String result = WordUtils.wrap(input, 1, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and wrapLength == input length
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords false and wrapLength == input length
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthEqualsInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 6, ""\n"", false);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords true and wrapLength greater than input length
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthGreaterThanInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 10, ""\n"", true);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords false and wrapLength greater than input length
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthGreaterThanInputLength() {
        String input = ""abcdef"";
        String result = WordUtils.wrap(input, 10, ""\n"", false);
        assertEquals(""abcdef"", result);
    }

    // Test input with wrapLongWords true and wrapLength == 2
    @Test
    public void testWrap_WrapLongWordsTrue_WrapLengthTwo() {
        String input = ""abcdef"";
        String expected = ""ab\ncd\nef"";
        String result = WordUtils.wrap(input, 2, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and wrapLength == 2
    @Test
    public void testWrap_WrapLongWordsFalse_WrapLengthTwo() {
        String input = ""abcdef"";
        String expected = ""abcdef"";
        String result = WordUtils.wrap(input, 2, ""\n"", false);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and input contains tabs and newlines
    @Test
    public void testWrap_InputWithTabsAndNewlines() {
        String input = ""abc\tdef\nghi"";
        String expected = ""abc\tdef\nghi"";
        String result = WordUtils.wrap(input, 50, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords true and input contains only one word longer than wrapLength
    @Test
    public void testWrap_OneLongWordOnly_WrapLongWordsTrue() {
        String input = ""abcdefghij"";
        String expected = ""abc\ndef\nghi\nj"";
        String result = WordUtils.wrap(input, 3, ""\n"", true);
        assertEquals(expected, result);
    }

    // Test input with wrapLongWords false and input contains only one word longer than wrapLength
    @Test
    public void testWrap_OneLongWordOnly_WrapLongWordsFalse() {
        String input = ""abcdefghij"";
        String expected = ""abcdefghij"";
        String result = WordUtils.wrap(input, 3, ""\n"", false);
        assertEquals(expected, result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_wrap_java_lang_String_int_java_lang_String_boolean_Test.java
org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String),java.lang.String capitalize(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Capitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed. To convert the \nrest of each word to lowercase at the same time; \nuse {@link #capitalizeFully(String)}.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalize(null)        = null\nWordUtils.capitalize("")          = ""\nWordUtils.capitalize(i am FINE"") = ""I Am FINE""\n</pre>\n\n@param str the String to capitalize; may be null\n@return capitalized String; <code>null</code> if null String input\n@see #uncapitalize(String)\n@see #capitalizeFully(String)\n""",{\n    return capitalize(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalize_String_Test {

    @Test
    public void testCapitalize_NullInput() {
        assertNull(WordUtils.capitalize((String) null));
    }

    @Test
    public void testCapitalize_EmptyString() {
        assertEquals("""", WordUtils.capitalize(""""));
    }

    @Test
    public void testCapitalize_SingleLowercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalize(""hello""));
    }

    @Test
    public void testCapitalize_SingleUppercaseWord() {
        assertEquals(""HELLO"", WordUtils.capitalize(""HELLO""));
    }

    @Test
    public void testCapitalize_SingleMixedCaseWord() {
        assertEquals(""Hello"", WordUtils.capitalize(""hELLO""));
    }

    @Test
    public void testCapitalize_MultipleWords_MixedCase() {
        assertEquals(""I Am FINE"", WordUtils.capitalize(""i am FINE""));
    }

    @Test
    public void testCapitalize_MultipleWords_AllLowercase() {
        assertEquals(""Hello World"", WordUtils.capitalize(""hello world""));
    }

    @Test
    public void testCapitalize_MultipleWords_AllUppercase() {
        assertEquals(""HELLO WORLD"", WordUtils.capitalize(""HELLO WORLD""));
    }

    @Test
    public void testCapitalize_MultipleWords_MixedWhitespace() {
        assertEquals(""Hello   World"", WordUtils.capitalize(""hello   world""));
    }

    @Test
    public void testCapitalize_LeadingAndTrailingWhitespace() {
        assertEquals("" Hello World "", WordUtils.capitalize("" hello world ""));
    }

    @Test
    public void testCapitalize_TabAndNewlineWhitespace() {
        assertEquals(""Hello\tWorld\nTest"", WordUtils.capitalize(""hello\tworld\ntest""));
    }

    @Test
    public void testCapitalize_SingleCharacter() {
        assertEquals(""A"", WordUtils.capitalize(""a""));
    }

    @Test
    public void testCapitalize_SingleWhitespace() {
        assertEquals("" "", WordUtils.capitalize("" ""));
    }

    @Test
    public void testCapitalize_AlreadyCapitalized() {
        assertEquals(""Hello World"", WordUtils.capitalize(""Hello World""));
    }

    @Test
    public void testCapitalize_NonLetterCharacters() {
        assertEquals(""123abc !@#"", WordUtils.capitalize(""123abc !@#""));
    }

    @Test
    public void testCapitalize_MixedUnicode() {
        assertEquals(""Éclair Über"", WordUtils.capitalize(""éclair über""));
    }

    @Test
    public void testCapitalize_UnicodeWhitespace() {
        String input = ""hello\u2003world""; // EM SPACE
        String expected = ""Hello\u2003World"";
        assertEquals(expected, WordUtils.capitalize(input));
    }

    @Test
    public void testCapitalize_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String expected = input.replaceAll(""\\b(\\w)"", m -> m.group(1).toUpperCase());
        // Since WordUtils.capitalize only capitalizes first letter of each word, rest remains as is
        String result = WordUtils.capitalize(input);
        String[] words = input.split(""\\s"");
        StringBuilder expectedBuilder = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            if (words[i].length() > 0) {
                expectedBuilder.append(Character.toUpperCase(words[i].charAt(0)));
                if (words[i].length() > 1) {
                    expectedBuilder.append(words[i].substring(1));
                }
            }
            if (i < words.length - 1) {
                expectedBuilder.append("" "");
            }
        }
        assertEquals(expectedBuilder.toString(), result);
    }

    @Test
    public void testCapitalize_OnlyWhitespace() {
        assertEquals(""   "", WordUtils.capitalize(""   ""));
    }

    @Test
    public void testCapitalize_SpecialCharactersBetweenWords() {
        assertEquals(""Hello-World"", WordUtils.capitalize(""hello-world""));
    }

    @Test
    public void testCapitalize_WordsWithApostrophes() {
        assertEquals(""O'Connor Mc'Donald"", WordUtils.capitalize(""o'connor mc'donald""));
    }

    @Test
    public void testCapitalize_WordsWithNumbers() {
        assertEquals(""Test123 Case456"", WordUtils.capitalize(""test123 case456""));
    }

    @Test
    public void testCapitalize_WordsWithMixedSeparators() {
        assertEquals(""Hello\tWorld-Test"", WordUtils.capitalize(""hello\tworld-test""));
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalize_String_Test {

    @Test
    public void testCapitalize_NullInput() {
        assertNull(WordUtils.capitalize((String) null));
    }

    @Test
    public void testCapitalize_EmptyString() {
        assertEquals("""", WordUtils.capitalize(""""));
    }

    @Test
    public void testCapitalize_SingleLowercaseWord() {
        assertEquals(""Hello"", WordUtils.capitalize(""hello""));
    }

    @Test
    public void testCapitalize_SingleUppercaseWord() {
        assertEquals(""HELLO"", WordUtils.capitalize(""HELLO""));
    }

    @Test
    public void testCapitalize_SingleMixedCaseWord() {
        assertEquals(""Hello"", WordUtils.capitalize(""hELLO""));
    }

    @Test
    public void testCapitalize_MultipleWords_MixedCase() {
        assertEquals(""I Am FINE"", WordUtils.capitalize(""i am FINE""));
    }

    @Test
    public void testCapitalize_MultipleWords_AllLowercase() {
        assertEquals(""Hello World"", WordUtils.capitalize(""hello world""));
    }

    @Test
    public void testCapitalize_MultipleWords_AllUppercase() {
        assertEquals(""HELLO WORLD"", WordUtils.capitalize(""HELLO WORLD""));
    }

    @Test
    public void testCapitalize_MultipleWords_MixedWhitespace() {
        assertEquals(""Hello   World"", WordUtils.capitalize(""hello   world""));
    }

    @Test
    public void testCapitalize_LeadingAndTrailingWhitespace() {
        assertEquals("" Hello World "", WordUtils.capitalize("" hello world ""));
    }

    @Test
    public void testCapitalize_TabAndNewlineWhitespace() {
        assertEquals(""Hello\tWorld\nTest"", WordUtils.capitalize(""hello\tworld\ntest""));
    }

    @Test
    public void testCapitalize_SingleCharacter() {
        assertEquals(""A"", WordUtils.capitalize(""a""));
    }

    @Test
    public void testCapitalize_SingleWhitespace() {
        assertEquals("" "", WordUtils.capitalize("" ""));
    }

    @Test
    public void testCapitalize_AlreadyCapitalized() {
        assertEquals(""Hello World"", WordUtils.capitalize(""Hello World""));
    }

    @Test
    public void testCapitalize_NonLetterCharacters() {
        assertEquals(""123abc !@#"", WordUtils.capitalize(""123abc !@#""));
    }

    @Test
    public void testCapitalize_MixedUnicode() {
        assertEquals(""Éclair Über"", WordUtils.capitalize(""éclair über""));
    }

    @Test
    public void testCapitalize_UnicodeWhitespace() {
        String input = ""hello\u2003world""; // EM SPACE
        String expected = ""Hello\u2003World"";
        assertEquals(expected, WordUtils.capitalize(input));
    }

    @Test
    public void testCapitalize_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String expected = input.replaceAll(""\\b(\\w)"", m -> m.group(1).toUpperCase());
        // Since WordUtils.capitalize only capitalizes first letter of each word, rest remains as is
        String result = WordUtils.capitalize(input);
        String[] words = input.split(""\\s"");
        StringBuilder expectedBuilder = new StringBuilder();
        for (int i = 0; i < words.length; i++) {
            if (words[i].length() > 0) {
                expectedBuilder.append(Character.toUpperCase(words[i].charAt(0)));
                if (words[i].length() > 1) {
                    expectedBuilder.append(words[i].substring(1));
                }
            }
            if (i < words.length - 1) {
                expectedBuilder.append("" "");
            }
        }
        assertEquals(expectedBuilder.toString(), result);
    }

    @Test
    public void testCapitalize_OnlyWhitespace() {
        assertEquals(""   "", WordUtils.capitalize(""   ""));
    }

    @Test
    public void testCapitalize_SpecialCharactersBetweenWords() {
        assertEquals(""Hello-World"", WordUtils.capitalize(""hello-world""));
    }

    @Test
    public void testCapitalize_WordsWithApostrophes() {
        assertEquals(""O'Connor Mc'Donald"", WordUtils.capitalize(""o'connor mc'donald""));
    }

    @Test
    public void testCapitalize_WordsWithNumbers() {
        assertEquals(""Test123 Case456"", WordUtils.capitalize(""test123 case456""));
    }

    @Test
    public void testCapitalize_WordsWithMixedSeparators() {
        assertEquals(""Hello\tWorld-Test"", WordUtils.capitalize(""hello\tworld-test""));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_capitalize_String_Test.java
org.apache.commons.lang3.text.WordUtils.initials(java.lang.String),java.lang.String initials(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Extracts the initial letters from each word in the String.</p>\n\n<p>The first letter of the string and all first letters after\nwhitespace are returned as a new string.\nTheir case is not changed.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.initials(null)             = null\nWordUtils.initials("")               = ""\nWordUtils.initials(Ben John Lee"")   = ""BJL""\nWordUtils.initials(""Ben J.Lee"")      = ""BJ""\n</pre>\n\n@param str the String to get initials from; may be null\n@return String of initial letters; <code>null</code> if null String input\n@see #initials(String;char[])\n@since 2.2\n""",{\n    return initials(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_initials_String_Test {

    @Test
    public void testInitials_NullInput() {
        assertNull(WordUtils.initials((String) null));
    }

    @Test
    public void testInitials_EmptyString() {
        assertEquals("""", WordUtils.initials(""""));
    }

    @Test
    public void testInitials_SingleWord() {
        assertEquals(""B"", WordUtils.initials(""Ben""));
        assertEquals(""A"", WordUtils.initials(""A""));
        assertEquals(""1"", WordUtils.initials(""1""));
        assertEquals(""!"", WordUtils.initials(""!""));
    }

    @Test
    public void testInitials_MultipleWords_Simple() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee""));
        assertEquals(""BJ"", WordUtils.initials("" Ben J.Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben  J.Lee""));
    }

    @Test
    public void testInitials_MultipleWords_WithWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""  Ben   John   Lee  ""));
        assertEquals(""BJL"", WordUtils.initials(""\tBen\tJohn\tLee\t""));
        assertEquals(""BJL"", WordUtils.initials(""\nBen\nJohn\nLee\n""));
        assertEquals(""BJL"", WordUtils.initials(""Ben\nJohn\tLee""));
    }

    @Test
    public void testInitials_MixedSeparators() {
        assertEquals(""BJL"", WordUtils.initials("" Ben\tJohn\nLee ""));
        assertEquals(""BJL"", WordUtils.initials(""Ben  John\tLee""));
    }

    @Test
    public void testInitials_OnlyWhitespace() {
        assertEquals("""", WordUtils.initials("" ""));
        assertEquals("""", WordUtils.initials(""\t""));
        assertEquals("""", WordUtils.initials(""\n""));
        assertEquals("""", WordUtils.initials(""   \t\n  ""));
    }

    @Test
    public void testInitials_PunctuationAndSymbols() {
        assertEquals(""BJL"", WordUtils.initials(""Ben, John! Lee?""));
        assertEquals(""BJL"", WordUtils.initials(""Ben.John.Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben-John-Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben/John\\Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben@John#Lee$""));
    }

    @Test
    public void testInitials_UnicodeWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\u2003John\u2009Lee"")); // em space, thin space
        assertEquals(""BJL"", WordUtils.initials(""Ben\u00A0John\u202FLee"")); // non-breaking space, narrow no-break space
    }

    @Test
    public void testInitials_LeadingAndTrailingWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""   Ben John Lee   ""));
        assertEquals(""BJL"", WordUtils.initials(""\tBen John Lee\n""));
    }

    @Test
    public void testInitials_MultipleConsecutiveWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben   John    Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben\t\tJohn\t\tLee""));
    }

    @Test
    public void testInitials_WordsWithInternalDots() {
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben.J.Lee""));
    }

    @Test
    public void testInitials_WordsWithApostrophes() {
        assertEquals(""BO"", WordUtils.initials(""Ben O'Connor""));
        assertEquals(""BOD"", WordUtils.initials(""Ben O'Donald""));
    }

    @Test
    public void testInitials_WordsWithHyphens() {
        assertEquals(""BJ"", WordUtils.initials(""Ben-John""));
        assertEquals(""BJL"", WordUtils.initials(""Ben-John Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben-J.Lee""));
    }

    @Test
    public void testInitials_NonLatinCharacters() {
        assertEquals(""ПС"", WordUtils.initials(""Петр Сергеевич""));
        assertEquals(""张三"", WordUtils.initials(""张 三""));
        assertEquals(""山田太"", WordUtils.initials(""山田 太郎""));
    }

    @Test
    public void testInitials_LongString() {
        StringBuilder sb = new StringBuilder();
        StringBuilder expected = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word"").append(i).append("" "");
            expected.append(""W"");
        }
        assertEquals(expected.toString(), WordUtils.initials(sb.toString().trim()));
    }

    @Test
    public void testInitials_StringWithNoWords() {
        assertEquals("""", WordUtils.initials(""     ""));
        assertEquals("""", WordUtils.initials(""\t\t\t""));
        assertEquals("""", WordUtils.initials(""\n\n\n""));
    }

    @Test
    public void testInitials_SingleCharacterWords() {
        assertEquals(""ABC"", WordUtils.initials(""A B C""));
        assertEquals(""A"", WordUtils.initials(""A""));
    }

    @Test
    public void testInitials_WordsWithNumbers() {
        assertEquals(""B1L"", WordUtils.initials(""Ben 1 Lee""));
        assertEquals(""123"", WordUtils.initials(""1 2 3""));
    }

    @Test
    public void testInitials_WordsWithMixedCase() {
        assertEquals(""BJL"", WordUtils.initials(""ben JOHN lee""));
        assertEquals(""BJL"", WordUtils.initials(""BEN john LEE""));
    }
}
```","package org.apache.commons.lang3.text;

import org.junit.Test;
import static org.junit.Assert.*;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

public class WordUtils_initials_String_Test {

    @Test
    public void testInitials_NullInput() {
        assertNull(WordUtils.initials((String) null));
    }

    @Test
    public void testInitials_EmptyString() {
        assertEquals("""", WordUtils.initials(""""));
    }

    @Test
    public void testInitials_SingleWord() {
        assertEquals(""B"", WordUtils.initials(""Ben""));
        assertEquals(""A"", WordUtils.initials(""A""));
        assertEquals(""1"", WordUtils.initials(""1""));
        assertEquals(""!"", WordUtils.initials(""!""));
    }

    @Test
    public void testInitials_MultipleWords_Simple() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee""));
        assertEquals(""BJ"", WordUtils.initials("" Ben J.Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben  J.Lee""));
    }

    @Test
    public void testInitials_MultipleWords_WithWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""  Ben   John   Lee  ""));
        assertEquals(""BJL"", WordUtils.initials(""\tBen\tJohn\tLee\t""));
        assertEquals(""BJL"", WordUtils.initials(""\nBen\nJohn\nLee\n""));
        assertEquals(""BJL"", WordUtils.initials(""Ben\nJohn\tLee""));
    }

    @Test
    public void testInitials_MixedSeparators() {
        assertEquals(""BJL"", WordUtils.initials("" Ben\tJohn\nLee ""));
        assertEquals(""BJL"", WordUtils.initials(""Ben  John\tLee""));
    }

    @Test
    public void testInitials_OnlyWhitespace() {
        assertEquals("""", WordUtils.initials("" ""));
        assertEquals("""", WordUtils.initials(""\t""));
        assertEquals("""", WordUtils.initials(""\n""));
        assertEquals("""", WordUtils.initials(""   \t\n  ""));
    }

    @Test
    public void testInitials_PunctuationAndSymbols() {
        assertEquals(""BJL"", WordUtils.initials(""Ben, John! Lee?""));
        assertEquals(""BJL"", WordUtils.initials(""Ben.John.Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben-John-Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben/John\\Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben@John#Lee$""));
    }

    @Test
    public void testInitials_UnicodeWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\u2003John\u2009Lee"")); // em space, thin space
        assertEquals(""BJL"", WordUtils.initials(""Ben\u00A0John\u202FLee"")); // non-breaking space, narrow no-break space
    }

    @Test
    public void testInitials_LeadingAndTrailingWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""   Ben John Lee   ""));
        assertEquals(""BJL"", WordUtils.initials(""\tBen John Lee\n""));
    }

    @Test
    public void testInitials_MultipleConsecutiveWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben   John    Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben\t\tJohn\t\tLee""));
    }

    @Test
    public void testInitials_WordsWithInternalDots() {
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee""));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben.J.Lee""));
    }

    @Test
    public void testInitials_WordsWithApostrophes() {
        assertEquals(""BO"", WordUtils.initials(""Ben O'Connor""));
        assertEquals(""BOD"", WordUtils.initials(""Ben O'Donald""));
    }

    @Test
    public void testInitials_WordsWithHyphens() {
        assertEquals(""BJ"", WordUtils.initials(""Ben-John""));
        assertEquals(""BJL"", WordUtils.initials(""Ben-John Lee""));
        assertEquals(""BJ"", WordUtils.initials(""Ben-J.Lee""));
    }

    @Test
    public void testInitials_NonLatinCharacters() {
        assertEquals(""ПС"", WordUtils.initials(""Петр Сергеевич""));
        assertEquals(""张三"", WordUtils.initials(""张 三""));
        assertEquals(""山田太"", WordUtils.initials(""山田 太郎""));
    }

    @Test
    public void testInitials_LongString() {
        StringBuilder sb = new StringBuilder();
        StringBuilder expected = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word"").append(i).append("" "");
            expected.append(""W"");
        }
        assertEquals(expected.toString(), WordUtils.initials(sb.toString().trim()));
    }

    @Test
    public void testInitials_StringWithNoWords() {
        assertEquals("""", WordUtils.initials(""     ""));
        assertEquals("""", WordUtils.initials(""\t\t\t""));
        assertEquals("""", WordUtils.initials(""\n\n\n""));
    }

    @Test
    public void testInitials_SingleCharacterWords() {
        assertEquals(""ABC"", WordUtils.initials(""A B C""));
        assertEquals(""A"", WordUtils.initials(""A""));
    }

    @Test
    public void testInitials_WordsWithNumbers() {
        assertEquals(""B1L"", WordUtils.initials(""Ben 1 Lee""));
        assertEquals(""123"", WordUtils.initials(""1 2 3""));
    }

    @Test
    public void testInitials_WordsWithMixedCase() {
        assertEquals(""BJL"", WordUtils.initials(""ben JOHN lee""));
        assertEquals(""BJL"", WordUtils.initials(""BEN john LEE""));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_initials_String_Test.java
"org.apache.commons.lang3.text.WordUtils.capitalize(java.lang.String, char[])","java.lang.String capitalize(java.lang.String,char[])",{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack7; $stack8; $stack9; buffer; capitalizeNext; ch; delimLen; i;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n\n    if delimiters != null goto label1;\n    delimLen = -1;\n\n    goto label2;\n\n  label1:\n    delimLen = lengthof delimiters;\n\n  label2:\n    $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack7 != 0 goto label3;\n\n    if delimLen != 0 goto label4;\n\n  label3:\n    return str;\n\n  label4:\n    buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\n    capitalizeNext = 1;\n    i = 0;\n\n  label5:\n    $stack8 = lengthof buffer;\n\n    if i >= $stack8 goto label8;\n    ch = buffer[i];\n    $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack10 == 0 goto label6;\n    capitalizeNext = 1;\n\n    goto label7;\n\n  label6:\n    if capitalizeNext == 0 goto label7;\n    $stack11 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\n    buffer[i] = $stack11;\n    capitalizeNext = 0;\n\n  label7:\n    i = i + 1;\n\n    goto label5;\n\n  label8:\n    $stack9 = new java.lang.String;\n    specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\n\n    return $stack9;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.String: char[] toCharArray()> via buffer = virtualinvoke str.<java.lang.String: char[] toCharArray()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack10 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.Character: char toTitleCase(char)> via $stack11 = staticinvoke <java.lang.Character: char toTitleCase(char)>(ch);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <java.lang.String: void <init>(char[])> via specialinvoke $stack9.<java.lang.String: void <init>(char[])>(buffer);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String capitalize(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack7 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Capitalizes all the delimiter separated words in a String.\nOnly the first letter of each word is changed. To convert the \nrest of each word to lowercase at the same time; \nuse {@link #capitalizeFully(String; char[])}.</p>\n\n<p>The delimiters represent a set of characters understood to separate words.\nThe first string character and the first non-delimiter character after a\ndelimiter will be capitalized. </p>\n\n<p>A <code>null</code> input String returns <code>null</code>.\nCapitalization uses the Unicode title case; normally equivalent to\nupper case.</p>\n\n<pre>\nWordUtils.capitalize(null; *)            = null\nWordUtils.capitalize(""; *)              = ""\nWordUtils.capitalize(*; new char[0])     = *\nWordUtils.capitalize(i am fine""; null)  = ""I Am Fine""\nWordUtils.capitalize(""i aM.fine""; {'.'}) = ""I aM.Fine""\n</pre>\n\n@param str the String to capitalize; may be null\n@param delimiters set of characters to determine capitalization; null means whitespace\n@return capitalized String; <code>null</code> if null String input\n@see #uncapitalize(String)\n@see #capitalizeFully(String)\n@since 2.1\n""",{\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch; delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalize_java_lang_String_charARRAY_Test {

    @Test
    public void testCapitalize_NullString_NullDelimiters() {
        String result = WordUtils.capitalize(null, null);
        assertNull(result);
    }

    @Test
    public void testCapitalize_EmptyString_NullDelimiters() {
        String result = WordUtils.capitalize("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testCapitalize_EmptyString_EmptyDelimiters() {
        String result = WordUtils.capitalize("""", new char[0]);
        assertEquals("""", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_EmptyDelimiters() {
        String input = ""hello world"";
        char[] delimiters = new char[0];
        String result = WordUtils.capitalize(input, delimiters);
        // Should return the original string as per Javadoc and code
        assertEquals(input, result);
    }

    @Test
    public void testCapitalize_NonEmptyString_NullDelimiters() {
        String input = ""i am fine"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""I Am Fine"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_SingleDelimiter() {
        String input = ""i aM.fine"";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""I aM.Fine"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_MultipleDelimiters() {
        String input = ""hello-world_foo"";
        char[] delimiters = {'-', '_'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Hello-World_Foo"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_WhitespaceDelimiters() {
        String input = ""java\tunit test\nexample"";
        char[] delimiters = {' ', '\t', '\n'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Java\tUnit Test\nExample"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_DelimiterAtStartAndEnd() {
        String input = "".hello.world."";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals("".Hello.World."", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_AllDelimiters() {
        String input = ""...."";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""...."", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_NoDelimitersPresent() {
        String input = ""foobar"";
        char[] delimiters = {'-'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foobar"", result);
    }

    @Test
    public void testCapitalize_SingleCharacterString() {
        String input = ""a"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""A"", result);
    }

    @Test
    public void testCapitalize_StringWithNumbersAndSymbols() {
        String input = ""123abc!def"";
        char[] delimiters = {'!'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""123abc!Def"", result);
    }

    @Test
    public void testCapitalize_StringWithUnicodeCharacters() {
        String input = ""élève école"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""Élève École"", result);
    }

    @Test
    public void testCapitalize_StringWithMixedCase() {
        String input = ""hELLo wORLD"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""HELLo WORLD"", result);
    }

    @Test
    public void testCapitalize_StringWithConsecutiveDelimiters() {
        String input = ""foo--bar"";
        char[] delimiters = {'-'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo--Bar"", result);
    }

    @Test
    public void testCapitalize_StringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00 smile""; // 😀 smile
        String result = WordUtils.capitalize(input, null);
        assertEquals(""\uD83D\uDE00 Smile"", result);
    }

    @Test
    public void testCapitalize_DelimitersIncludeWhitespace() {
        String input = ""foo bar\tbaz"";
        char[] delimiters = {' ', '\t'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo Bar\tBaz"", result);
    }

    @Test
    public void testCapitalize_DelimiterIsUppercaseLetter() {
        String input = ""fooAbarAbaz"";
        char[] delimiters = {'A'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""FooABarABaz"", result);
    }

    @Test
    public void testCapitalize_StringWithOnlyDelimiters() {
        String input = ""   "";
        char[] delimiters = {' '};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""   "", result);
    }

    @Test
    public void testCapitalize_StringWithNullCharDelimiter() {
        String input = ""foo\u0000bar"";
        char[] delimiters = {'\u0000'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo\u0000Bar"", result);
    }

    @Test
    public void testCapitalize_StringWithLongLength() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.capitalize(input, null);
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(Character.isUpperCase(word.charAt(0)));
        }
    }

    @Test
    public void testCapitalize_NullDelimitersWithSpecialChars() {
        String input = ""foo-bar_baz"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""Foo-Bar_Baz"", result);
    }

    @Test
    public void testCapitalize_DelimitersWithNoMatch() {
        String input = ""foo bar"";
        char[] delimiters = {'x', 'y', 'z'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo bar"", result);
    }

    @Test
    public void testCapitalize_DelimitersWithAllMatch() {
        String input = ""abc"";
        char[] delimiters = {'a', 'b', 'c'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Abc"", result);
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_capitalize_java_lang_String_charARRAY_Test {

    @Test
    public void testCapitalize_NullString_NullDelimiters() {
        String result = WordUtils.capitalize(null, null);
        assertNull(result);
    }

    @Test
    public void testCapitalize_EmptyString_NullDelimiters() {
        String result = WordUtils.capitalize("""", null);
        assertEquals("""", result);
    }

    @Test
    public void testCapitalize_EmptyString_EmptyDelimiters() {
        String result = WordUtils.capitalize("""", new char[0]);
        assertEquals("""", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_EmptyDelimiters() {
        String input = ""hello world"";
        char[] delimiters = new char[0];
        String result = WordUtils.capitalize(input, delimiters);
        // Should return the original string as per Javadoc and code
        assertEquals(input, result);
    }

    @Test
    public void testCapitalize_NonEmptyString_NullDelimiters() {
        String input = ""i am fine"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""I Am Fine"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_SingleDelimiter() {
        String input = ""i aM.fine"";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""I aM.Fine"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_MultipleDelimiters() {
        String input = ""hello-world_foo"";
        char[] delimiters = {'-', '_'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Hello-World_Foo"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_WhitespaceDelimiters() {
        String input = ""java\tunit test\nexample"";
        char[] delimiters = {' ', '\t', '\n'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Java\tUnit Test\nExample"", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_DelimiterAtStartAndEnd() {
        String input = "".hello.world."";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals("".Hello.World."", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_AllDelimiters() {
        String input = ""...."";
        char[] delimiters = {'.'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""...."", result);
    }

    @Test
    public void testCapitalize_NonEmptyString_NoDelimitersPresent() {
        String input = ""foobar"";
        char[] delimiters = {'-'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foobar"", result);
    }

    @Test
    public void testCapitalize_SingleCharacterString() {
        String input = ""a"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""A"", result);
    }

    @Test
    public void testCapitalize_StringWithNumbersAndSymbols() {
        String input = ""123abc!def"";
        char[] delimiters = {'!'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""123abc!Def"", result);
    }

    @Test
    public void testCapitalize_StringWithUnicodeCharacters() {
        String input = ""élève école"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""Élève École"", result);
    }

    @Test
    public void testCapitalize_StringWithMixedCase() {
        String input = ""hELLo wORLD"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""HELLo WORLD"", result);
    }

    @Test
    public void testCapitalize_StringWithConsecutiveDelimiters() {
        String input = ""foo--bar"";
        char[] delimiters = {'-'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo--Bar"", result);
    }

    @Test
    public void testCapitalize_StringWithSurrogatePairs() {
        String input = ""\uD83D\uDE00 smile""; // 😀 smile
        String result = WordUtils.capitalize(input, null);
        assertEquals(""\uD83D\uDE00 Smile"", result);
    }

    @Test
    public void testCapitalize_DelimitersIncludeWhitespace() {
        String input = ""foo bar\tbaz"";
        char[] delimiters = {' ', '\t'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo Bar\tBaz"", result);
    }

    @Test
    public void testCapitalize_DelimiterIsUppercaseLetter() {
        String input = ""fooAbarAbaz"";
        char[] delimiters = {'A'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""FooABarABaz"", result);
    }

    @Test
    public void testCapitalize_StringWithOnlyDelimiters() {
        String input = ""   "";
        char[] delimiters = {' '};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""   "", result);
    }

    @Test
    public void testCapitalize_StringWithNullCharDelimiter() {
        String input = ""foo\u0000bar"";
        char[] delimiters = {'\u0000'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo\u0000Bar"", result);
    }

    @Test
    public void testCapitalize_StringWithLongLength() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.capitalize(input, null);
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(Character.isUpperCase(word.charAt(0)));
        }
    }

    @Test
    public void testCapitalize_NullDelimitersWithSpecialChars() {
        String input = ""foo-bar_baz"";
        String result = WordUtils.capitalize(input, null);
        assertEquals(""Foo-Bar_Baz"", result);
    }

    @Test
    public void testCapitalize_DelimitersWithNoMatch() {
        String input = ""foo bar"";
        char[] delimiters = {'x', 'y', 'z'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Foo bar"", result);
    }

    @Test
    public void testCapitalize_DelimitersWithAllMatch() {
        String input = ""abc"";
        char[] delimiters = {'a', 'b', 'c'};
        String result = WordUtils.capitalize(input, delimiters);
        assertEquals(""Abc"", result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_capitalize_java_lang_String_charARRAY_Test.java
org.apache.commons.lang3.text.WordUtils.uncapitalize(java.lang.String),java.lang.String uncapitalize(java.lang.String),{\n    java.lang.String str;\n    unknown $stack1;\n\n\n    str := @parameter0: java.lang.String;\n    $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])>(str; null);\n\n    return $stack1;\n}\n,Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String)> -> <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])> via $stack1 = staticinvoke <org.apache.commons.lang3.text.WordUtils: java.lang.String uncapitalize(java.lang.String;char[])>(str; null);,[public ; static ],[public ],"<p>Uncapitalizes all the whitespace separated words in a String.\nOnly the first letter of each word is changed.</p>\n\n<p>Whitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.</p>\n\n<pre>\nWordUtils.uncapitalize(null)        = null\nWordUtils.uncapitalize("")          = ""\nWordUtils.uncapitalize(I Am FINE"") = ""i am fINE""\n</pre>\n\n@param str the String to uncapitalize; may be null\n@return uncapitalized String; <code>null</code> if null String input\n@see #capitalize(String)\n""",{\n    return uncapitalize(str; null);\n},[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_uncapitalize_java_lang_String_Test {

    @Test
    public void testUncapitalize_NullInput() {
        String input = null;
        String result = WordUtils.uncapitalize(input);
        assertNull(result);
    }

    @Test
    public void testUncapitalize_EmptyString() {
        String input = """";
        String result = WordUtils.uncapitalize(input);
        assertEquals("""", result);
    }

    @Test
    public void testUncapitalize_SingleWord_AllUpperCase() {
        String input = ""HELLO"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hELLO"", result);
    }

    @Test
    public void testUncapitalize_SingleWord_AllLowerCase() {
        String input = ""hello"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello"", result);
    }

    @Test
    public void testUncapitalize_SingleWord_MixedCase() {
        String input = ""HeLLo"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""heLLo"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_NormalCase() {
        String input = ""I Am FINE"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""i am fINE"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_AlreadyUncapitalized() {
        String input = ""i am fine"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""i am fine"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_MixedCase() {
        String input = ""Java IS Fun"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""java iS fun"", result);
    }

    @Test
    public void testUncapitalize_LeadingWhitespace() {
        String input = ""  Hello World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""  hello world"", result);
    }

    @Test
    public void testUncapitalize_TrailingWhitespace() {
        String input = ""Hello World  "";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello world  "", result);
    }

    @Test
    public void testUncapitalize_MultipleConsecutiveWhitespaces() {
        String input = ""Hello   World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello   world"", result);
    }

    @Test
    public void testUncapitalize_TabAndNewlineWhitespace() {
        String input = ""Hello\tWorld\nTest"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello\tworld\ntest"", result);
    }

    @Test
    public void testUncapitalize_SingleCharacter_UpperCase() {
        String input = ""A"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""a"", result);
    }

    @Test
    public void testUncapitalize_SingleCharacter_LowerCase() {
        String input = ""a"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""a"", result);
    }

    @Test
    public void testUncapitalize_StringWithPunctuation() {
        String input = ""Hello, World!"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello, world!"", result);
    }

    @Test
    public void testUncapitalize_StringWithNumbers() {
        String input = ""123 ABC"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""123 aBC"", result);
    }

    @Test
    public void testUncapitalize_StringWithOnlyWhitespace() {
        String input = ""   "";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""   "", result);
    }

    @Test
    public void testUncapitalize_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.uncapitalize(input);
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(word.length() > 0);
            assertEquals(Character.toLowerCase('W'), word.charAt(0));
        }
    }

    @Test
    public void testUncapitalize_StringWithNonWhitespaceSeparators() {
        String input = ""Hello-World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello-World"", result);
    }

    @Test
    public void testUncapitalize_StringWithUnicodeWhitespace() {
        String input = ""Hello\u2003World""; // em space
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello\u2003world"", result);
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_uncapitalize_java_lang_String_Test {

    @Test
    public void testUncapitalize_NullInput() {
        String input = null;
        String result = WordUtils.uncapitalize(input);
        assertNull(result);
    }

    @Test
    public void testUncapitalize_EmptyString() {
        String input = """";
        String result = WordUtils.uncapitalize(input);
        assertEquals("""", result);
    }

    @Test
    public void testUncapitalize_SingleWord_AllUpperCase() {
        String input = ""HELLO"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hELLO"", result);
    }

    @Test
    public void testUncapitalize_SingleWord_AllLowerCase() {
        String input = ""hello"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello"", result);
    }

    @Test
    public void testUncapitalize_SingleWord_MixedCase() {
        String input = ""HeLLo"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""heLLo"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_NormalCase() {
        String input = ""I Am FINE"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""i am fINE"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_AlreadyUncapitalized() {
        String input = ""i am fine"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""i am fine"", result);
    }

    @Test
    public void testUncapitalize_MultipleWords_MixedCase() {
        String input = ""Java IS Fun"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""java iS fun"", result);
    }

    @Test
    public void testUncapitalize_LeadingWhitespace() {
        String input = ""  Hello World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""  hello world"", result);
    }

    @Test
    public void testUncapitalize_TrailingWhitespace() {
        String input = ""Hello World  "";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello world  "", result);
    }

    @Test
    public void testUncapitalize_MultipleConsecutiveWhitespaces() {
        String input = ""Hello   World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello   world"", result);
    }

    @Test
    public void testUncapitalize_TabAndNewlineWhitespace() {
        String input = ""Hello\tWorld\nTest"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello\tworld\ntest"", result);
    }

    @Test
    public void testUncapitalize_SingleCharacter_UpperCase() {
        String input = ""A"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""a"", result);
    }

    @Test
    public void testUncapitalize_SingleCharacter_LowerCase() {
        String input = ""a"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""a"", result);
    }

    @Test
    public void testUncapitalize_StringWithPunctuation() {
        String input = ""Hello, World!"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello, world!"", result);
    }

    @Test
    public void testUncapitalize_StringWithNumbers() {
        String input = ""123 ABC"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""123 aBC"", result);
    }

    @Test
    public void testUncapitalize_StringWithOnlyWhitespace() {
        String input = ""   "";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""   "", result);
    }

    @Test
    public void testUncapitalize_LongString() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word "");
        }
        String input = sb.toString().trim();
        String result = WordUtils.uncapitalize(input);
        String[] words = result.split("" "");
        for (String word : words) {
            assertTrue(word.length() > 0);
            assertEquals(Character.toLowerCase('W'), word.charAt(0));
        }
    }

    @Test
    public void testUncapitalize_StringWithNonWhitespaceSeparators() {
        String input = ""Hello-World"";
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello-World"", result);
    }

    @Test
    public void testUncapitalize_StringWithUnicodeWhitespace() {
        String input = ""Hello\u2003World""; // em space
        String result = WordUtils.uncapitalize(input);
        assertEquals(""hello\u2003world"", result);
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_uncapitalize_java_lang_String_Test.java
"org.apache.commons.lang3.text.WordUtils.initials(java.lang.String, char[])","java.lang.String initials(java.lang.String,char[])","{\n    char[] delimiters;\n    java.lang.String str;\n    unknown $stack10; $stack11; $stack12; $stack13; $stack14; $stack8; $stack9; buf; ch; count; i; lastWasGap; strLen;\n\n\n    str := @parameter0: java.lang.String;\n    delimiters := @parameter1: char[];\n    $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\n\n    if $stack8 == 0 goto label1;\n\n    return str;\n\n  label1:\n    if delimiters == null goto label2;\n    $stack14 = lengthof delimiters;\n\n    if $stack14 != 0 goto label2;\n\n    return "";\n\n  label2:\n    strLen = virtualinvoke str.<java.lang.String: int length()>();\n    $stack9 = strLen / 2;\n    $stack10 = $stack9 + 1;\n    buf = newarray (char)[$stack10];\n    count = 0;\n    lastWasGap = 1;\n    i = 0;\n\n  label3:\n    if i >= strLen goto label6;\n    ch = virtualinvoke str.<java.lang.String: char charAt(int)>(i);\n    $stack12 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\n\n    if $stack12 == 0 goto label4;\n    lastWasGap = 1;\n\n    goto label5;\n\n  label4:\n    if lastWasGap == 0 goto label5;\n    $stack13 = count;\n    count = count + 1;\n    buf[$stack13] = ch;\n    lastWasGap = 0;\n\n  label5:\n    i = i + 1;\n\n    goto label3;\n\n  label6:\n    $stack11 = new java.lang.String;\n    specialinvoke $stack11.<java.lang.String: void <init>(char[];int;int)>(buf; 0; count);\n\n    return $stack11;\n}\n",Call:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: int length()> via strLen = virtualinvoke str.<java.lang.String: int length()>();\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: char charAt(int)> via ch = virtualinvoke str.<java.lang.String: char charAt(int)>(i);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])> via $stack12 = staticinvoke <org.apache.commons.lang3.text.WordUtils: boolean isDelimiter(char;char[])>(ch; delimiters);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <java.lang.String: void <init>(char[];int;int)> via specialinvoke $stack11.<java.lang.String: void <init>(char[];int;int)>(buf; 0; count);\nCall:<org.apache.commons.lang3.text.WordUtils: java.lang.String initials(java.lang.String;char[])> -> <org.apache.commons.lang3.StringUtils: void <clinit>()> via $stack8 = staticinvoke <org.apache.commons.lang3.StringUtils: boolean isEmpty(java.lang.CharSequence)>(str);,[public ; static ],[public ],"<p>Extracts the initial letters from each word in the String.</p>\n\n<p>The first letter of the string and all first letters after the\ndefined delimiters are returned as a new string.\nTheir case is not changed.</p>\n\n<p>If the delimiters array is null; then Whitespace is used.\nWhitespace is defined by {@link Character#isWhitespace(char)}.\nA <code>null</code> input String returns <code>null</code>.\nAn empty delimiter array returns an empty String.</p>\n\n<pre>\nWordUtils.initials(null; *)                = null\nWordUtils.initials(""; *)                  = ""\nWordUtils.initials(Ben John Lee""; null)   = ""BJL""\nWordUtils.initials(""Ben J.Lee""; null)      = ""BJ""\nWordUtils.initials(""Ben J.Lee""; [' ';'.']) = ""BJL""\nWordUtils.initials(*; new char[0])         = """"\n</pre>\n\n@param str the String to get initials from; may be null\n@param delimiters set of characters to determine words; null means whitespace\n@return String of initial letters; <code>null</code> if null String input\n@see #initials(String)\n@since 2.2\n""","{\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return "";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch; delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n            continue;\n        }\n    }\n    return new String(buf; 0; count);\n}",[import org.apache.commons.lang3.StringUtils;\n; import org.apache.commons.lang3.SystemUtils;\n],<p>Operations on Strings that contain words.</p>\n\n<p>This class tries to handle <code>null</code> input gracefully.\nAn exception will not be thrown for a <code>null</code> input.\nEach method documents its behaviour in more detail.</p>\n\n@since 2.0\n@version $Id$\n,"/**\n * <p><code>WordUtils</code> instances should NOT be constructed in\n * standard programming. Instead; the class should be used as\n * <code>WordUtils.wrap(foo bar""; 20);</code>.</p>\n *\n * <p>This constructor is public to permit tools that require a JavaBean\n * instance to operate.</p>\n */\npublic WordUtils() {\n    super();\n}\n""","```java
package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_initials_java_lang_String_char_ARRAY_Test {

    // Helper: Provide a minimal isDelimiter implementation for test purposes
    // since initials() is static and calls isDelimiter() statically.
    // We'll use reflection to override isDelimiter for edge-case testing if needed.
    // But for now, we assume the real WordUtils.isDelimiter(char, char[]) is present.

    @Test
    public void testInitials_NullString_ReturnsNull() {
        assertNull(WordUtils.initials(null, new char[] { ' ' }));
    }

    @Test
    public void testInitials_EmptyString_ReturnsEmptyString() {
        assertEquals("""", WordUtils.initials("""", new char[] { ' ' }));
    }

    @Test
    public void testInitials_NullDelimiters_WhitespaceDefault() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee"", null));
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee"", null));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee"", null));
        assertEquals("""", WordUtils.initials(""   "", null));
    }

    @Test
    public void testInitials_EmptyDelimiters_ReturnsEmptyString() {
        assertEquals("""", WordUtils.initials(""Any String"", new char[0]));
        assertEquals("""", WordUtils.initials("""", new char[0]));
        assertEquals("""", WordUtils.initials(null, new char[0]));
    }

    @Test
    public void testInitials_WithCustomDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben J.Lee"", new char[] { ' ', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee"", new char[] { ' ', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben.J.Lee"", new char[] { '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben-J-Lee"", new char[] { '-' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben*J*Lee"", new char[] { '*' }));
    }

    @Test
    public void testInitials_SingleWord() {
        assertEquals(""B"", WordUtils.initials(""Ben"", null));
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { ' ' }));
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { ' ', '.' }));
    }

    @Test
    public void testInitials_LeadingAndTrailingDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""  Ben John Lee  "", null));
        assertEquals(""BJL"", WordUtils.initials(""..Ben.John.Lee.."", new char[] { '.' }));
        assertEquals(""BJL"", WordUtils.initials(""  Ben  John  Lee  "", new char[] { ' ' }));
    }

    @Test
    public void testInitials_MultipleConsecutiveDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben  John   Lee"", null));
        assertEquals(""BJL"", WordUtils.initials(""Ben..John...Lee"", new char[] { '.' }));
    }

    @Test
    public void testInitials_AllDelimiters() {
        assertEquals("""", WordUtils.initials(""   "", null));
        assertEquals("""", WordUtils.initials(""..."", new char[] { '.' }));
        assertEquals("""", WordUtils.initials(""   "", new char[] { ' ' }));
    }

    @Test
    public void testInitials_NoDelimitersInString() {
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { '.' }));
        assertEquals(""Ben"", WordUtils.initials(""Ben"", new char[] { }));
    }

    @Test
    public void testInitials_NonWhitespaceDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben*John*Lee"", new char[] { '*' }));
        assertEquals(""BJL"", WordUtils.initials(""*Ben*John*Lee*"", new char[] { '*' }));
    }

    @Test
    public void testInitials_UnicodeDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\u2028John\u2028Lee"", new char[] { '\u2028' }));
    }

    @Test
    public void testInitials_EmptyString_NullDelimiters() {
        assertEquals("""", WordUtils.initials("""", null));
    }

    @Test
    public void testInitials_SingleCharString() {
        assertEquals(""B"", WordUtils.initials(""B"", null));
        assertEquals(""B"", WordUtils.initials(""B"", new char[] { ' ' }));
        assertEquals(""B"", WordUtils.initials(""B"", new char[] { '.' }));
    }

    @Test
    public void testInitials_StringWithNoWords() {
        assertEquals("""", WordUtils.initials(""     "", null));
        assertEquals("""", WordUtils.initials(""....."", new char[] { '.' }));
    }

    @Test
    public void testInitials_StringWithMixedDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben-J.Lee"", new char[] { '-', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben J.Lee"", new char[] { ' ', '.' }));
    }

    @Test
    public void testInitials_StringWithTabsAndNewlines() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\tJohn\nLee"", null));
    }

    @Test
    public void testInitials_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word"").append(i).append("" "");
        }
        String result = WordUtils.initials(sb.toString(), null);
        assertEquals(1000, result.length());
        for (int i = 0; i < 1000; i++) {
            assertEquals('W', result.charAt(i));
        }
    }

    @Test
    public void testInitials_StringWithSpecialCharacters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben@John#Lee"", new char[] { '@', '#' }));
    }

    @Test
    public void testInitials_DelimitersAreWhitespaceAndNonWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John-Lee"", new char[] { ' ', '-' }));
    }

    @Test
    public void testInitials_DelimitersArrayContainsDuplicates() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee"", new char[] { ' ', ' ', ' ' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben.John.Lee"", new char[] { '.', '.', '.' }));
    }

    @Test
    public void testInitials_DelimitersArrayIsNullAndStringIsNull() {
        assertNull(WordUtils.initials(null, null));
    }

    @Test
    public void testInitials_DelimitersArrayIsNullAndStringIsEmpty() {
        assertEquals("""", WordUtils.initials("""", null));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsNull() {
        assertEquals("""", WordUtils.initials(null, new char[0]));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsEmpty() {
        assertEquals("""", WordUtils.initials("""", new char[0]));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsWhitespace() {
        assertEquals("""", WordUtils.initials(""   "", new char[0]));
    }
}
```","package org.apache.commons.lang3.text;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;
import org.junit.Test;
import static org.junit.Assert.*;

public class WordUtils_initials_java_lang_String_char_ARRAY_Test {

    // Helper: Provide a minimal isDelimiter implementation for test purposes
    // since initials() is static and calls isDelimiter() statically.
    // We'll use reflection to override isDelimiter for edge-case testing if needed.
    // But for now, we assume the real WordUtils.isDelimiter(char, char[]) is present.

    @Test
    public void testInitials_NullString_ReturnsNull() {
        assertNull(WordUtils.initials(null, new char[] { ' ' }));
    }

    @Test
    public void testInitials_EmptyString_ReturnsEmptyString() {
        assertEquals("""", WordUtils.initials("""", new char[] { ' ' }));
    }

    @Test
    public void testInitials_NullDelimiters_WhitespaceDefault() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee"", null));
        assertEquals(""BJ"", WordUtils.initials(""Ben J.Lee"", null));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee"", null));
        assertEquals("""", WordUtils.initials(""   "", null));
    }

    @Test
    public void testInitials_EmptyDelimiters_ReturnsEmptyString() {
        assertEquals("""", WordUtils.initials(""Any String"", new char[0]));
        assertEquals("""", WordUtils.initials("""", new char[0]));
        assertEquals("""", WordUtils.initials(null, new char[0]));
    }

    @Test
    public void testInitials_WithCustomDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben J.Lee"", new char[] { ' ', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben J. Lee"", new char[] { ' ', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben.J.Lee"", new char[] { '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben-J-Lee"", new char[] { '-' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben*J*Lee"", new char[] { '*' }));
    }

    @Test
    public void testInitials_SingleWord() {
        assertEquals(""B"", WordUtils.initials(""Ben"", null));
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { ' ' }));
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { ' ', '.' }));
    }

    @Test
    public void testInitials_LeadingAndTrailingDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""  Ben John Lee  "", null));
        assertEquals(""BJL"", WordUtils.initials(""..Ben.John.Lee.."", new char[] { '.' }));
        assertEquals(""BJL"", WordUtils.initials(""  Ben  John  Lee  "", new char[] { ' ' }));
    }

    @Test
    public void testInitials_MultipleConsecutiveDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben  John   Lee"", null));
        assertEquals(""BJL"", WordUtils.initials(""Ben..John...Lee"", new char[] { '.' }));
    }

    @Test
    public void testInitials_AllDelimiters() {
        assertEquals("""", WordUtils.initials(""   "", null));
        assertEquals("""", WordUtils.initials(""..."", new char[] { '.' }));
        assertEquals("""", WordUtils.initials(""   "", new char[] { ' ' }));
    }

    @Test
    public void testInitials_NoDelimitersInString() {
        assertEquals(""B"", WordUtils.initials(""Ben"", new char[] { '.' }));
        assertEquals(""Ben"", WordUtils.initials(""Ben"", new char[] { }));
    }

    @Test
    public void testInitials_NonWhitespaceDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben*John*Lee"", new char[] { '*' }));
        assertEquals(""BJL"", WordUtils.initials(""*Ben*John*Lee*"", new char[] { '*' }));
    }

    @Test
    public void testInitials_UnicodeDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\u2028John\u2028Lee"", new char[] { '\u2028' }));
    }

    @Test
    public void testInitials_EmptyString_NullDelimiters() {
        assertEquals("""", WordUtils.initials("""", null));
    }

    @Test
    public void testInitials_SingleCharString() {
        assertEquals(""B"", WordUtils.initials(""B"", null));
        assertEquals(""B"", WordUtils.initials(""B"", new char[] { ' ' }));
        assertEquals(""B"", WordUtils.initials(""B"", new char[] { '.' }));
    }

    @Test
    public void testInitials_StringWithNoWords() {
        assertEquals("""", WordUtils.initials(""     "", null));
        assertEquals("""", WordUtils.initials(""....."", new char[] { '.' }));
    }

    @Test
    public void testInitials_StringWithMixedDelimiters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben-J.Lee"", new char[] { '-', '.' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben J.Lee"", new char[] { ' ', '.' }));
    }

    @Test
    public void testInitials_StringWithTabsAndNewlines() {
        assertEquals(""BJL"", WordUtils.initials(""Ben\tJohn\nLee"", null));
    }

    @Test
    public void testInitials_LargeInput() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(""Word"").append(i).append("" "");
        }
        String result = WordUtils.initials(sb.toString(), null);
        assertEquals(1000, result.length());
        for (int i = 0; i < 1000; i++) {
            assertEquals('W', result.charAt(i));
        }
    }

    @Test
    public void testInitials_StringWithSpecialCharacters() {
        assertEquals(""BJL"", WordUtils.initials(""Ben@John#Lee"", new char[] { '@', '#' }));
    }

    @Test
    public void testInitials_DelimitersAreWhitespaceAndNonWhitespace() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John-Lee"", new char[] { ' ', '-' }));
    }

    @Test
    public void testInitials_DelimitersArrayContainsDuplicates() {
        assertEquals(""BJL"", WordUtils.initials(""Ben John Lee"", new char[] { ' ', ' ', ' ' }));
        assertEquals(""BJL"", WordUtils.initials(""Ben.John.Lee"", new char[] { '.', '.', '.' }));
    }

    @Test
    public void testInitials_DelimitersArrayIsNullAndStringIsNull() {
        assertNull(WordUtils.initials(null, null));
    }

    @Test
    public void testInitials_DelimitersArrayIsNullAndStringIsEmpty() {
        assertEquals("""", WordUtils.initials("""", null));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsNull() {
        assertEquals("""", WordUtils.initials(null, new char[0]));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsEmpty() {
        assertEquals("""", WordUtils.initials("""", new char[0]));
    }

    @Test
    public void testInitials_DelimitersArrayIsEmptyAndStringIsWhitespace() {
        assertEquals("""", WordUtils.initials(""   "", new char[0]));
    }
}
",src/test/java/org/apache/commons/lang3/text/WordUtils_initials_java_lang_String_char_ARRAY_Test.java
